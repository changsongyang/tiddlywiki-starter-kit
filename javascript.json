[{"title":"200-304","text":"HTTP 状态码中的\"200\"和\"304\"分别表示不同的含义。\r\n\r\n\"200 OK\"表示请求成功，服务器已成功处理请求并返回所请求的资源。这是一种正常的响应状态码，表示服务器已经成功地处理了请求。\r\n\r\n\"304 Not Modified\"表示在条件 GET 请求中，资源未发生变化，客户端可以使用缓存的版本。这通常是在使用缓存的情况下使用的状态码，用于减少不必要的数据传输。服务器告诉客户端它可以继续使用之前缓存的版本，而不需要从服务器重新下载。\r\n\r\n总结起来，\"200 OK\"表示请求成功并返回资源，而\"304 Not Modified\"表示资源未修改，可以继续使用缓存的版本。","type":"text/markdown","created":"20230816142531444","creator":"oeyoews","modified":"20230816142544987","modifier":"oeyoews","tags":"JavaScript"},{"title":"ajax-fetch-axios","text":"_Ajax、Fetch 和 Axios_ 都是用于在 Web 应用程序中进行异步数据请求和处理的技术。虽然它们都可以实现类似的功能，但它们之间也有很多区别。以下是这些技术的一些主要区别：\r\n\r\n- Ajax 是一个基于原生 XMLHttpRequest 对象的技术，用于发起 HTTP 请求并处理响应。它需要手动编写较多的代码来设置请求和处理响应，并且通常需要依赖回调函数来处理异步操作。\r\n- Fetch 是一个基于 Promise 的 API，用于通过 Fetch API 发起 HTTP 请求并处理响应。相比于原生的 Ajax 技术，Fetch API 更简洁、更易于使用，并且支持流式响应、跨站资源共享（CORS）等特性。\r\n- Axios 是一个开源的基于 Promise 的 HTTP 客户端库，可用于发送 HTTP 请求并处理响应。与 Fetch 不同，Axios 具有内置的请求取消、错误处理、拦截器、基于浏览器和 Node.js 环境的支持等特性。同时，Axios 也提供了对 Promise 和 async/await 的支持。\r\n\r\n**综上所述，Ajax 以及 Fetch 是 JavaScript 原生提供的异步请求技术，而 Axios 则是一个由第三方库封装的异步请求工具。在选择使用哪种技术时，需要根据实际需求和开发经验进行权衡和选择。**\r\n\r\n以下是使用 Ajax 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\n// 创建一个新的 XMLHttpRequest 对象\r\nconst xhr = new XMLHttpRequest();\r\n\r\n// 设置请求 URL 和方法\r\nxhr.open('GET', 'path/to/data.json');\r\n\r\n// 处理响应数据\r\nxhr.onload = function() {\r\n  if (xhr.status === 200) {\r\n    const data = JSON.parse(xhr.responseText);\r\n    console.log(data);\r\n  } else {\r\n    console.error('Request failed. Status code:', xhr.status);\r\n  }\r\n};\r\n\r\n// 发送请求\r\nxhr.send();\r\n```\r\n\r\n在上面的示例中，我们首先创建了一个新的 XMLHttpRequest 对象，并通过 `.open()` 方法设置请求的 URL 和方法。然后，我们使用 `.onload` 事件处理程序处理响应数据，并将其解析为 JSON 格式。最后，使用 `.send()` 方法发送请求。\r\n\r\n以下是使用 Fetch 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\nfetch('path/to/data.json')\r\n  .then(response => response.json())\r\n  .then(data => console.log(data))\r\n  .catch(error => console.error('Request failed:', error));\r\n```\r\n\r\n在上面的示例中，我们使用 `fetch()` 函数发送 GET 请求，并在 Promise 链中处理响应数据。如果请求成功，则将响应解析为 JSON 格式并打印到控制台上；如果请求失败，则捕获错误并打印到控制台上。\r\n\r\n以下是使用 Axios 发送 GET 请求并处理响应的示例代码：\r\n\r\n```javascript\r\naxios.get('path/to/data.json')\r\n  .then(response => console.log(response.data))\r\n  .catch(error => console.error('Request failed:', error));\r\n```\r\n\r\n在上面的示例中，我们使用 `axios.get()` 方法发送 GET 请求，并在 Promise 链中处理响应数据。如果请求成功，则将响应解析为 JSON 格式并打印到控制台上；如果请求失败，则捕获错误并打印到控制台上。\r\n\r\n需要注意的是，以上示例仅演示了如何使用 Ajax、Fetch 和 Axios 发送 GET 请求并处理响应。实际开发中，您可能需要使用其他 HTTP 方法（例如 POST、PUT 或 DELETE）来与服务器进行交互，并针对具体业务需求进行相关设置和处理。","type":"text/markdown","created":"20230517123356253","creator":"oeyoews","modified":"20230726045248439","modifier":"oeyoews","tags":"JavaScript"},{"title":"append-appendchild","text":"在 JavaScript 中，`append` 和 `appendChild` 是用于向 DOM（文档对象模型）中添加新元素或节点的两个常用方法，它们有一些区别和不同的用途。\r\n\r\n1. `appendChild` 方法：\r\n   - `appendChild` 是 Node 对象的方法，用于将一个节点对象作为子节点插入到目标节点的最后一个子节点位置。\r\n   - 使用 `appendChild` 方法时，需要创建一个节点对象，然后将其添加到目标节点中。\r\n   - 示例代码：\r\n     ```javascript\r\n     const parent = document.getElementById('parent'); // 获取父节点\r\n     const child = document.createElement('div'); // 创建一个子节点（div）\r\n     parent.appendChild(child); // 将子节点添加到父节点中\r\n     ```\r\n\r\n2. `append` 方法：\r\n   - `append` 是 Element 对象的方法，用于在目标元素的末尾插入一组指定的节点对象或 DOM 字符串。\r\n   - 使用 `append` 方法时，可以直接传入一个或多个节点对象、DOM 字符串或其他可以转换为节点的对象。\r\n   - 示例代码：\r\n     ```javascript\r\n     const parent = document.getElementById('parent'); // 获取父节点\r\n     const child1 = document.createElement('div'); // 创建子节点 1（div）\r\n     const child2 = document.createElement('span'); // 创建子节点 2（span）\r\n     parent.append(child1, child2); // 将多个子节点添加到父节点中\r\n     ```\r\n\r\n对比：\r\n- `appendChild` 只能将一个节点对象作为子节点添加到目标节点中，需要先创建节点对象后再使用。\r\n- `append` 可以将一个或多个节点对象或 DOM 字符串添加到目标元素中，更加灵活方便，且支持链式操作。\r\n- 注意：`append` 是较新的方法，可能在一些旧版本的浏览器中不被支持，而 `appendChild` 是较旧的方法，具有更广泛的兼容性。\r\n\r\n根据具体的需求和浏览器兼容性要求，您可以选择适合的方法来向 DOM 中添加新的内容。","type":"text/markdown","created":"20230928021738777","creator":"oeyoews","modified":"20230928021808852","modifier":"oeyoews","tags":"JavaScript"},{"title":"apply-call-bind","text":"```mermaid\n---\ntitle: apply bind call(abc)\n---\ngraph TB;\nthis --> a & b & c\na[apply] --> 数组\nb[bind] -.-> f[New Function]\nc[call] --> list\n```\n\n`call`、`apply` 和 `bind` 是 JavaScript 中的三个方法，它们都是用于改变函数的 `this` 指向。\n\n`call` 和 `apply` 的作用一样，它们都可以在指定的作用域中调用函数，并将 `this` 指向第一个参数。\n\n## apply vs call\n\n1. `call` 的参数是逐个传入的，\n2. `apply` 的参数是以数组(array, apply 都是a开头的)的形式传入的。\n\n## bind\n\n`bind` 的作用是创建一个新的函数，新函数的 `this` 指向第一个参数，后续的参数作为新函数的参数传入。与 `call` 和 `apply` 不同的是，`bind` 方法不会立即执行函数，而是返回一个新函数，需要手动调用才会执行。\n\n下面是这三个方法的用法示例：\n\n```javascript\nconst obj = {\n  name: 'Alice',\n  age: 18,\n};\n\nfunction sayHi() {\n  console.log(`Hi, my name is ${this.name}, I'm ${this.age} years old.`);\n}\n\n// 使用 call 方法调用函数\nsayHi.call(obj);\n\n// 使用 apply 方法调用函数\nsayHi.apply(obj);\n\n// 使用 bind 方法创建新函数并调用\nconst newSayHi = sayHi.bind(obj);\nnewSayHi();\n```\n\n在实际开发中，这三个方法经常用于改变函数的 `this` 指向，例如在回调函数中使用，或者在函数式编程中使用柯里化等技术。\n\n```js\nconst demo = {\n  version: 1,\n  log: function () {\n    console.log(this.version);\n  },\n};\n\nconst { log } = demo;\n// log.apply(demo, []);\n// log.bind(demo, null);\nconst bunLog = log.bind(demo);\nbunLog();\n```\n\n在这个例子中，`demo` 对象的 `log` 方法被定义为一个箭头函数。箭头函数的一个重要特点是它们继承了定义时的上下文，而不是在运行时绑定到一个新的上下文。因此，在这个例子中，箭头函数的 `this` 值将继承自它的父级上下文，即全局上下文。\n\n在这个例子中，当 `log` 方法被解构并作为独立函数调用时，它的 `this` 值将指向全局上下文，因为它的父级上下文是全局上下文。在浏览器环境中，全局上下文通常是 `window` 对象。由于 `window` 对象没有名为 `version` 的属性，因此 `console.log(this.version)` 表达式将输出 `undefined`。\n\n因此，箭头函数的 `this` 值与普通函数的 `this` 值有很大的区别。普通函数的 `this` 值在运行时根据调用方式和上下文动态绑定，而箭头函数的 `this` 值在定义时就已经确定，无法通过 `call()`、`apply()` 或 `bind()` 等方法进行修改。\n\n```js\nconst version = 1;\nconst demo = {\n  log: () => {\n    console.log(this.version);\n  },\n};\n\nconst { log } = demo;\nlog();\n```\n\n如果想使箭头函数的 `this` 值指向 `demo` 对象，可以将 `log` 方法改为普通函数，或者使用 `Function.prototype.bind()` 方法将 `log` 方法绑定到 `demo` 对象上，如下所示：\n\n```javascript\nconst demo = {\n  version: 1,\n  log: function() {\n    console.log(this.version);\n  },\n};\n\nconst { log } = demo;\nlog.bind(demo)(); // 输出：1\n```\n\n在这个例子中，`log` 方法被改为普通函数，它的 `this` 值将根据调用方式和上下文动态绑定。接下来，使用 `bind()` 方法将 `log` 方法绑定到 `demo` 对象上，并立即调用返回的新函数。这样，`log` 方法就会在 `demo` 对象的上下文中被调用，从而正确地输出 `version` 属性。","type":"text/markdown","created":"20230522105648570","creator":"oeyoews","modified":"20240130022636671","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&change-this","tags":"JavaScript"},{"title":"array-from","text":"```js\n// 虚构数组\nconst data = Array.from({ length: 10 }, (_, i) => i + 1);\n\nconst d1 = [1, 2, 3];\nconst d2 = [\n  {\n    id: 1,\n    name: 'John',\n  },\n  {\n    id: 2,\n    name: 'Jane',\n  },\n];\nconst data1 = Array.from(d1, (arr) => arr * 2);\nconst data2 = Array.from(d2, (obj) => obj.name);\nconsole.log(data, data1, data2);\n\n// data:  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n// data1: [2, 4, 6]\n// data2: [('John', 'Jane')]\n```\n\n`Array.from()` 是一个用于将类数组对象或可迭代对象（如字符串、Set、Map 等）转换为数组的方法。以下是如何使用 `Array.from()` 进行转换的示例：\n\n```javascript\n// 将字符串转换为数组\nconst str = \"Hello, World!\";\nconst arr = Array.from(str);\nconsole.log(arr); // 输出：['H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!']\n\n// 将 Set 转换为数组\nconst mySet = new Set([1, 2, 3, 4, 5]);\nconst arrFromSet = Array.from(mySet);\nconsole.log(arrFromSet); // 输出：[1, 2, 3, 4, 5]\n\n// 将 Map 转换为数组\nconst myMap = new Map([['a', 1], ['b', 2], ['c', 3]]);\nconst arrFromMap = Array.from(myMap);\nconsole.log(arrFromMap); // 输出：[['a', 1], ['b', 2], ['c', 3]]\n```\n\n你可以看到，`Array.from()` 能够将不同类型的可迭代对象转换为数组，并且你还可以提供一个可选的映射函数，用于对数组的每个元素进行转换。例如：\n\n```javascript\n// 使用映射函数将数字加倍\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = Array.from(numbers, x => x * 2);\nconsole.log(doubled); // 输出：[2, 4, 6, 8, 10]\n```\n\n这种方式可以在将类数组对象或其他可迭代对象转换为数组时非常方便。\n\n使用 `Array.from()` 方法可以很方便地虚构一个数组。你可以通过传递一个可迭代对象或类数组对象来创建一个新的数组实例。下面是一个使用 `Array.from()` 方法虚构数组的示例：\n\n```javascript\n// 虚构一个包含 1 到 5 的数组\nconst arr = Array.from({ length: 5 }, (_, index) => index + 1);\nconsole.log(arr); // 输出 [1, 2, 3, 4, 5]\n\n// 虚构一个包含 A 到 E 的数组\nconst alphabet = Array.from({ length: 5 }, (_, index) => String.fromCharCode(65 + index));\nconsole.log(alphabet); // 输出 [\"A\", \"B\", \"C\", \"D\", \"E\"]\n\n// 虚构一个包含随机数的数组\nconst randomArray = Array.from({ length: 5 }, () => Math.random());\nconsole.log(randomArray); // 输出包含 5 个随机数的数组\n```\n\n在上面的示例中，我们使用了 `Array.from()` 方法来创建了不同类型的数组。通过传递一个具有 `length` 属性的对象，我们可以指定数组的长度。然后，我们可以使用第二个参数 `mapFn` 来对数组中的每个元素进行处理，从而虚构出我们想要的数组。\n\n希望这个示例能够帮助你理解如何使用 `Array.from()` 方法来虚构数组。如果你有任何其他问题，请随时提问！","type":"text/markdown","created":"20231020135810686","creator":"oeyoews","modified":"20231220130658783","modifier":"oeyoews","tags":"JavaScript"},{"title":"array-prototype-last","created":"20230527161734029","creator":"oeyoews","modified":"20231016103720078","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"```js\n/**\n * link: https://leetcode.cn/problems/array-prototype-last/\n * Order: 2619\n * Type: Javascript\n * Description:\n * \tWrite code that enhances all arrays such that you can call the array.last() method on any array and it will return the last element. If there are no elements in the array, it should return -1.\n * \t请你编写一段代码实现一个数组方法，使任何数组都可以调用 array.last() 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 -1 。\n */\n\nArray.prototype.last = function () {\n    if (this.length === 0) { return -1; }\n    else {\n        return this[this.length - 1];\n    }\n};\n\n/**\n * const arr = [1, 2, 3];\n * arr.last(); // 3\n */\n```"},{"title":"arrow-function","text":"箭头函数（Arrow Function）是 ES6 提出的一种新的函数语法，它可以更简洁地定义函数，并且不会改变 this 的指向。\r\n\r\n箭头函数的参数有以下几种形式：\r\n\r\n1. 无参数：如果函数没有参数，那么可以在括号中省略参数部分，如下所示：\r\n\r\n   ```javascript\r\n   const sayHello = () => {\r\n     console.log('Hello');\r\n   };\r\n   \r\n   sayHello(); // 输出 \"Hello\"\r\n   ```\r\n\r\n2. 单个参数：如果函数只有一个参数，则可以省略参数括号。例如：\r\n\r\n   ```javascript\r\n   const double = x => {\r\n     return x * 2;\r\n   };\r\n   \r\n   console.log(double(5)); // 输出 10\r\n   ```\r\n\r\n3. 多个参数：如果函数有多个参数，则需要使用圆括号将这些参数括起来。例如：\r\n\r\n   ```javascript\r\n   const add = (x, y) => {\r\n     return x + y;\r\n   };\r\n   \r\n   console.log(add(2, 3)); // 输出 5\r\n   ```\r\n\r\n注意事项：\r\n\r\n- 如果只有一个参数，也可以选择加上括号，如 `(x)` 或者 `(y)`，但是不允许只有右侧的括号，如 `x)`。\r\n- 如果没有参数或者有多个参数，就必须使用圆括号。\r\n- 如果函数体只有一条语句，可以省略花括号和 return 语句，例如：\r\n\r\n  ```javascript\r\n  const add = (x, y) => x + y;\r\n  \r\n  console.log(add(2, 3)); // 输出 5\r\n  ```\r\n\r\n- 如果函数体中包含多条语句，就必须使用花括号和 return 语句。","type":"text/markdown","created":"20230506060228915","creator":"oeyoews","modified":"20230506060244599","modifier":"oeyoews","tags":"JavaScript"},{"title":"arrow-function-brackets","text":"在箭头函数中使用大括号 `{}` 的有无会影响函数的行为。\r\n\r\n如果箭头函数体内只有一条语句，你可以选择省略大括号 `{}`。这种情况下，该语句的结果将自动成为箭头函数的返回值。例如：\r\n\r\n```javascript\r\nconst add = (a, b) => a + b;\r\nconsole.log(add(1, 2)); // 输出：3\r\n```\r\n\r\n上述示例中，箭头函数 `add` 的函数体只有一条语句 `a + b`，因此可以省略大括号 `{}`。这样，函数会直接返回表达式 `a + b` 的结果。在调用 `add(1, 2)` 时，输出结果为 `3`。\r\n\r\n但是，如果箭头函数体内有多个语句，则需要使用大括号 `{}` 将这些语句包裹起来，并使用 `return` 关键字显式地返回一个值。例如：\r\n\r\n```javascript\r\nconst multiply = (a, b) => {\r\n  const result = a * b;\r\n  return result;\r\n};\r\nconsole.log(multiply(2, 3)); // 输出：6\r\n```\r\n\r\n上述示例中，箭头函数 `multiply` 的函数体有两条语句：定义变量 `result` 和返回 `result`。这时就需要使用大括号 `{}` 将这两条语句包裹起来，并使用 `return` 关键字明确地返回 `result` 的值。在调用 `multiply(2, 3)` 时，输出结果为 `6`。\r\n\r\n因此，是否在箭头函数体内使用大括号 `{}` 取决于函数体中的语句数量和你是否需要显式地返回一个值。","type":"text/markdown","created":"20230724135425766","creator":"oeyoews","modified":"20230726045248443","modifier":"oeyoews","tags":"JavaScript"},{"title":"axios-http","text":"是的，axios 可以代替 fetch 进行网络请求。虽然 fetch 在现代浏览器中已经成为了原生 API，但是它的兼容性还不够完善，而且只能基于 Promise 来处理请求结果，使用起来相对比较麻烦。\r\n\r\naxios 是一个基于 Promise 的 HTTP 客户端库，提供了丰富的 API 和配置选项，可以使得请求的配置、管理和拦截变得更加方便和灵活。axios 支持多种类型的请求（如 GET、POST、PUT、DELETE 等），支持自定义头部、请求参数、请求体等配置，同时也支持请求的取消、错误处理和超时设置等特性。\r\n\r\n以下是使用 axios 发送 GET 请求的示例代码：\r\n\r\n```javascript\r\nimport axios from 'axios';\r\n\r\naxios.get('https://api.github.com/users/octocat')\r\n  .then(response => console.log(response.data))\r\n  .catch(error => console.error(error));\r\n```\r\n\r\n上面的代码通过 axios 发送了一个 GET 请求，并在请求成功后打印出响应数据。注意，在 axios 中，响应数据被封装在 response 对象的 data 属性中，我们需要通过 response.data 来获取响应数据。\r\n\r\n由于 axios 具有更加丰富的功能和更好的可扩展性，因此在实际开发中，我们通常会优先选择 axios 来进行网络请求。","type":"text/markdown","created":"20230503024601635","creator":"oeyoews","modified":"20230503024612621","modifier":"oeyoews","tags":"JavaScript"},{"title":"bind-01","text":"`call` 和 `apply` 方法只是在函数调用时临时绑定 `this` 值，并不会对函数本身产生永久的影响。如果我们需要永久地将一个函数绑定到一个对象上，可以使用 `bind` 方法。\r\n\r\n`bind` 方法返回一个新的函数，这个函数的 `this` 值被永久绑定到指定的对象上。当调用这个新函数时，它会在绑定的对象上下文中执行，而不是在全局上下文中执行。下面是一个简单的例子：\r\n\r\n```javascript\r\nconst obj = {\r\n  name: 'Alice',\r\n  sayName() {\r\n    console.log(this.name);\r\n  },\r\n};\r\n\r\nconst boundSayName = obj.sayName.bind(obj);\r\nboundSayName(); // 输出：Alice\r\n```\r\n\r\n在这个例子中，我们定义了一个对象 `obj`，它有一个 `sayName` 方法，用于输出对象的 `name` 属性。然后，我们使用 `bind` 方法将 `sayName` 方法绑定到 `obj` 对象上，并将返回的新函数保存在变量 `boundSayName` 中。最后，我们调用 `boundSayName` 函数，它会在 `obj` 对象的上下文中执行，输出 `Alice`。\r\n\r\n需要注意的是，`bind` 方法返回的是一个新函数，它和原函数是不同的函数实例。如果对原函数的修改不会影响到绑定后的新函数。此外，一旦使用 `bind` 绑定了函数和对象，就无法再使用 `call` 或 `apply` 方法来改变绑定的对象。","type":"text/markdown","created":"20230607042346710","creator":"oeyoews","modified":"20230726045248444","modifier":"oeyoews","tags":"JavaScript"},{"title":"blur-focus-visibilitychange","text":"`visibilitychange` 事件与 `onblur` 和 `onfocus` 事件有不同的用途和触发条件：\r\n\r\n1. `visibilitychange` 事件：\r\n   - `visibilitychange` 事件是 HTML5 的一个事件，用于检测浏览器标签页或窗口的可见性状态。\r\n   - 当用户切换到其他标签页、最小化浏览器窗口或隐藏浏览器窗口时，会触发 `visibilitychange` 事件。\r\n   - 通过监听 `visibilitychange` 事件，你可以在浏览器标签页或窗口变得不可见时执行特定的操作，如暂停音频或视频播放，节省资源。\r\n\r\n2. `onblur` 和 `onfocus` 事件：\r\n   - `onblur` 和 `onfocus` 事件是针对特定的 DOM 元素（通常是表单元素或可获得焦点的元素）而言的。\r\n   - `onblur` 事件在元素失去焦点时触发，而 `onfocus` 事件在元素获得焦点时触发。\r\n   - 这些事件通常用于处理用户与页面上的特定元素的交互，例如验证表单输入或在输入框获取焦点时显示帮助文本。\r\n\r\n总结：\r\n- `visibilitychange` 事件用于监测整个浏览器窗口或标签页的可见性状态，用于全局的操作。\r\n- `onblur` 和 `onfocus` 事件用于处理特定 DOM 元素的焦点变化，通常用于改善用户交互体验和验证输入。","type":"text/markdown","created":"20230926061940157","creator":"oeyoews","modified":"20230926061958843","modifier":"oeyoews","tags":"JavaScript"},{"title":"bower","text":"Bower 是一种 Web 前端资源依赖管理工具，它可以帮助我们方便地下载、安装和更新各种 JavaScript、CSS、图像等资源文件，并将这些文件统一放到一个指定的目录中，以便于代码引用。Bower 有以下几个特点：\r\n\r\n1. 简单易用：Bower 的命令行界面非常简洁，使用起来比较容易上手。通过 bower install 命令可以快速地下载和安装所需的依赖包。\r\n\r\n2. 集成性好：Bower 提供了很多插件和工具，可以与其他常用工具（如 Grunt、Gulp、Yeoman 等）进行集成，使得整个开发环境更加完善和便捷。\r\n\r\n3. 可配置性强：Bower 支持自定义配置文件（bower.json），可以在其中指定依赖包名称、版本号、下载地址、依赖关系等信息，同时还提供了许多配置选项，可以满足不同场景下的需求。\r\n\r\n4. 社区支持广泛：Bower 拥有一个庞大的开发者社区，有许多优秀的开源项目使用 Bower 作为 Web 前端资源管理工具。同时，Bower 还提供了丰富的文档和示例，方便用户学习和使用。\r\n\r\n虽然 Bower 曾经是 Web 前端开发中最流行的资源管理工具之一，但是随着 Node.js 的流行和前端构建工具的发展，Bower 逐渐被替代。现在，许多前端开发者更倾向于使用 npm 或 yarn 来管理前端依赖包，以及使用 Webpack、Rollup 等构建工具来打包和压缩代码。","type":"text/markdown","created":"20230503031142073","creator":"oeyoews","modified":"20230503031152541","modifier":"oeyoews","tags":"JavaScript"},{"title":"btn-once","text":"```js\nbtn.addEventListener('click', () => {\n}, {\nonce: true}) \n```","type":"text/markdown","created":"20231217054838949","creator":"oeyoews","modified":"20231217054922341","modifier":"oeyoews","tags":"JavaScript"},{"title":"canvas-methods","text":"1. `toBlob()`: 这是一个 Canvas 元素的方法，它将当前 Canvas 中的图像数据转换为 Blob 对象。Blob 对象代表不可变、原始数据的片段，通常用于存储二进制数据或文件。`toBlob()`方法接受一个回调函数作为参数，该回调函数会在转换完成后被调用，并传递生成的 Blob 对象。示例代码如下：\r\n\r\n```javascript\r\ncanvas.toBlob(function(blob) {\r\n  // 在这里处理生成的 Blob 对象\r\n}, 'image/png');\r\n```\r\n\r\n2. `toDataURL()`: 这也是一个 Canvas 元素的方法，它将当前 Canvas 中的图像数据转换为一个表示图像的 Data URL 字符串。Data URL 是一种用于内联嵌入数据的 URL 格式，可以包含图像、文本等各种类型的数据。`toDataURL()`方法接受一个可选的参数，用于指定图像格式，默认为'image/png'。示例代码如下：\r\n\r\n```javascript\r\nvar dataURL = canvas.toDataURL('image/png');\r\n// 在这里使用生成的 Data URL\r\n```\r\n\r\n3. `new Blob()`: 这是 JavaScript 中的构造函数，用于创建 Blob 对象。Blob 对象可以包含任意类型的数据，例如图像、音频、视频等。`new Blob()`接受一个数组作为参数，数组中的每个元素是要包含在 Blob 中的数据块。示例代码如下：\r\n\r\n```javascript\r\nvar data = ['Hello, world!'];\r\nvar blob = new Blob(data, { type: 'text/plain' });\r\n// 在这里使用生成的 Blob 对象\r\n```\r\n","type":"text/markdown","created":"20231003033436615","creator":"oeyoews","modified":"20231003033453883","modifier":"oeyoews","tags":"JavaScript"},{"title":"ci-info-package","created":"20230910135515773","modified":"20230910135541146","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"```js\r\nimport ci from 'ci-info';\n\nswitch (ci.name) {\r\n  case 'VERCEL':\r\n    console.log('Running on Vercel');\r\n  case 'GITHUB':\r\n    console.log('Running on Github');\r\n  case 'isCI':\r\n    console.log('Running on CI');\r\n  default:\r\n    console.log('Running locally');\r\n}\r\n```"},{"title":"class-compare","text":"> [ref](https://www.bilibili.com/video/BV1UX4y1C7gQ/?spm_id_from=333.788&vd_source=d6afd7eedd9f9c940321c63f0a1539e3)\r\n\r\n```js\r\nconst Person = function (name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n};\r\nPerson.prototype.greeting = function () {\r\n  console.log(`Hi, my name is ${this.name}`);\r\n};\r\n\r\nclass P {\r\n  constructor(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n  greeting() {\r\n    console.log(`Hi, my name is ${this.name}`);\r\n  }\r\n}\r\n\r\nconst person1 = new Person(\"John\", 30);\r\nconsole.log(person1.age);\r\nperson1.greeting();\r\nconst p = new P(\"John\", 30);\r\nconsole.log(p.age);\r\np.greeting();\r\n```","type":"text/markdown","created":"20230524101743864","creator":"oeyoews","modified":"20230726045248447","modifier":"oeyoews","tags":"JavaScript"},{"title":"classList-error","text":"`classList.add` 是 JavaScript 中用于向元素的 class 列表添加一个或多个类名的方法。通常情况下，它不会报错，但有一些情况下可能会出现问题：\n\n1. **参数为空或非字符串值**：如果你尝试将一个空的字符串或非字符串值传递给 `classList.add`，它不会报错，但不会有任何效果。\n\n    ```javascript\n    element.classList.add(\"\");  // 无效操作，不会报错\n    element.classList.add(123);  // 无效操作，不会报错\n    ```\n\n2. **DOM 未加载完全**：如果你尝试在文档的 DOM 结构尚未完全加载的时候调用 `classList.add`，它也可能会无效，因为元素尚不存在。\n\n    ```javascript\n    document.addEventListener(\"DOMContentLoaded\", function() {\n        var element = document.getElementById(\"myElement\");\n        element.classList.add(\"myClass\"); // 正确的使用方式\n    });\n    ```\n\n3. **不存在的元素**：如果你尝试将类名添加到不存在的元素上，也会出现问题。\n\n    ```javascript\n    var element = document.getElementById(\"nonExistentElement\");\n    element.classList.add(\"myClass\"); // 无效操作，不会报错\n    ```\n\n总的来说，`classList.add` 主要在处理 DOM 元素时使用，因此确保元素存在并且参数是有效的字符串值，通常可以避免出现错误。如果不符合这些条件，它可能会失败，但通常不会抛出异常。","type":"text/markdown","created":"20231017012552669","creator":"oeyoews","modified":"20231017012610588","modifier":"oeyoews","tags":"JavaScript TiddlyWiki"},{"title":"cloneNode","text":"cloneNode 是一个 DOM API 中的方法，用于复制一个节点并返回它的副本。该方法可以接受一个布尔值参数 deep，表示是否复制节点的子节点。如果 deep 为 true，则会同时复制该节点的所有子孙节点，否则只复制该节点本身。\r\n\r\n> 引用; 克隆","type":"text/markdown","created":"20230609141408826","creator":"oeyoews","modified":"20230726045248448","modifier":"oeyoews","tags":"JavaScript"},{"title":"concat-array","text":"concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。","type":"text/markdown","created":"20240104082841294","creator":"oeyoews","modified":"20240104082853190","modifier":"oeyoews","tags":"JavaScript"},{"title":"cookie-localstorage","text":"> <https://github.com/florian/cookie.js>\r\n\r\nCookie 和 localStorage 是在 Web 开发中常用的两种浏览器存储技术，它们之间有以下几个主要区别：\r\n\r\n1. Cookie 的大小通常受到浏览器和服务器的限制，不能超过 4KB。而 localStorage 则可以存储更大量级的数据，通常最大可存储 5MB 的数据。\r\n\r\n2. Cookie 会随着每个 HTTP 请求自动发送到服务器，包括图片、样式表等，这可能会影响性能。而 localStorage 只存储在客户端，不会随着每个请求发送到服务器，因此对于本地数据存储来说更适合。\r\n\r\n3. Cookie 可以设置过期时间，可以是一个确定的日期或者是一个持续时间。当到达过期时间后，浏览器会自动删除该 Cookie。而 localStorage 没有过期时间，除非手动删除，否则数据将一直存在。\r\n\r\n4. 因为 Cookie 存储在客户端，所以存在一些安全风险，如 CSRF（跨站请求伪造）攻击和 XSS（跨站脚本）攻击等问题。而 localStorage 只能通过 JavaScript 访问，其安全性相对较高。\r\n\r\n根据应用场景和需求的不同，选择使用 Cookie 还是 localStorage 也不同。如果需要与服务器交互并且存储小型数据，则使用 Cookie 可能更合适；而如果要在客户端存储大型数据或敏感数据，则使用 localStorage 可能更为安全。jkgg","type":"text/markdown","created":"20230507113407126","creator":"oeyoews","modified":"20230507113650198","modifier":"oeyoews","tags":"JavaScript"},{"title":"countTime","text":"console.time\r\nconsole.timeEnd","type":"text/markdown","created":"20230913054513716","modified":"20230913054531818","tags":"JavaScript"},{"title":"create-image","text":"`new Image()` 和 `createElement('img')` 都可以用来创建一个新的 `<img>` 元素，但它们的实现方式有所不同：\r\n\r\n- `new Image()` 是使用了 `Image` 构造函数来创建一个新的 `HTMLImageElement` 对象。这个对象具有所有 `<img>` 元素的特性和方法，例如 `src` 属性用于设置图像的源，`addEventListener` 方法用于添加事件监听器等。使用 `new Image()` 创建的对象是专门用于处理图像的元素。\r\n\r\n- `createElement('img')` 是使用 DOM 的 `createElement` 方法创建一个新的元素节点，类型为 `HTMLUnknownElement`。通过给这个元素节点设置标签名为 \"img\"，我们将创建一个 `<img>` 元素。与 `new Image()` 不同，使用 `createElement('img')` 创建的元素节点在初始时是一个普通的元素节点，不具备所有针对图像的特性和方法。\r\n\r\n综上所述，如果我们需要创建一个专门用于处理图像的元素，则推荐使用 `new Image()`。但如果只是简单地创建一个 `<img>` 元素节点，则可以使用 `createElement('img')`。","type":"text/markdown","created":"20230918151828478","modified":"20230918151843612","tags":"JavaScript"},{"title":"create-style-in-js","text":"```js\n    // Create a style element\n    const style = document.createElement('style');\n    // Append the CSS styles to the style element\n    style.textContent = `\n  .resizer {\n    cursor: ew-resize;\n    background-color: #f3f3f3;\n    border-radius: 50%;\n    height: 100%;\n    width: 5px;\n    position: absolute;\n    top: 0;\n    transition: all 0.2s ease;\n  }\n  .resizer:hover {\n    background-color: #e5e5e5;\n  }\n  .dark .resizer {\n    background-color: #666;\n  }\n  .dark .resizer:hover {\n    background-color: #4d4d4d;\n  }\n`;\n    // Append the style element to the document head\n    document.head.appendChild(style);\n```","type":"text/markdown","created":"20231219125424485","creator":"oeyoews","modified":"20231219143108393","modifier":"oeyoews","tags":"JavaScript"},{"title":"cssText setProperty","text":"`cssText` 和 `setProperty` 都是用于在 JavaScript 中操作 CSS 样式的方法，它们之间有几个关键的区别：\n\n1. **用途**:\n   - `cssText`: 用于设置或获取整个 CSS 样式规则的文本表示，可以一次性设置多个属性。\n   - `setProperty`: 用于设置单个 CSS 属性的值，需要指定属性名称和对应的值。\n\n2. **粒度**:\n   - `cssText` 允许你直接操作整个样式规则的文本表示，这意味着你可以同时修改多个属性。例如：\n     ```javascript\n     element.style.cssText = \"color: red; font-size: 16px;\";\n     ```\n   - `setProperty` 更精细，它只能设置单个属性的值，你需要指定属性名称和值。例如：\n     ```javascript\n     element.style.setProperty(\"color\", \"red\");\n     element.style.setProperty(\"font-size\", \"16px\");\n     ```\n\n3. **语法**:\n   - `cssText` 的语法是直接将整个 CSS 规则的文本赋值给 `style.cssText` 属性。\n   - `setProperty` 的语法是通过方法调用，需要提供属性名称和属性值。\n\n4. **兼容性**:\n   - `cssText` 在所有主流浏览器中得到支持。\n   - `setProperty` 也得到了广泛的支持，但某些较老版本的浏览器可能不支持。因此，在跨浏览器兼容性方面，`cssText` 更为可靠一些。\n\n总的来说，如果你需要一次性设置或获取多个样式属性，可以使用 `cssText`。而如果你需要更精确地设置单个属性的值，并且对兼容性要求较高，可以使用 `setProperty`。","type":"text/markdown","created":"20240130140425716","creator":"oeyoews","modified":"20240130140510484","modifier":"oeyoews","tags":"JavaScript CSS"},{"title":"debounce","text":":::tip\ndebounce: 手机息屏\nthrottle: 闹钟定时\n:::\n\n```mermaid\ngraph LR;\n    A[用户输入事件] -->|触发事件处理函数| B[执行事件处理函数]\n    B -->|设置计时器| C{计时器是否到期}\n    C -- 是 --> D[执行事件处理函数, 更新定时器]\n    C -- 否 --> E[重置计时器]\n\t\tE --> D\n```\n\n防抖和节流都是为了减少函数的执行次数，避免频繁触发函数而影响性能。不同之处在于，防抖是在一定时间内只执行一次函数，而节流是在一定时间内间隔执行函数。\n\n以下是防抖和节流的实现代码：\n\n防抖：\n\n```javascript\nfunction debounce(func, delay) {\n  let timer = null;\n  return function() {\n    const context = this;\n    const args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(function() {\n      func.apply(context, args);\n    }, delay);\n  };\n}\n```\n\n好的，这个 `debounce` 函数的作用是用来__防止函数在短时间内多次执行__，它接收两个参数，第一个参数是要执行的函数，第二个参数是时间间隔。\n\n在函数内部，我们定义了一个变量 `timer`，用来保存定时器的引用。接着，我们返回一个函数，这个函数会在一定时间间隔后执行传入的函数。\n\n在这个返回的函数里，我们首先保存了 `this` 和 `arguments` 的值，因为在延迟执行的时候，这两个值可能会发生变化。接着，我们清除了之前设置的定时器，然后设置一个新的定时器，在一定时间间隔后执行传入的函数。\n\n在执行函数的时候，我们使用了 `apply` 方法来改变函数执行时的上下文，以及传入函数的参数。这样就能保证函数在执行时使用的是正确的上下文和参数，避免了因为上下文或参数的改变而导致的问题。\n\n通过这个 `debounce` 函数，我们就能够控制函数的执行频率，避免了在短时间内连续触发函数的情况，从而提高了代码的性能和效率。这个函数在实际开发中经常用于输入框的搜索、滚动事件等场景，能够避免频繁地进行请求和操作，提高用户体验。\n\n使用方式：\n\n```javascript\nconst debounceFn = debounce(function() {\n  console.log('debounce');\n}, 1000);\ndebounceFn();\n```\n\n节流：\n\n```javascript\nfunction throttle(func, delay) {\n  let timer = null;\n  return function() {\n    const context = this;\n    const args = arguments;\n    if (!timer) {\n      timer = setTimeout(function() {\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  };\n}\n```\n\n好的，这个 `throttle` 函数的作用是用来控制函数的执行频率，避免函数在短时间内多次执行。它接收两个参数，第一个参数是要执行的函数，第二个参数是时间间隔。\n\n在函数内部，我们定义了一个变量 `timer`，用来保存定时器的引用。接着，我们返回一个函数，这个函数会在一定时间间隔后执行传入的函数。\n\n在这个返回的函数里，我们首先检查 `timer` 是否已经存在，如果不存在，就表示现在没有定时器在运行，就可以设置一个新的定时器，并在一定时间间隔后执行传入的函数。在执行完函数之后，我们将 `timer` 设置为 `null`，这样就能保证在下一次函数执行前，`timer` 变量已经被清空了。\n\n通过这个 `throttle` 函数，我们就能够控制函数的执行频率，避免了在短时间内连续触发函数的情况，从而提高了代码的性能和效率。\n\n使用方式：\n\n```javascript\nconst throttleFn = throttle(function() {\n  console.log('throttle');\n}, 1000);\nthrottleFn();\n```\n\n```js\nconst debounce = (func, delay) => {\n        let timeoutId;\n        return (...args) => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          timeoutId = setTimeout(() => {\n            func.apply(null, args);\n          }, delay);\n        };\n      };\n```","type":"text/markdown","created":"20230519120239950","creator":"oeyoews","modified":"20240130075244795","modifier":"oeyoews","tags":"JavaScript"},{"title":"debounce-throttle","text":"```mermaid\ngraph LR;\n    A[用户输入事件] -->|触发事件处理函数| B[执行事件处理函数]\n    B -->|设置计时器| C{计时器是否到期}\n    C -- 是 --> D[执行事件处理函数, 更新定时器]\n    C -- 否 --> E[等待]\n```\n\n> https://www.bilibili.com/video/BV1dv4y117mY/?spm_id_from=333.788&vd_source=d6afd7eedd9f9c940321c63f0a1539e3\n> https://www.cnblogs.com/aurora-ql/p/13757733.html\n\n闭包的典型应用就是函数防抖(重新开始)和节流(不要打断我)\n\n> 搜索框输入, 文本实时保存(定时器实现)\n\n> 快速点击, 鼠标滑动, 下拉加载, scroll, resize, 视频播放记录时间 \n\n函数防抖（debounce）\n函数防抖，就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。\n\n简单的说，当一个动作连续触发，只执行最后一次。\n\n打个比方，坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门。\n\n函数节流（throttle）\n限制一个函数在一定时间内只能执行一次\n\n举个例子，乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入\n\n","type":"text/markdown","created":"20230412104400249","creator":"oeyoews","modified":"20240130075219634","modifier":"oeyoews","tags":"JavaScript"},{"title":"debounce-throttle-code","text":":::tip\n防抖和节流的立即执行和非立即执行版本的代码\n:::\n\n## 防抖\n\n### 立即执行版本\n\n```js\nfunction debounceImmediate(fn, wait) {\n  let timer = null; // 定义计时器，初始值为 null\n  return function (...args) {\n    // 返回一个函数，利用闭包来保存 timer 变量\n    if (timer) {\n      // 如果 timer 存在，则说明函数还在等待执行\n      clearTimeout(timer); // 清除计时器\n    } else {\n      // 如果 timer 不存在，则说明可以立即执行函数\n      fn.apply(this, args); // 执行函数，并将上下文和参数传递进去\n    }\n    timer = setTimeout(() => {\n      // 设置计时器，在规定时间后将 timer 设为 null\n      timer = null;\n    }, wait);\n  };\n}\n```\n\n这个函数实现了立即执行一次函数，并在规定的时间内限制函数的调用次数。在函数被调用时，会判断计时器是否存在，如果存在则说明函数还在等待执行，此时需要清除计时器。如果计时器不存在，则说明可以立即执行函数，并将上下文和参数传递进去。在函数执行后，会设置一个计时器，在规定时间内将计时器设为 null，从而限制接下来的函数调用。这个函数也使用了闭包来保存计时器变量，从而实现了防抖的效果。\n\n### 非立即执行版本\n\n```javascript\nfunction debounce(fn, wait) {\n  let timer = null;\n  return function (...args) {\n    const context = this;\n    timer && clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n```\n\n## 节流\n\n### 立即执行版本\n\n```js\nfunction throttleImmediate(fn, wait) {\n  let timer = null; // 定义计时器，初始值为 null\n  return function (...args) {\n    // 返回一个函数，利用闭包来保存 timer 变量\n    if (!timer) {\n      // 如果 timer 不存在，则说明可以立即执行函数\n      fn.apply(this, args); // 执行函数，并将上下文和参数传递进去\n      timer = setTimeout(() => {\n        // 设置计时器，在规定时间后将 timer 设为 null\n        timer = null;\n      }, wait);\n    }\n  };\n}\n```\n\n这个函数实现了立即执行一次函数，并在规定的时间内限制函数的调用次数。在函数被调用时，会判断计时器是否存在，如果不存在则说明可以立即执行函数。在函数执行后，会设置一个计时器，在规定时间内将计时器设为 null，从而限制接下来的函数调用。这个函数也使用了闭包来保存计时器变量，从而实现了节流的效果。\n\n### 非立即执行版本\n\n```javascript\nfunction throttle(fn, wait) {\n  let timer = null;\n  return function (...args) {\n    if (!timer) {\n      const context = this;\n      fn.apply(context, args);\n      timer = setTimeout(() => {\n        timer = null;\n      }, wait);\n    }\n  };\n}\n```\n\n在这些代码中，立即执行版本的函数会在第一次触发时立即执行，而非立即执行版本的函数会在等待一定时间后执行。这两种函数都可以根据需要使用防抖或节流功能来限制函数的执行次数。\n\n> https://juejin.cn/post/7087286029551403015\n","type":"text/markdown","created":"20230605112003013","creator":"oeyoews","modified":"20240125065846191","modifier":"oeyoews","publish":"public","tags":"JavaScript"},{"title":"debounce-throttle2","text":"JavaScript 中的防抖（debounce）是一种常用的优化技术，它可以有效地降低高频事件触发时的资源消耗和性能问题。主要是因为以下几个原因：\n\n1. 防止高频触发事件导致的性能问题：例如，当用户连续快速输入搜索关键词时，每次输入都会触发一次搜索请求，这可能会导致浏览器出现卡顿或崩溃等问题。使用防抖技术可以延迟事件处理，从而避免过多的请求和计算工作。\n\n2. 减少不必要的网络请求：例如，当用户在短时间内多次点击提交按钮时，每次点击都会触发一次表单提交操作，这可能会导致服务器端出现重复的请求或者数据丢失等问题。使用防抖技术可以确保只有最后一次点击事件被执行，从而避免重复提交。\n\n3. 提高用户体验：通过合理使用防抖技术，可以让用户获得更加流畅的交互体验，同时也能够减少冗余的操作以及对系统资源的浪费。\n\n因此，在 JavaScript 开发中，通常会使用防抖技术来控制高频事件的触发，从而提高程序的性能和稳定性。常见的防抖实现方式包括基于定时器的简单防抖和基于时间戳的立即执行防抖等。\n\n防抖和节流都是常用的事件优化技术，它们可以避免高频事件触发导致的性能问题，但它们的实现方式和使用场景有所不同：\n\n1. 防抖（debounce）：指的是在事件被触发 n 秒后才执行回调函数（如果在这段时间内事件又被触发，则重新计时），主要应用于一些高频触发事件（如窗口缩放、搜索框输入等）。通过使用防抖，可以有效地减少事件处理的次数，从而提高程序的性能和稳定性。\n\n2. 节流（throttle）：指的是在 n 秒内最多只执行一次回调函数，主要应用于一些频率较高但处理逻辑简单的事件（如鼠标滚轮、页面滚动等）。通过使用节流，可以限制事件处理的频率，从而降低计算机资源的负担，并提高程序的响应速度。\n\n总体来说，防抖和节流都是为了优化事件处理效率而产生的技术。二者的选择取决于具体的场景需求，如果是针对高频触发事件，可以考虑使用防抖；如果是针对频率较高且处理逻辑简单的事件，则可以考虑使用节流。需要注意的是，在实际应用中，还需要根据具体情况来调整防抖和节流的时间参数，以达到最佳效果。","type":"text/markdown","created":"20230513120708785","creator":"oeyoews","modified":"20240110061745663","modifier":"oeyoews","tags":"JavaScript"},{"title":"decorator","text":"装饰器函数是一种在 JavaScript 中常用的语法，它可以用来修改类、方法或属性的行为。装饰器函数通常被定义为一个函数，它接受一个类或函数作为参数，并返回一个新的类或函数。在应用装饰器函数时，我们可以使用 `@` 符号来注释一个类、方法或属性，例如：\r\n\r\n```javascript\r\n@decorator\r\nclass MyClass {\r\n  // ...\r\n}\r\n\r\nclass MyClass {\r\n  @decorator\r\n  myMethod() {\r\n    // ...\r\n  }\r\n}\r\n\r\nclass MyClass {\r\n  @decorator\r\n  myProperty = 123;\r\n}\r\n```\r\n\r\n装饰器函数可以用来实现很多功能，例如修改函数的参数、修改类的属性等等。需要注意的是，装饰器函数目前还不是 JavaScript 的标准语法，需要使用特定的工具来进行转换才能使用。","type":"text/markdown","created":"20230606093427215","creator":"oeyoews","modified":"20230726045248452","modifier":"oeyoews","tags":"JavaScript"},{"title":"defineProperty","text":"`Object.defineProperty` 是 JavaScript 中用于在对象上定义新属性或修改现有属性的方法。它的语法如下：\n\n```javascript\nObject.defineProperty(obj, prop, descriptor)\n```\n\n- `obj`: 要定义属性的对象。\n- `prop`: 要定义或修改的属性名称。\n- `descriptor`: 描述符对象，用于指定属性的特性（如可写、可枚举等）和相关的值。\n\n描述符对象 (`descriptor`) 可以包含以下属性：\n\n- `value`: 属性的值。\n- `writable`: 属性是否可写，默认为 `false`。\n- `enumerable`: 属性是否可枚举，默认为 `false`。\n- `configurable`: 属性是否可配置，默认为 `false`。\n- `get`: 获取属性值的方法。\n- `set`: 设置属性值的方法。\n\n示例：\n\n```javascript\nconst obj = {};\n\nObject.defineProperty(obj, 'name', {\n  value: 'John',\n  writable: false,\n  enumerable: true\n});\n\nconsole.log(obj.name); // 输出：\"John\"\nobj.name = 'Jane'; // 不会改变属性的值，因为 writable 为 false\n\nfor (let key in obj) {\n  console.log(key); // 输出：\"name\"\n}\n```\n\n注意：使用 `Object.defineProperty` 定义的属性是不可修改的，即无法通过赋值运算符修改其值。要修改属性值，可以使用 `Object.defineProperties` 方法定义多个属性，或者使用 `Object.assign` 方法进行浅拷贝。\n\nhttps://www.bilibili.com/video/BV1Zy4y1K7SH?p=11&vd_source=d6afd7eedd9f9c940321c63f0a1539e3","type":"text/markdown","created":"20231212100051932","creator":"oeyoews","modified":"20231212100136868","modifier":"oeyoews","tags":"JavaScript"},{"title":"delete-obj-attr","text":":::abstract\n今天才知道还有这种语法，我还是以为是 sql\n:::\n\n要从 JavaScript 对象中删除一个属性，可以使用`delete`运算符。这个运算符接受对象和要删除的属性作为操作数。以下是一个简单的示例：\n\n```javascript\nlet obj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconsole.log(obj); // 输出 { name: 'John', age: 30, city: 'New York' }\n\ndelete obj.age;\n\nconsole.log(obj); // 输出 { name: 'John', city: 'New York' }\n```\n\n在上面的示例中，我们首先创建了一个名为`obj`的对象，并设置了三个属性：`name`、`age`和`city`。然后，我们使用`delete`运算符将`age`属性从对象中删除。最后，我们再次打印对象，发现`age`属性已经被移除。\n\n需要注意的是，`delete`运算符只能删除对象自身的属性，不能删除继承的属性或变量。另外，如果尝试删除一个不存在的属性，不会产生错误，而只是什么都不会发生。\n\n```javascript\ndelete obj.nonExistentProperty; // 不会产生错误，什么都不会发生\n```\n\n希望这可以帮助你理解如何从 JavaScript 对象中删除属性。","type":"text/markdown","created":"20231101015636027","creator":"oeyoews","modified":"20231101015734228","modifier":"oeyoews","tags":"JavaScript"},{"title":"design-mode","text":"前端开发中常用的设计模式有以下几种：\r\n\r\n1. 单例模式（Singleton Pattern）：单例模式是指保证一个类仅有一个实例，并提供一个全局的访问点。它通常用于管理全局资源、配置信息、日志等。在 JavaScript 中，可以通过闭包和模块化的方式来实现单例模式。\r\n\r\n2. 工厂模式（Factory Pattern）：工厂模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。它将对象的创建延迟到子类中进行，从而避免了在代码中显式地引用具体类。常用于创建一些复杂的对象。\r\n\r\n3. 观察者模式（Observer Pattern）：观察者模式是指定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。常用于解决对象间的耦合问题，可以实现松耦合的设计。\r\n\r\n4. 装饰器模式（Decorator Pattern）：装饰器模式是指动态地给一个对象添加一些额外的职责，而不需要修改它的原始代码。它通过包装一个对象来扩展它的功能，从而避免了继承带来的静态性和不可扩展性。常用于增强对象的功能和可维护性。\r\n\r\n5. 策略模式（Strategy Pattern）：策略模式是指定义一系列算法，将每个算法都封装起来，并使它们可以相互替换。它可以让算法的变化独立于使用它的客户端，从而提高代码的灵活性和可维护性。常用于实现一些动态的算法和逻辑。\r\n\r\n6. 命令模式（Command Pattern）：命令模式是指将一个请求封装成一个对象，从而使你可以用不同的请求对客户端进行参数化。它可以将请求的发送者和接收者解耦，从而提高系统的灵活性和可扩展性。常用于实现一些可撤销的操作和日志记录。\r\n\r\n这些设计模式在前端开发中都有着广泛的应用，可以帮助我们更好地组织代码、降低耦合、提高可维护性和可扩展性。不同的设计模式适用于不同的场景和需求，我们需要根据实际情况来选择合适的模式来进行开发。希望这个解释能够帮助您更好地了解前端常用的设计模式。\r\n\r\n好的，让我来举几个前端开发中常用的设计模式的例子：\r\n\r\n1. 单例模式：在前端开发中，单例模式常用于管理全局资源、配置信息和日志等。例如，我们可以通过创建一个全局的 Logger 对象来实现日志的记录和管理：\r\n\r\n```js\r\nclass Logger {\r\n  constructor() {\r\n    this.log = [];\r\n  }\r\n\r\n  add(message) {\r\n    this.log.push(message);\r\n  }\r\n\r\n  print() {\r\n    console.log(this.log.join('\\n'));\r\n  }\r\n\r\n  static getInstance() {\r\n    if (!Logger.instance) {\r\n      Logger.instance = new Logger();\r\n    }\r\n    return Logger.instance;\r\n  }\r\n}\r\n\r\nconst logger = Logger.getInstance();\r\nlogger.add('Hello');\r\nlogger.add('World');\r\nlogger.print();\r\n```\r\n\r\n```javascript\r\nconst Logger = (function () {\r\n  let instance;\r\n\r\n  function createInstance() {\r\n    const log = [];\r\n\r\n    function add(message) {\r\n      log.push(message);\r\n    }\r\n\r\n    function print() {\r\n      console.log(log.join('\\n'));\r\n    }\r\n\r\n    return {\r\n      add,\r\n      print,\r\n    };\r\n  }\r\n\r\n  return {\r\n    getInstance: function () {\r\n      if (!instance) {\r\n        instance = createInstance();\r\n      }\r\n      return instance;\r\n    },\r\n  };\r\n})();\r\n\r\nconst logger = Logger.getInstance();\r\nlogger.add('Hello');\r\nlogger.add('World');\r\nlogger.print();\r\n```\r\n\r\n在这个例子中，我们通过创建一个闭包来实现单例模式，保证了 Logger 对象仅有一个实例。我们在 Logger 对象中定义了一些方法，如 add 和 print，用于记录和输出日志。然后，我们通过调用 Logger.getInstance() 方法来获取 Logger 对象的实例，从而实现了全局的日志管理。\r\n\r\n2. 工厂模式：在前端开发中，工厂模式常用于创建复杂的对象和组件，例如 React 组件、Redux store 等。以下是一个简单的 React 组件工厂的例子：\r\n\r\n```javascript\r\nclass Button extends React.Component {\r\n  // Button 组件的实现\r\n}\r\n\r\nclass Input extends React.Component {\r\n  // Input 组件的实现\r\n}\r\n\r\nclass ComponentFactory {\r\n  static create(type) {\r\n    if (type === 'button') {\r\n      return Button;\r\n    } else if (type === 'input') {\r\n      return Input;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nconst ButtonComponent = ComponentFactory.create('button');\r\nconst InputComponent = ComponentFactory.create('input');\r\n```\r\n\r\n在这个例子中，我们定义了两个 React 组件 Button 和 Input，分别用于创建按钮和输入框。然后，我们创建了一个 ComponentFactory 工厂类，用于根据传入的参数来创建对应的组件。最后，我们通过调用 ComponentFactory.create('button') 和 ComponentFactory.create('input') 来获取 Button 和 Input 组件的实例，从而实现了组件的动态创建和管理。\r\n\r\n3. 观察者模式：在前端开发中，观察者模式常用于处理事件和状态的变化，例如 React 组件的生命周期、Redux store 的状态更新等。以下是一个简单的 Redux store 的观察者的例子：\r\n\r\n```javascript\r\nclass Store {\r\n  constructor() {\r\n    this.listeners = [];\r\n    this.state = {};\r\n  }\r\n\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  subscribe(listener) {\r\n    this.listeners.push(listener);\r\n  }\r\n\r\n  dispatch(action) {\r\n    this.state = reducer(this.state, action);\r\n    this.listeners.forEach((listener) => listener(this.state));\r\n  }\r\n}\r\n\r\nfunction reducer(state, action) {\r\n  // 处理 state 和 action，返回新的 state\r\n}\r\n\r\nconst store = new Store();\r\n\r\nstore.subscribe((state) => {\r\n  console.log('State has changed:', state);\r\n});\r\n\r\nstore.dispatch({ type: 'INCREMENT' });\r\n```\r\n\r\n在这个例子中，我们定义了一个 Redux store 的类 Store，用于管理应用的状态。我们在 Store 类中定义了 getState、subscribe 和 dispatch 等方法，用于获取状态、添加观察者和派发 action。然后，我们在 store 对象上添加了一个观察者函数来监听状态的变化。最后，我们调用 store.dispatch({ type: 'INCREMENT' }) 来触发状态的变化，从而实现了观察者模式的应用。\r\n\r\n希望这些例子能够帮助您更好地理解前端常用的设计模式，以及如何在实际开发中应用它们。","type":"text/markdown","created":"20230601030750449","creator":"oeyoews","modified":"20230726045248452","modifier":"oeyoews","tags":"JavaScript"},{"title":"difference-template-var","text":"```js\r\nconst tags = [\"想法\", \"任务\", \"工作\", \"生活\", \"其他\"];\r\nconsole.log(`${tags}`);\r\nconsole.log(tags);\r\n```\r\n\r\n模板字符串会自动将数组转换成字符串","type":"text/markdown","created":"20230908111439790","creator":"oeyoews","modified":"20230908111523283","modifier":"oeyoews","tags":"JavaScript"},{"title":"dispatchEvent","created":"20230604024022812","creator":"oeyoews","modified":"20230918114409537","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"`dispatchEvent` 和 `addEventListener` 都是 JavaScript 中的 DOM API，但它们的作用不同。\n\n`addEventListener` 方法用于为元素添加事件监听器，以响应用户的操作。事件监听器可以在元素上监听各种 DOM 事件，例如 `click`、`mouseover`、`keydown` 等等。当指定的事件在元素上发生时，事件监听器会自动被触发，执行相应的代码。例如：\n\n```javascript\r\nconst myButton = document.querySelector('#myButton');\r\nmyButton.addEventListener('click', () => {\r\n  console.log('按钮被单击了');\r\n});\r\n```\n\n在这个示例中，我们使用 `addEventListener` 方法为一个按钮元素添加了一个单击事件监听器。当用户单击这个按钮时，事件监听器会被触发，输出 `'按钮被单击了'`。\n\n`dispatchEvent` 方法用于手动触发指定元素上的指定事件。通过调用 `dispatchEvent` 方法，可以模拟用户在页面上进行的各种操作，例如单击按钮、提交表单等。例如：\n\n```javascript\r\nconst myButton = document.querySelector('#myButton');\r\nconst clickEvent = new MouseEvent('click', {\r\n  bubbles: true,\r\n  cancelable: true,\r\n  view: window\r\n});\r\nmyButton.dispatchEvent(clickEvent);\r\n```\n\n在这个示例中，我们使用 `dispatchEvent` 方法手动触发了一个按钮的单击事件。由于按钮的单击事件被触发，所以控制台会输出 `'按钮被单击了'`。\n\n需要注意的是，通过 `dispatchEvent` 方法触发的事件不会触发浏览器的默认行为，除非事件对象的 `cancelable` 属性被设置为 `false`。此外，使用 `dispatchEvent` 方法触发的事件也不会触发事件冒泡，除非事件对象的 `bubbles` 属性被设置为 `true`。\n\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>dispatchEvent 示例</title>\r\n  </head>\r\n  <body>\r\n    <button id=\"myButton\">点击我触发事件</button>\n\n    <!-- JavaScript 代码 -->\r\n    <script>\r\n      // 获取按钮元素\r\n      const button = document.getElementById(\"myButton\");\n\n      // 创建自定义事件\r\n      const customEvent = new Event(\"customEvent\");\n\n      // 添加事件监听器\r\n      button.addEventListener(\"click\", function () {\r\n        console.log(\"按钮被点击了\");\n\n        // 触发自定义事件\r\n        button.dispatchEvent(customEvent);\r\n      });\n\n      // 在自定义事件上添加另一个事件监听器\r\n      button.addEventListener(\"customEvent\", function () {\r\n        console.log(\"自定义事件被触发了\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```"},{"title":"document-getElementById","text":"`getElementById` 方法只能通过 `document` 对象来调用，因为它是 Document 接口的一部分，用于在文档对象模型（DOM）中通过元素的 ID 来获取相应的元素节点。这个方法的调用形式如下：\r\n\r\n```javascript\r\nvar element = document.getElementById(\"elementId\");\r\n```\r\n\r\n在这里，`document` 是一个全局对象，代表整个文档。通过 `getElementById` 方法，你可以在文档中查找匹配指定 ID 的元素节点。这是因为 HTML 规范要求一个文档中每个 ID 都是唯一的，所以可以通过 ID 来精确地获取一个特定的元素。\r\n\r\n需要注意的是，`getElementById` 方法只在浏览器环境中可用，因为它是浏览器提供的 DOM API 的一部分。在其他 JavaScript 运行环境（例如 Node.js）中，是无法直接使用该方法的，因为那些环境没有浏览器的 DOM。","type":"text/markdown","created":"20230829135039087","creator":"oeyoews","modified":"20230829135056960","modifier":"oeyoews","tags":"JavaScript"},{"title":"double-question","text":":::tip\n如果你希望仅仅在null/undefined的时候， 认为false, use `??` 很有用， 比如空字符串的处理。 这些虚假值在 || 会被认为是false\n:::\n\nhttps://stackoverflow.com/questions/61480993/when-should-i-use-nullish-coalescing-vs-logical-or\n\n## ??\n   \"?? \"是空值合并运算符，通常用于处理可能为空或未定义的值。如果左侧的操作数是 null 或 undefined，它会返回右侧的操作数，否则返回左侧的操作数。这对于确保你有一个有效的值来使用非常有用。\n\n   例如：\n   ```javascript\n   let value = someValue ?? defaultValue;\n   ```\n\n   如果 `someValue` 有值，那么 `value` 将等于 `someValue`。如果 `someValue` 是 null 或 undefined，那么 `value` 将等于 `defaultValue`。\n\n## ||\n   \"||\" 是逻辑或操作符，用于执行逻辑或操作。它返回第一个为真的操作数，如果都是假，则返回最后一个操作数。\n\n   例如：\n   ```javascript\n   let result = expression1 || expression2;\n   ```\n\n   如果 `expression1` 为真，那么 `result` 将等于 `expression1` 的值。如果 `expression1` 为假，但 `expression2` 为真，那么 `result` 将等于 `expression2` 的值。\n\n## 总结\n\n- \"??\" 用于处理空值和未定义值，确保你有一个有效的值。\n- \"||\" 用于执行逻辑或操作，返回第一个为真的值。\n","type":"text/markdown","created":"20231014235309185","creator":"oeyoews","modified":"20240121124731571","modifier":"oeyoews","tags":"JavaScript"},{"title":"double-quote","text":"\"??\"是一个新的语法特性，也称为\"nullish coalescing operator\"，可以用于判断一个值是否为 null 或 undefined，如果是，就返回一个默认值。这个语法特性和逻辑运算符\"||\"有些类似，但是它可以明确地区分 null 和 0 或''这些\"假值\"，从而避免一些潜在的问题。例如：\r\n\r\n```js\r\nconst foo = null ?? 'default value';\r\nconsole.log(foo); // 输出'default value'\r\n\r\nconst bar = 0 || 'default value';\r\nconsole.log(bar); // 输出'default value'，这里会出现一些潜在的问题\r\n```\r\n\r\n可以看到，当我们使用\"??\"运算符时，只有在值为 null 或 undefined 时才会返回默认值，而使用逻辑运算符\"||\"时，除了 null 和 undefined 之外，其他的\"假值\"也会触发返回默认值的操作。因此，在某些情况下，使用\"??\"运算符可能会更加安全和可靠。","type":"text/markdown","created":"20230527113331431","creator":"oeyoews","modified":"20230726045248454","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&double-quote","tags":"JavaScript"},{"title":"double!!","text":"在编程中，`!!variable` 的用途是将一个值转换为相应的布尔值。这是一种常见的技巧，可以用来判断一个值是否为真或假。\r\n\r\n具体地说，`!!variable` 的作用是将 `variable` 转换为布尔类型。如果 `variable` 是一个真值（例如非空字符串、非零数字、非空对象等），则 `!!variable` 的结果为 `true`。如果 `variable` 是一个假值（例如空字符串、零、`null`、`undefined` 等），则 `!!variable` 的结果为 `false`。\r\n\r\n这种转换通常用于条件判断，例如在逻辑表达式中使用。它可以将非布尔类型的值转换为布尔类型，以便进行条件判断或逻辑运算。\r\n\r\n以下是一个示例：\r\n\r\n```javascript\r\nconst value = \"Hello\";\r\nconst booleanValue = !!value;\r\nconsole.log(booleanValue); // true\r\n```\r\n\r\n在上述示例中，将字符串 \"Hello\" 转换为布尔类型，结果为 `true`。\r\n\r\n需要注意的是，`!!variable` 的使用并不是必需的，因为在大多数情况下，JavaScript 会自动进行类型转换来进行条件判断。但是，使用 `!!` 可以明确地将值转换为布尔类型，以增加代码的可读性和清晰性。","type":"text/markdown","created":"20230709123558971","creator":"oeyoews","modified":"20230726045248455","modifier":"oeyoews","tags":"JavaScript"},{"title":"download-attr","text":"download 属性，仅仅支持同源策略，跨源就等同于 link 了","type":"text/markdown","created":"20231118053652188","creator":"oeyoews","modified":"20231118053738343","modifier":"oeyoews","tags":"JavaScript"},{"title":"dynamic-protocal","text":"`//tokinx.github.io/ViewImage/view-image.min.js` 看起来是一个文件路径或 URL 地址，可能是用于加载 JavaScript 脚本的。在这个上下文中，双斜杠 `//` 在 URL 中通常表示使用与当前页面相同的协议（通常是 HTTP 或 HTTPS），以便动态适应页面的协议。例如，如果当前页面是通过 HTTPS 访问的，那么 `//tokinx.github.io/ViewImage/view-image.min.js` 将使用 HTTPS 协议加载脚本，如果是通过 HTTP 访问的，则使用 HTTP 协议加载。\r\n\r\n这个路径或 URL 可能用于在网页中加载一个名为 `view-image.min.js` 的 JavaScript 脚本，以添加特定的功能或交互性。具体脚本的功能和用途可能需要查看脚本的文档或源代码来了解。\r\n\r\n如果您需要更多关于这个脚本的信息或有具体问题，可以提供更多上下文，我将尽力提供帮助。","type":"text/markdown","created":"20230910142329441","modified":"20230910142351199","tags":"JavaScript"},{"title":"equal and strict equal","text":"在JavaScript中，`==`和===是用于比较两个值是否相等的运算符。它们之间的主要区别在于==运算符在比较之前会对操作数进行类型转换，而===运算符会同时比较值和操作数的数据类型。\n\n==运算符被称为松散相等运算符，因为它在进行比较之前会进行类型强制转换。这意味着如果操作数的数据类型不同，JavaScript引擎会自动将其中一个操作数转换为与另一个操作数相同的类型，以便进行比较。例如：\n\n```javascript\nconst a = 100;\nconst b = '100';\nconsole.log(a == b); // 输出 true\n```\n在上面的例子中，变量a的类型是数字，变量b的类型是字符串。当我们使用双等号（==）比较这两个变量时，输出为true，因为变量a的类型在比较之前被转换为字符串类型。\n\n另一方面，===运算符被称为严格相等运算符，它不会在比较之前进行类型转换。它首先检查操作数的类型是否不同。如果类型不同，则返回false。如果类型相同，则检查值。如果值相同且不是数字，则返回true。如果两个操作数都是数字且不是NaN，并且它们的值相同，则返回true。否则返回false。\n\n因此，建议在JavaScript中使用严格相等运算符===，以避免类型转换可能导致的意外结果。","type":"text/markdown","created":"20240117160729614","creator":"oeyoews","modified":"20240117160822914","modifier":"oeyoews","tags":"JavaScript"},{"title":"equal-compare","created":"20230525133553087","creator":"oeyoews","modified":"20230525133617231","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"* ===\r\n* ==\r\n* Object.is()"},{"title":"equal-order","text":"这两个表达式都涉及到条件判断和逻辑运算符。\n\n1. mvComment.code !== 200:\n这是一个条件判断表达式，意思是当 mvComment 对象的 code 属性不等于 200 时为真。换句话说，这个条件会在 mvComment 的 code 属性不等于 200 时成立。\n\n2. !mvcomment.code === 200：\n这也是一个条件判断表达式，但它使用了逻辑非（!）运算符。首先，!mvcomment.code 会对 mvcomment.code 的值取非，然后再与 200 进行相等性比较。这个表达式的意思是，当 mvcomment.code 的值取非之后等于 200 时为真。\n\n需要注意的是，第二个表达式可能存在一些问题。因为逻辑非运算符的优先级高于相等性比较运算符，所以这个表达式会被解释为 (!mvcomment.code) === 200，而不是！(mvcomment.code === 200)。这可能不是你想要表达的意思。\n\n因此，正确的表达式应该是 mvComment.code !== 200。","type":"text/markdown","created":"20231120093326994","creator":"oeyoews","modified":"20231120093343262","modifier":"oeyoews","tags":"JavaScript"},{"title":"equals","created":"20230522034643350","creator":"oeyoews","modified":"20230522034655705","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在 JavaScript 中，`==` 和 `===` 都是用来比较两个值是否相等的运算符，但它们之间有一些区别。\n\n`==` 运算符会在比较之前进行类型转换，将两个值转换成相同的类型，然后再进行比较。这种类型转换可能会导致一些不直观的结果，例如：\n\n```javascript\r\nconsole.log(1 == \"1\"); // true\r\nconsole.log(0 == false); // true\r\nconsole.log(\"\" == false); // true\r\n```\n\n上面的例子中，`==` 运算符会将字符串 `\"1\"`、布尔值 `false` 和空字符串 `\"\"` 都转换成数值 `0` 进行比较，因此结果都是 `true`。\n\n相比之下，`===` 运算符不会进行类型转换，而是直接比较两个值是否相等。这种比较更加严格，只有在两个值的类型和值都相等时才会返回 `true`。例如：\n\n```javascript\r\nconsole.log(1 === \"1\"); // false\r\nconsole.log(0 === false); // false\r\nconsole.log(\"\" === false); // false\r\n```\n\n上面的例子中，由于类型不同，因此结果都是 `false`。\n\n因此，建议在比较两个值时，优先使用 `===` 运算符，这样可以避免类型转换带来的不确定性。"},{"title":"es6-7-8-9","text":"> ECMAScript 是一种由 Ecma International 标准化的脚本语言，也就是我们常说的 JavaScript。ECMAScript 的版本从 ES1 到 ES12 不断更新和迭代，其中主要包括以下几个版本：\r\n\r\nES6:2015 年 6 月发布，引入了大量新特性和语法糖，如箭头函数、模板字符串、解构赋值、类和模块等。\r\n\r\nES7:2016 年 6 月发布，引入了少量的新特性，如 Array.prototype.includes 和指数操作符（**）等。\r\n\r\nES8:2017 年 6 月发布，引入了 Async/Await、Object.entries()、Object.values()、String padding 等。\r\n\r\nES9:2018 年 6 月发布，引入了 Rest/Spread 属性、Promise.finally()、正则表达式具名捕获等。\r\n每个新版本都会引入更多的新特性和改进，以使得 JavaScript 的开发变得更加容易和高效。虽然不是所有浏览器都支持最新的 ECMAScript 版本，但是你可以使用 Babel 等工具将现代 JavaScript 代码转换为向下兼容的代码。","type":"text/markdown","created":"20230502123203046","creator":"oeyoews","modified":"20230726045248458","modifier":"oeyoews","tags":"JavaScript"},{"title":"event-bubble","text":"##  事件冒泡\n\nDOM 事件，也是有一个流程的。从事件触发开始到事件响应是有三个阶段。\n\n* 事件捕获阶段(外 => 里) e.preventDefault();\n* 处于目标阶段\n* 事件冒泡阶段(里 => 外) e.stopPropagation();\n\n## event 委托\n\n简单来说，就是利用事件冒泡，将某个元素上的事件委托给他的父级。\n\n### 优点\n\n* 减少内存消耗\n* 动态绑定事件\n* 减少内存消耗，优化页面性能\n\n好的，我可以举两个代码示例，来演示事件冒泡和事件委托的应用。\n\n1. 事件冒泡示例\n\n在这个示例中，我们为一个包含多个按钮的容器元素添加了一个单击事件处理程序。当用户单击任意一个按钮时，事件将从该按钮开始冒泡，最终到达容器元素，并触发事件处理程序。然后，我们使用事件对象来获取单击按钮的 ID，以便在控制台中输出。\n\n```html\n<div id=\"container\">\n  <button id=\"btn1\">按钮 1</button>\n  <button id=\"btn2\">按钮 2</button>\n  <button id=\"btn3\">按钮 3</button>\n</div>\n```\n\n```javascript\nvar container = document.getElementById('container');\n\ncontainer.addEventListener('click', function(event) {\n  if (event.target.tagName === 'BUTTON') {\n    console.log('您单击了按钮：' + event.target.id);\n  }\n});\n```\n\n当用户单击任意一个按钮时，事件将从该按钮开始冒泡，最终到达容器元素，并触发事件处理程序。然后，我们使用事件对象来获取单击按钮的 ID，以便在控制台中输出。\n\n2. 事件委托示例\n\n在这个示例中，我们为一个包含多个列表项的列表元素添加了一个单击事件处理程序。但是，我们并没有将事件处理程序直接绑定到每个列表项上，而是将它绑定到列表元素的父元素上。当用户单击任意一个列表项时，事件将冒泡到列表元素，并触发事件处理程序。然后，我们使用事件对象来获取单击列表项的内容，以便在控制台中输出。\n\n```html\n<ul id=\"list\">\n  <li>列表项 1</li>\n  <li>列表项 2</li>\n  <li>列表项 3</li>\n</ul>\n```\n\n```javascript\nvar list = document.getElementById('list');\n\nlist.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    console.log('您单击了列表项：' + event.target.textContent);\n  }\n});\n```\n\n当用户单击任意一个列表项时，事件将冒泡到列表元素，并触发事件处理程序。然后，我们使用事件对象来获取单击列表项的内容，以便在控制台中输出。\n\n希望这两个示例能够帮助您更好地理解事件冒泡和事件委托的应用。如果您有任何问题或疑问，请随时向我提问。","type":"text/markdown","created":"20230421080044107","creator":"oeyoews","modified":"20240116074121450","modifier":"oeyoews","tags":"JavaScript"},{"title":"event-objectParam","text":"<$tid2pdf />\r\n\r\n```js\r\n// 获取按钮元素\r\nconst myButton = document.getElementById('myButton');\r\n\r\n// 绑定点击事件\r\nmyButton.addEventListener('click', function(event) {\r\n  // 使用 event.objectParam 获取事件相关的信息\r\n  const button = event.target;\r\n  const buttonId = button.id;\r\n  const eventType = event.type;\r\n  const clientX = event.clientX;\r\n  const clientY = event.clientY;\r\n  \r\n  console.log('按钮 ID：', buttonId);\r\n  console.log('事件类型：', eventType);\r\n  console.log('鼠标点击位置：', clientX, clientY);\r\n});\r\n```","type":"text/markdown","created":"20230604030141179","creator":"oeyoews","modified":"20230726045248460","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&event-objectParam","tags":"JavaScript"},{"title":"false-convert","text":"转换规则是除了下面六个值被转为 false，其他值都视为 true。\r\n\r\n* undefined\r\n* null\r\n* false\r\n* 0\r\n* NaN\r\n* \"\"或''（空字符串）\r\n\r\n:::note\r\n注意，空数组（[]）和空对象（{}）对应的布尔值，都是 true。\r\n:::","type":"text/markdown","created":"20230620115015442","creator":"oeyoews","modified":"20230726045248460","modifier":"oeyoews","tags":"JavaScript"},{"title":"fetch-api","text":"Fetch API 使用 Promise 技术来处理异步操作。Fetch API 是用于异步获取资源的新标准 API，它提供了一种更现代、更简洁、更灵活的方式来处理网络请求。\r\n\r\n在 Fetch API 中，我们可以使用全局的 fetch() 函数来发起网络请求。fetch() 函数返回一个 Promise 对象，可以在异步操作成功或失败时执行回调函数。如果请求成功，Promise 对象将会 resolve 并返回一个代表响应的 Response 对象；如果请求失败，Promise 对象将会 reject 并返回一个代表错误信息的 Error 对象。\r\n\r\n以下是一个使用 Fetch API 发起网络请求的示例：\r\n\r\n```javascript\r\nfetch('https://jsonplaceholder.typicode.com/todos/1')\r\n  .then(response => {\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n    return response.json();\r\n  })\r\n  .then(data => {\r\n    console.log(data);\r\n  })\r\n  .catch(error => {\r\n    console.error('There was a problem with the fetch operation:', error);\r\n  });\r\n```\r\n\r\n使用 fetch() 函数发起一个 GET 请求，并在成功时输出响应的 JSON 数据，失败时输出错误信息。在 then 方法中，使用 response.json() 方法将响应的 JSON 数据解析为 JavaScript 对象。如果请求失败，catch 方法会捕获错误并输出错误信息。","type":"text/markdown","created":"20230523022921612","creator":"oeyoews","modified":"20230726045248461","modifier":"oeyoews","tags":"JavaScript"},{"title":"fetch-cache","text":"要了解 HTTP 协议的缓存策略，可以查看服务器返回的 HTTP 响应头中的缓存相关字段。以下是一些常见的缓存相关的响应头字段：\n\n1. Cache-Control：该字段指定了缓存的控制策略。常见的指令有：\n   - `public`：允许任何地方的缓存（包括客户端和代理服务器）缓存该响应。\n   - `private`：只允许客户端缓存该响应，不允许代理服务器缓存。\n   - `no-cache`：需要在使用缓存之前先向服务器验证是否过期。\n   - `no-store`：禁止缓存该响应，每次都需要向服务器请求最新数据。\n   - `max-age=seconds`：指定缓存的最大有效时间，以秒为单位。\n   \n2. Expires：指定了响应的过期时间，是一个具体的日期/时间。当当前时间超过过期时间时，缓存被认为是过期的。\n\n3. ETag：指定了一个唯一标识符，用于判断资源是否发生了变化。当资源没有发生变化时，可以使用缓存副本。如果服务器返回的响应中包含此字段，则客户端可以将其发送回服务器进行验证。\n\n4. Last-Modified：指定了资源的最后修改时间。与 ETag 一样，它也用于验证资源是否发生了变化。\n\n通过查看响应头中的这些字段，可以了解 HTTP 协议的缓存策略，判断是否可以使用缓存以及何时需要重新请求最新的数据。\n\n可以使用浏览器的开发者工具（如 Chrome DevTools）来查看网络请求的响应头字段，或者在代码中使用 Fetch API 或其他 HTTP 请求库获取响应头并进行分析。\n\n---\n\n在使用 Fetch API 发起网络请求的时候，可以通过设置缓存来提高性能和用户体验。Fetch API 提供了一个 `cache` 选项，可以指定请求的缓存模式。一共有 5 种缓存模式可供选择：\n\n- `default`：默认模式，采用 HTTP 协议的缓存机制；\n- `no-store`：不允许缓存，每次请求都会向服务器发送请求；\n- `reload`：强制从服务器刷新缓存，即使本地存在缓存；\n- `no-cache`：可以使用缓存，但首先必须向服务器验证缓存是否过期；\n- `force-cache`：强制使用缓存，即使它已经过期。\n\n在使用 Fetch API 的 `fetch()` 方法时，可以通过设置 `cache` 选项来指定缓存模式。例如：\n\n```javascript\nfetch(url, {\n  cache: 'no-cache'\n})\n```\n\n在上面的示例中，我们将缓存模式设置为 `no-cache`，表示可以使用缓存，但首先必须向服务器验证缓存是否过期。如果缓存未过期，则使用缓存；如果缓存已过期，则会向服务器发送请求获取最新数据。\n\n另外，还可以使用第二个参数 `init` 中的 `headers` 选项设置缓存控制头，例如：\n\n```javascript\nfetch(url, {\n  headers: {\n    'Cache-Control': 'no-cache'\n  }\n})\n```\n\n在上面的示例中，我们使用 `Cache-Control` 头设置缓存控制，将缓存模式设置为 `no-cache`。\n\n需要注意的是，如果服务器返回了有效的缓存控制头，则 Fetch API 会自动触发相应的缓存操作，不需要进行任何额外的设置。因此，在设置缓存模式时，建议同时设置合适的缓存控制头，以便在网络请求时能够正确地处理缓存。\n\n---\n\n`cache: \"no-cache\"`和`cache: \"no-store\"`是用于控制浏览器缓存行为的两个不同选项。\n\n1. `cache: \"no-cache\"`:\n   - 当设置为`\"no-cache\"`时，浏览器会发送请求到服务器进行验证，并在缓存中存储响应。\n   - 如果服务器返回的响应状态是 200，则表示响应有效，可以使用缓存中的响应。如果响应状态是其他值（如 304），则表示响应无效，需要重新从服务器获取新的响应。\n   - 这意味着浏览器会强制进行验证，但仍然允许缓存响应。\n\n2. `cache: \"no-store\"`:\n   - 当设置为`\"no-store\"`时，浏览器不会缓存任何响应，并且每次都会向服务器发送请求获取最新的数据。\n   - 响应不会被保存在浏览器的缓存中，也不会被替换或更新。\n   - 这意味着浏览器每次都会完全忽略缓存，并始终从服务器获取最新的响应。\n\n总结：\n- `\"no-cache\"`选项允许浏览器缓存响应，但需要验证响应的有效性。\n- `\"no-store\"`选项禁止浏览器缓存响应，始终请求最新的数据。\n\n---\n\n\"fetch\" 的 \"res.headers\" 是一个包含响应头信息的 Map。这个 Map 包含了响应的各种头部字段，通常用于获取有关响应的信息，比如内容类型、响应时间等。你可以使用不同的键来访问特定的响应头字段，比如：\n\n- \"Content-Type\"：响应的内容类型。\n- \"Date\"：响应的日期和时间信息。\n- \"Server\"：响应的服务器信息。\n- ...\n\n你可以通过 JavaScript 中的代码来访问这些响应头字段，例如：\n\n```javascript\nfetch('https://example.com')\n  .then(response => {\n    const contentType = response.headers.get('Content-Type');\n    const date = response.headers.get('Date');\n    const server = response.headers.get('Server');\n    \n    // 进行你的操作\n  })\n  .catch(error => {\n    console.error('发生错误：', error);\n  });\n```","type":"text/markdown","created":"20231103042151151","creator":"oeyoews","modified":"20231103043330889","modifier":"oeyoews","tags":"JavaScript"},{"title":"filter","text":"`Array.filter()` 是 JavaScript 数组提供的一个高阶函数，用于筛选数组中满足条件的元素，并返回一个新的、由满足条件的元素组成的数组。\r\n\r\n`Array.filter()` 使用一个回调函数作为参数，该回调函数接受三个参数：当前正在遍历的元素、当前元素的索引和正在遍历的数组本身。回调函数应返回一个布尔值，决定是否保留当前元素在最终的结果数组中。\r\n\r\n语法结构如下：\r\n```javascript\r\nconst newArray = array.filter((element, index, arr) => {\r\n  // 进行条件判断，返回布尔值\r\n});\r\n```\r\n\r\n- `element`：当前正在遍历的元素。\r\n- `index`：当前元素的索引（可选）。\r\n- `arr`：正在遍历的数组（可选）。\r\n\r\n例如，假设我们有一个数字数组，要筛选出其中的偶数：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5, 6];\r\n\r\nconst evenNumbers = numbers.filter((number) => {\r\n  return number % 2 === 0;\r\n});\r\n\r\nconsole.log(evenNumbers); // 输出：[2, 4, 6]\r\n```\r\n\r\n在上述例子中，回调函数 `number % 2 === 0` 用于判断元素是否为偶数，满足条件的元素将被保留在 `evenNumbers` 数组中。\r\n\r\n需要注意的是，`Array.filter()` 不会修改原始数组，而是返回一个新数组。如果不满足筛选条件，元素将被忽略。如果所有元素都不满足条件，将返回一个空数组。\r\n\r\n`Array.filter()` 是一种非常常用和灵活的数组操作方法，可以根据自己的需要编写不同的筛选条件来满足特定的需求。","type":"text/markdown","created":"20230722182023656","creator":"oeyoews","modified":"20230726045248462","modifier":"oeyoews","tags":"JavaScript"},{"title":"find-method","text":"`Array.prototype.find()` 方法是 JavaScript 数组的一个内置方法，用于在数组中查找满足给定条件的第一个元素，并返回该元素。它的语法如下：\r\n\r\n```javascript\r\narray.find(callback(element[, index[, array]])[, thisArg])\r\n```\r\n\r\n参数说明：\r\n- `callback`：回调函数，用来测试每个元素是否满足某个条件。该函数接收三个参数：\r\n  - `element`：当前正在被测试的数组元素。\r\n  - `index`（可选）：当前被测试元素的索引。\r\n  - `array`（可选）：调用 `find` 方法的数组。\r\n- `thisArg`（可选）：执行回调函数时使用的 `this` 值。\r\n\r\n返回值：\r\n- 如果找到满足条件的元素，则返回该元素。\r\n- 如果没有找到满足条件的元素，则返回 `undefined`。\r\n\r\n示例代码：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\n// 查找第一个大于 3 的数\r\nconst result = numbers.find((num) => num > 3);\r\nconsole.log(result); // 输出：4\r\n\r\n// 查找第一个索引为偶数的数\r\nconst evenIndexNum = numbers.find((num, index) => index % 2 === 0);\r\nconsole.log(evenIndexNum); // 输出：1\r\n\r\n// 在对象数组中查找 name 属性为 \"Alice\" 的对象\r\nconst users = [\r\n  { name: \"Alice\", age: 25 },\r\n  { name: \"Bob\", age: 30 },\r\n  { name: \"Charlie\", age: 35 },\r\n];\r\nconst user = users.find((user) => user.name === \"Alice\");\r\nconsole.log(user); // 输出：{ name: \"Alice\", age: 25 }\r\n```\r\n\r\n`find()` 方法在找到符合条件的元素后会停止搜索，不会继续遍历整个数组。如果需要查找所有满足条件的元素，可以使用 `filter()` 方法。","type":"text/markdown","created":"20230721155835445","creator":"oeyoews","modified":"20230726045248463","modifier":"oeyoews","tags":"JavaScript"},{"title":"floor-parseInt","text":"```mermaid\ngraph TD;\n    parseInt((parseInt))-->|字符串转整数| num[整数];\n    floor((floor))-- 向下取整 -->roundedDown[最接近的整数];\n\n    subgraph parseInt函数\n        parseInt -->  num\n    end\n\n    subgraph floor函数\n        floor -->  roundedDown\n    end\n```\n\nparseInt 是向 0 取整，Math.floor 是向下取整 2.5 -> 2 -2.5 -> -3(接近整数即可，不论正负号)\n\n:::note\n在正数范围上, 取值结果一致.\n:::","type":"text/markdown","created":"20240120160140745","creator":"oeyoews","modified":"20240131104816001","modifier":"oeyoews","tags":"JavaScript"},{"title":"for-each","created":"20230527011856513","creator":"oeyoews","modified":"20230527011907572","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"forEach 是 JavaScript 中的一个数组方法，它的作用是遍历数组中的每个元素，并执行指定的函数。该方法接受一个函数作为参数，该函数会接受三个参数：当前元素的值、当前元素的索引和数组本身。下面是一个简单的例子：\n\n```\r\nconst arr = [1, 2, 3, 4, 5];\r\narr.forEach((item, index) => {\r\n  console.log(`元素值为${item}，索引为${index}`);\r\n});\r\n```\n\n在这个例子中，我们定义了一个包含 5 个元素的数组，然后使用 forEach 方法遍历该数组，并在每次遍历时输出元素值和索引。运行结果如下：\n\n```\r\n元素值为1，索引为0\r\n元素值为2，索引为1\r\n元素值为3，索引为2\r\n元素值为4，索引为3\r\n元素值为5，索引为4\r\n```\n\n可以看到，forEach 方法遍历了整个数组，并在每次遍历时执行了指定的函数。\n\n需要注意的是，forEach 方法不会修改原数组，也不会返回任何值，它仅仅是用来遍历数组并执行指定的函数。如果需要修改原数组，可以在函数内部进行操作，或者使用其他的数组方法，例如 map、filter 等。"},{"title":"form-disabled-readonly","text":"如果 form 里面有 disable, 则 form 的 submit 全部不能用，使用 readonly 代替\r\n\r\n如果给 button 加一个 listener, 你会发现，回车的时候，button 的点击事件也被触发了 (仅仅只会触发第一个捕获到的 submit 事件 btn1)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index 17</title>\r\n  </head>\r\n  <body>\r\n    <form id=\"form\" type=\"submit\">\r\n      <button type=\"submit\" readonly=\"readonly\">点击</button>\r\n      <input type=\"text\" value=\"\" name=\"message\" />\r\n    </form>\r\n  </body>\r\n  <script charset=\"utf-8\">\r\n    const button = document.querySelector(\"button\");\r\n    button.addEventListener(\"click\", function () {\r\n      console.log(\"点击\");\r\n    });\r\n    var form = document.querySelector(\"#form\");\r\n    form.addEventListener(\"submit\", function (event) {\r\n      event.preventDefault();\r\n      console.log(\"提交\");\r\n    });\r\n  </script>\r\n</html>\r\n```\r\n\r\n```html \r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width\" />\r\n    <title>Index 17</title>\r\n  </head>\r\n  <body>\r\n    <form id=\"form\" type=\"submit\">\r\n      <input type=\"text\" value=\"\" name=\"message\" />\r\n      <button id=\"btn2\" type=\"submit\">点击</button>\r\n      <button id=\"btn1\" type=\"submit\">点击</button>\r\n    </form>\r\n  </body>\r\n  <script charset=\"utf-8\">\r\n    const button = document.querySelector(\"#btn1\");\r\n    button.addEventListener(\"click\", function () {\r\n      console.log(\"点击 btn1\");\r\n    });\r\n    const anotherbutton = document.querySelector(\"#btn2\");\r\n    anotherbutton.addEventListener(\"click\", function () {\r\n      console.log(\"点击 btn2\");\r\n    });\r\n    var form = document.querySelector(\"#form\");\r\n    form.addEventListener(\"submit\", function (event) {\r\n      event.preventDefault();\r\n      console.log(\"提交\");\r\n    });\r\n  </script>\r\n</html>\r\n```","type":"text/markdown","created":"20230908093847496","creator":"oeyoews","modified":"20230908095150286","modifier":"oeyoews","tags":"JavaScript HTML"},{"title":"full-type-support-with-plain-javascript","text":"## 使用纯 JavaScript 获得完整的类型支持\n\n* 这听起来是不是很熟悉：你想写一个小脚本——无论是用于网络、命令行工具还是其他任何东西——你从 JavaScript 开始……直到你想起编写没有类型的代码是多么痛苦。因此，您将文件从 重命名.js 为.ts… 并意识到您已经打开了一罐蠕虫。\n\n* 如果您正在为网站或图书馆编写代码，那么您需要进行编译步骤。如果你正在构建一个 CLI 脚本，你可以求助于 Deno（它支持开箱即用的 TypeScript），但是你需要设置你的 IDE 来理解 Deno API，而且混合和匹配 Deno 和节点并不总是那么容易。\n\n* 一旦一切都在本地运行，您需要考虑如何分发您的代码。你检查你的编译.js 文件吗？您是否创建了一个 CI 管道来自动编译您的.ts 文件？如果您正在编写一个库，您如何发布您的库以便其他项目可以使用它？\n\n## 你实际上并不需要 TypeScript\n\n> 问题是您无需编写 TypeScript 即可获得静态类型分析！\n\n* 通过使用 JSDoc，您可以在 JavaScript 中获得 TypeScript 的所有好处\n\n* TypeScript 提供的是静态类型系统。这意味着类型信息对运行代码没有影响。当你的 TypeScript 被执行时，所有的类型信息都完全丢失了（这就是为什么你不能在不编写类型保护的情况下测试变量是否属于某种类型的原因）。\n\n* 这也意味着 TypeScript 只是提供给 TypeScript 分析器的附加类型信息，对运行代码的 JavaScript 引擎没有任何意义。当您将 TypeScript 编译为 JavaScript 时，它基本上只是从您的代码中删除所有类型信息，因此它再次成为有效的 JavaScript 代码。\n\n## JSDoc\n\n在 25 年前 JavaScript 诞生的三年后，JSDoc 被引入作为一种注释 JavaScript 代码的方式。它是一种形式化的标记语言，允许 IDE 在开发人员看到功能时为他们提供额外的上下文。\n\n大多数语言中都存在类似的注释标记，我相信您已经知道了。这是它的样子：\n\n```js\n/**\n * This is the JSDOC block. IDEs will show this text when you hover the\n * printName function.\n *\n * @param {string} name\n */\nfunction printName(name) {\n  console.log(name)\n}\n```\n\n很少有人知道，JSDoc 是您充分利用 TypeScript 所需要的全部。TypeScript 分析器理解用 JSDoc 编写的类型，并为您提供与.ts 文件相同的静态分析。\n\nJSDoc 中类型的语法\n我不会在这里提供语法的完整文档。最重要的是你知道，几乎所有你可以在.ts 文件中做的事情，你都可以用 JSDoc 做。但这里有几个例子：\n\n具有本机类型的函数参数：\n\n```js\n/**\n * @param {string} a\n * @param {number} b\n */\nfunction foo(a, b) {}\n使用 TypeScript 开箱即用的类型：\n\n/**\n * @param {HTMLElement} element\n * @param {Window} window\n */\nfunction foo(element, window) {}\n\n/** @type {number[]} */\nlet years\n定义对象字面量和函数：\n\n/** @type {{ name: string; age: number }} */\nlet person\n\n/** @type {(s: string, b: boolean) => void} */\nlet myCallback\n*.d.ts从文件导入类型：\n\n/** @param {import('./types').User} user */\nconst deleteUser = (user) => {}\n定义一个类型供以后使用：\n\n/**\n * @typedef {object} Color\n * @property {number} chroma\n * @property {number} hue\n */\n\n/** @type {Color[]} */\nconst colors = [\n  { chroma: 0.2, hue: 262 },\n  { chroma: 0.2, hue: 28.3 },\n]\n有关详尽列表，请参阅官方TypeScript JSDoc 文档。\n```\n\n如果您有复杂的类型，您仍然可以创作您的*.d.ts 文件并将它们导入您的 JSDoc 注释中。\n\ntsconfig.json 请注意，您仍然需要为打字稿设置您的项目（和 IDE），并且您需要使用编译器选项创建一个文件 allowJs 并将 checkJs 其设置为 true：\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"allowJs\": true,\n    \"checkJs\": true\n    // ...\n  }\n}\n```\n什么时候写 TypeScript\n尽管完全使用 JSDoc 进行类型声明是可能的，但这并不是最方便的。TypeScript 语法更好，重复更少。\n\nTypeScript 团队创建了一个“类型作为注释”的 ECMAScript 提案，允许您编写 TypeScript 并在 JavaScript 引擎中运行它而无需修改（JavaScript 引擎会将这些类型注释视为注释。）\n\n但在这个提案被接受之前，我们一直坚持使用 JSDoc 或 TypeScript 工具链的决定。\n\n所以现在我的建议是：当你处理一个无论如何都有编译步骤的项目时，使用 TypeScript 没有任何缺点。这包括您想要优化生产脚本的典型网站。\n\n但如果您不需要编译步骤，那么坚持使用 JSDoc 类型注释可能更容易。这方面的例子是库和简单的脚本。\n\n> ref: https://www.pausly.app/blog/full-type-support-with-plain-javascript","type":"text/markdown","created":"20230604141122805","creator":"oeyoews","modified":"20231017085922159","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&full-type-support-with-plain-javascript","tags":"JavaScript"},{"title":"fullscreen-browsers","text":"```javascript\r\n// ==UserScript==\r\n// @name         Disable F Key in Input Fields and Toggle Full Screen\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @description  Disables the F key in all input fields on all websites and toggles full screen mode when pressing the F key outside of input fields.\r\n// @author       oeyoews\r\n// @match        *://*/*\r\n// @grant        none\r\n// ==/UserScript==\r\n\r\n(function() {\r\n    'use strict';\r\n\r\n    document.addEventListener('keydown', function(e) {\r\n        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {\r\n            return;\r\n        }\r\n        if (e.key === 'F') {\r\n            e.preventDefault();\r\n            if (document.fullscreenElement) {\r\n                document.exitFullscreen();\r\n            } else {\r\n                document.documentElement.requestFullscreen();\r\n            }\r\n        }\r\n    });\r\n})();\r\n```\r\n\r\n```javascript\r\n(function() {\r\n    'use strict';\r\n\r\n    let altKeyPressed = false;\r\n\r\n    document.addEventListener('keydown', function(e) {\r\n        if (e.key === 'Alt') {\r\n            altKeyPressed = true;\r\n        }\r\n        if (e.keyCode === 70 && altKeyPressed) {\r\n            e.preventDefault();\r\n            if (document.fullscreenElement) {\r\n                document.exitFullscreen();\r\n            } else {\r\n                document.documentElement.requestFullscreen();\r\n            }\r\n        }\r\n    });\r\n\r\n    document.addEventListener('keyup', function(e) {\r\n        if (e.key === 'Alt') {\r\n            altKeyPressed = false;\r\n        }\r\n    });\r\n})();\r\n```","type":"text/markdown","created":"20230424161844327","creator":"oeyoews","modified":"20230429080021953","modifier":"oeyoews","tags":"JavaScript"},{"title":"function-adjust","created":"20230521040356046","creator":"oeyoews","modified":"20230521040411100","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在JavaScript中，可以使用typeof运算符或者直接判断函数名的方式来判断一个函数是否存在。\n\n1. 使用typeof运算符：\n\n```js\r\nif (typeof functionName === 'function') {\r\n  // 函数存在，执行相关操作\r\n} else {\r\n  // 函数不存在或者不是一个函数类型\r\n}\r\n```\n\n2. 直接判断函数名：\n\n```js\r\nif (window.functionName) {\r\n  // 函数存在，执行相关操作\r\n} else {\r\n  // 函数不存在\r\n}\r\n```\n\n需要注意的是，在浏览器环境下，全局函数通常会被定义在window对象中。因此，我们可以通过window对象来访问和判断全局函数是否存在。如果在其他环境下使用，可能需要针对不同的上下文对象进行处理。\n\n另外，如果需要判断某个函数是否为对象的属性，也可以使用in运算符。例如：\n\n```js\r\nconst obj = {\r\n  foo() {\r\n    console.log('Hello, world!');\r\n  }\r\n};\n\nif ('foo' in obj) {\r\n  obj.foo(); // Hello, world!\r\n} else {\r\n  console.log('Function not found.');\r\n}\r\n```\n\n在这个例子中，我们通过in运算符来判断obj对象是否包含名为`foo`的函数，如果存在，则调用该函数。"},{"title":"generateCharacter","text":"```js\nlet result = Array.from({length:75},(_,i)=>String.fromCharCode(i+48)).sort().filter(c=>/[A-Za-z0-9]/.test(c)).join('');\nconsole.log(result);\n```\n\n在上面提供的 JavaScript 代码中，`Array.from({length:75},(_,i)=>String.fromCharCode(i+48))` 是用于创建包含字符的数组的部分。\n\n让我对这段代码进行解释：\n\n1. `Array.from({length:75}, (_, i) => String.fromCharCode(i + 48))`: 这一部分使用 `Array.from` 方法创建了一个长度为 75 的数组。在这个数组中，第二个参数的回调函数 `(_, i) => String.fromCharCode(i + 48)` 被调用了 75 次。这个回调函数的目的是生成字符，`String.fromCharCode(i + 48)` 则将 ASCII 码为 `i + 48` 的字符转换为字符串。\n\n2. `.sort()`: 接下来，对生成的字符数组进行排序。\n\n3. `.filter(c => /[A-Za-z0-9]/.test(c))`: 使用 `filter` 方法过滤掉不是大写字母、小写字母或数字的字符。\n\n4. `.join('')`: 最后，使用 `join('')` 方法将过滤后的字符数组连接成一个字符串。\n\n这一行代码的目的是创建一个包含排序且只包含大写字母、小写字母和数字的字符串。\n\n在上述 JavaScript 代码中，`test` 是 JavaScript 中正则表达式对象的一个方法。该方法用于测试一个字符串是否匹配正则表达式，并返回一个布尔值。\n\n在具体的例子中，`/[A-Za-z0-9]/.test(c)` 这一部分使用正则表达式来测试字符 `c` 是否是大写字母、小写字母或数字。正则表达式 `[A-Za-z0-9]` 匹配任何一个大写字母、小写字母或数字。如果 `c` 包含在这个范围内，`test` 方法返回 `true`，否则返回 `false`。\n\n因此，`.filter(c => /[A-Za-z0-9]/.test(c))` 的作用是过滤掉那些不是大写字母、小写字母或数字的字符，保留符合条件的字符。","type":"text/markdown","created":"20231220125555973","creator":"oeyoews","modified":"20231220125700086","modifier":"oeyoews","tags":"JavaScript"},{"title":"get-port","text":"get-port 和 get-port-please 都是 Node.js 中的模块，用于获取可用的端口号。它们的主要区别在于 get-port-please 是 get-port 的扩展，提供了额外的功能和选项。\n\nget-port 可以自动查找当前系统中未使用的端口号，并返回一个 Promise 对象，该对象的解析值为可用的端口号。使用 get-port，你可以轻松地获取一个可用的端口号，而无需手动查找。\n\nget-port-please 基于 get-port，提供了额外的功能，例如：\n\n1. 可以指定端口号范围，只在指定的端口范围内查找可用端口号。\n\n2. 可以指定要跳过的端口号列表，这些端口号将从查找中排除。\n\n3. 可以选择使用 IPv4 或 IPv6 地址来查找可用端口号。\n\n4. 可以指定最大尝试次数和等待时间，以控制查找可用端口号的时间。\n\n总之，get-port-please 提供了更多的灵活性和选项，使得端口号的查找更加方便和可控。但如果你只需要简单地获取一个可用的端口号，那么使用 get-port 就足够了。","type":"text/markdown","created":"20231030022218860","creator":"oeyoews","modified":"20231030022228494","modifier":"oeyoews","tags":"JavaScript"},{"title":"getElementById querySelector","text":"在性能方面，通常来说，`getElementById` 的效率会比 `querySelector` 更高。这是因为 `getElementById` 是针对特定ID进行查找的，而且在实现上通常会使用更优化的算法。相比之下，`querySelector` 是一个通用的选择器，可以通过任何CSS选择器来查找元素，因此它的实现会更加复杂，可能会涉及更多的计算。\n\n所以，如果你只是需要通过ID获取元素，那么 `getElementById` 会是更好的选择，因为它更直接，更高效。而如果你需要使用更复杂的选择器来获取元素，那么 `querySelector` 可能是更合适的选择，尤其是当你需要使用类名、属性等选择器时。","type":"text/markdown","created":"20240131100320431","creator":"oeyoews","modified":"20240131100338982","modifier":"oeyoews","tags":"JavaScript"},{"title":"getter-error-domnode","text":"\"Cannot set property parentNode of #<Node> which has only a getter\" 这种错误通常与尝试修改 DOM 节点的只读属性有关。在 DOM 中，有些属性是只读的，它们只能被获取而不能被设置。其中之一就是 `parentNode` 属性，该属性表示一个节点的父节点。\n\n当你尝试通过设置 `parentNode` 属性来修改节点的父节点时，如果这个属性是只读的，就会触发这个错误。这通常发生在使用不当的 DOM 操作时，例如尝试将一个节点插入到另一个节点中，但目标节点的 `parentNode` 属性是只读的。\n\n要解决这个问题，你可以确保在操作 DOM 节点时，使用正确的方法和属性。例如，使用 `appendChild` 或 `insertBefore` 方法来移动节点，而不是直接修改 `parentNode` 属性。确保你的 DOM 操作符合 DOM 规范和最佳实践。如果可能，请提供你的代码片段，以便我可以提供更具体的帮助。","type":"text/markdown","created":"20240110135840534","creator":"oeyoews","modified":"20240110135858895","modifier":"oeyoews","tags":"JavaScript"},{"title":"hasOwn-hasOwnProperty","text":"`hasOwnProperty` 和 `hasOwn` 都涉及到 JavaScript 中对象的属性检查，但它们是不同的。\n\n1. **hasOwnProperty:**\n   - `hasOwnProperty` 是 JavaScript 中原生的方法，用于检查对象是否具有指定名称的自身属性。\n   - 语法：`object.hasOwnProperty(propertyName)`，其中 `object` 是要检查的对象，`propertyName` 是属性的名称。\n   - 返回值：如果对象具有指定名称的自身属性，返回 `true`，否则返回 `false`。\n   - 示例：\n     ```javascript\n     var obj = { key: 'value' };\n     console.log(obj.hasOwnProperty('key')); // true\n     console.log(obj.hasOwnProperty('toString')); // false，因为 toString 是继承的属性\n     ```\n\nhasOwn 是 es2022, chatgpt(gpt 3.5) 无法回答这个问题","type":"text/markdown","created":"20231203132815577","creator":"oeyoews","modified":"20231203132911971","modifier":"oeyoews","tags":"JavaScript"},{"title":"Head-Stack","text":"在JavaScript中，堆（Heap）和栈（Stack）是两个主要的内存区域，用于存储不同类型的数据。\n\n1. **堆（Heap）：**\n   - 堆是动态分配的内存区域，用于存储引用类型的数据，如对象和数组。\n   - 对象和数组等复杂的数据结构存储在堆中。\n   - 在堆上分配的内存需要手动释放，否则可能导致内存泄漏。\n\n2. **栈（Stack）：**\n   - 栈是一种静态分配的内存区域，用于存储基本类型的数据和引用类型的指针。\n   - 基本类型的数据，例如数字、布尔值、字符串等，存储在栈上。\n   - 函数调用时，栈用于存储函数的局部变量、参数和返回地址。\n\n在JavaScript中，基本类型（如数字、布尔值、字符串、undefined、null）存储在栈上，而引用类型（如对象和数组）的实际数据存储在堆上，而栈中存储的是指向堆中实际数据的引用。\n\n下面是一个简单的例子，演示了栈和堆的使用：\n\n```javascript\n// 栈中存储基本类型数据\nlet num = 10;\nlet bool = true;\nlet str = \"Hello\";\n\n// 堆中存储引用类型数据\nlet obj = { key: \"value\" };\nlet arr = [1, 2, 3];\n\n// 函数调用时，栈用于存储局部变量\nfunction example() {\n  let localVar = \"I am a local variable\";\n  // ...\n}\n\n// 调用函数\nexample();\n```\n\n请注意，以上只是简单的示例，实际上JavaScript的内存管理是由JavaScript引擎负责的，开发者无需手动管理内存。","type":"text/markdown","created":"20231228083428941","creator":"oeyoews","modified":"20231228083443679","modifier":"oeyoews","tags":"JavaScript"},{"title":"history-api","created":"20230517155344267","creator":"oeyoews","modified":"20230517155357813","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"HTML5 的 history API 提供了一组在 Web 应用程序中以编程方式与浏览器历史记录进行交互的方法和属性。使用这些方法和属性，开发人员可以在不刷新整个页面的情况下，更好地控制浏览器的前进、后退和当前位置。\n\n以下是 HTML5 的 history API 常用的方法和属性：\n\n- `history.pushState(state, title, url)`：将新的状态信息与指定的 URL 添加到浏览器历史记录中，并更新浏览器地址栏中的 URL。\r\n- `history.replaceState(state, title, url)`：将新的状态信息与指定的 URL 替换当前页面在浏览器历史记录中的状态，并更新浏览器地址栏中的 URL。\r\n- `history.back()`：向后导航到上一个历史记录条目。\r\n- `history.forward()`：向前导航到下一个历史记录条目。\r\n- `history.go(delta)`：导航到指定的历史记录条目，其中 delta 可以是正数或负数（例如 `history.go(-1)` 意味着向后导航一个历史记录条目）。\n\n需要注意的是，当通过 `pushState()` 或 `replaceState()` 方法改变当前状态时，浏览器不会自动发送 HTTP 请求获取新的文档，而是仅仅简单地改变浏览器地址栏中的 URL 和浏览器历史记录。因此，开发人员需要手动编写代码来加载和更新页面内容。\n\n以下是一个使用 HTML5 的 history API 实现无刷新页面加载并更新浏览器历史记录的示例代码：\n\n```javascript\r\n// 监听链接点击事件\r\ndocument.addEventListener('click', function(event) {\r\n  // 如果被点击的元素是链接\r\n  if (event.target.tagName === 'A') {\r\n    event.preventDefault(); // 阻止默认链接行为\n\n    // 使用 AJAX 加载新页面 HTML\r\n    fetch(event.target.href)\r\n      .then(response => response.text())\r\n      .then(html => {\r\n        // 更新页面内容\r\n        document.querySelector('#content').innerHTML = html;\n\n        // 更新浏览器历史记录\r\n        history.pushState({}, null, event.target.href);\r\n      });\r\n  }\r\n});\n\n// 监听 popstate 事件（比如点击浏览器的前进或后退按钮）\r\nwindow.addEventListener('popstate', function(event) {\r\n  // 使用 AJAX 加载当前页面 HTML\r\n  fetch(location.href)\r\n    .then(response => response.text())\r\n    .then(html => {\r\n      // 更新页面内容\r\n      document.querySelector('#content').innerHTML = html;\r\n    });\r\n});\r\n```\n\n在上面的示例中，我们使用 `history.pushState()` 方法将新的 URL 添加到浏览器历史记录中，并使用 `history.popstate` 事件处理程序监听浏览器的前进或后退操作。在异步加载新页面数据时，我们可以通过 `fetch()` 函数获取新页面的 HTML，然后将其渲染到页面中指定的区域内。当用户点击浏览器的前进或后退按钮时，我们可以使用 `fetch()` 函数重新加载当前页面的 HTML，并将其渲染到页面中指定的区域内。\n\n需要注意的是，为了保证 Web 应用程序在不同浏览器之间的兼容性，开发人员还需要考虑到一些额外的问题，例如使用 `popstate` 事件处理程序时的各种兼容性问题。"},{"title":"in-hasOwnProperty","text":"在 JavaScript 中，除了使用`hasOwnProperty`方法来检查对象是否具有特定的自有属性外，还可以使用`in`运算符来检查对象是否具有某个属性，包括自有属性和继承属性。\r\n\r\n下面是使用`in`运算符的示例：\r\n\r\n```javascript\r\nconst object1 = {\r\n  property1: 42,\r\n};\r\n\r\nconsole.log('property1' in object1);\r\n// 输出：true\r\n\r\nconsole.log('toString' in object1);\r\n// 输出：true，因为 toString 是从 Object 原型继承而来的方法\r\n\r\nconsole.log('hasOwnProperty' in object1);\r\n// 输出：false，因为 hasOwnProperty 是从 Object 原型继承而来的方法\r\n```\r\n\r\n在上述示例中，我们使用`in`运算符来检查对象`object1`是否具有指定的属性。如果对象拥有该属性（不论是自有属性还是继承属性），则返回`true`，否则返回`false`。\r\n\r\n请注意，在使用`in`运算符时，如果属性存在于对象的原型链上，也会返回`true`。这就是为什么`'toString' in object1`返回`true`，因为`toString`方法是从`Object`原型继承而来的。相比之下，`hasOwnProperty`方法是`Object`自身的方法，而不是从原型继承而来的，因此`'hasOwnProperty' in object1`返回`false`。\r\n\r\n与`in`运算符不同，`hasOwnProperty`方法只检查对象是否具有自有属性，不会检查继承属性。","type":"text/markdown","created":"20230624144117469","creator":"oeyoews","modified":"20230726045248487","modifier":"oeyoews","tags":"JavaScript"},{"title":"in-operator","text":"\"in\" 在 JavaScript 中是一个运算符，用于检查一个对象是否包含某个属性。它的语法是：\r\n\r\n```javascript\r\n属性名 in 对象\r\n```\r\n\r\n例如，你可以使用它来检查一个对象是否包含特定的属性，如下所示：\r\n\r\n```javascript\r\nvar person = {name: \"John\", age: 30};\r\n\r\nif (\"name\" in person) {\r\n  console.log(\"person 对象包含 name 属性\");\r\n} else {\r\n  console.log(\"person 对象不包含 name 属性\");\r\n}\r\n```\r\n\r\n这段代码会输出 \"person 对象包含 name 属性\"，因为 `person` 对象包含一个名为 \"name\" 的属性。如果属性不存在，它将返回 `false`。这个运算符通常用于遍历对象的属性或检查特定属性是否存在。","type":"text/markdown","created":"20230907132851928","creator":"oeyoews","modified":"20230907132902212","modifier":"oeyoews","tags":"JavaScript"},{"title":"indexof","text":"indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。\n如果没有找到匹配的字符串则返回 -1。","type":"text/markdown","created":"20231009125938718","creator":"oeyoews","modified":"20231009125948291","modifier":"oeyoews","tags":"JavaScript"},{"title":"indexOf","created":"20230603051041134","creator":"oeyoews","modified":"20230603051242254","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"好的，`indexOf` 是 JavaScript 中的一个数组方法，用于返回指定元素在数组中第一次出现的位置。如果数组中不存在该元素，则返回 -1。\n\n以下是 `indexOf` 方法的语法：\n\n```javascript\r\narray.indexOf(searchElement[, fromIndex])\r\n```\n\n其中，`array` 是要搜索的数组，`searchElement` 是要查找的元素，`fromIndex` 是一个可选的参数，用于指定开始查找的索引位置。如果省略 `fromIndex` 参数，则默认从数组的第一个元素开始查找。\n\n以下是一个示例，演示如何使用 `indexOf` 方法：\n\n```javascript\r\nconst fruits = ['apple', 'banana', 'orange', 'grape'];\r\nconst index1 = fruits.indexOf('orange'); // 返回 2\r\nconst index2 = fruits.indexOf('pear'); // 返回 -1\r\n```\n\n在这个示例中，我们首先定义了一个包含多个水果名称的数组 `fruits`。然后，使用 `indexOf` 方法来查找数组中第一次出现 `'orange'` 和 `'pear'` 的位置。由于 `'orange'` 出现在数组的第 3 个位置（从 0 开始计数），因此 `index1` 的值为 2。而 `'pear'` 并不存在于数组中，因此 `index2` 的值为 -1。\n\n需要注意的是，`indexOf` 方法是区分大小写的。如果要忽略大小写进行查找，可以使用 `toLowerCase()` 或 `toUpperCase()` 方法将字符串转换为统一的大小写。\n\n要忽略大小写，可以使用 `toLowerCase()` 或 `toUpperCase()` 方法将要查找的字符串转换为统一的大小写形式，然后再使用 `indexOf()` 方法进行查找。这样可以确保在查找时忽略大小写的差异。以下是一个示例：\n\n```javascript\r\nconst fruits = ['apple', 'banana', 'orange', 'grape'];\r\nconst index1 = fruits.indexOf('Orange'.toLowerCase()); // 返回 2\r\nconst index2 = fruits.indexOf('PEAR'.toUpperCase()); // 返回 -1\r\n```\n\n在这个示例中，我们在查找之前，先使用 `toLowerCase()` 方法将要查找的字符串 `'Orange'` 转换为小写形式。这样，即使数组中的 `'orange'` 是小写的，我们也能够正确地找到它，并返回它在数组中第一次出现的位置。同样地，我们也可以使用 `toUpperCase()` 方法将要查找的字符串转换为大写形式。这样，即使数组中的 `'pear'` 是小写的，我们也能够正确地找到它，并返回 -1 表示没有找到。\n\n需要注意的是，在使用 `toLowerCase()` 或 `toUpperCase()` 方法时，需要注意不要直接修改原始字符串，而是将转换后的字符串保存到一个新的变量中。这是因为 JavaScript 中的字符串是不可变的，一旦创建就不能修改。如果直接修改原始字符串，会导致程序出现错误。"},{"title":"inline-block","text":"在前端开发中，\"inline\"、\"inline-block\" 和 \"block\" 是用来定义 HTML 元素在页面中的布局方式的三种常见属性。\n\n1. **inline（内联）**：inline 元素会在同一行内显示，不会产生换行。它们的宽度和高度是由其内容决定的，无法设置固定的宽度和高度。常见的 inline 元素包括 `<span>`、`<a>` 和 `<img>`。例如：\n\n   ```html\n   <span>这是一个内联元素</span> <span>这也是一个内联元素</span>\n   ```\n\n2. **inline-block（内联块）**：inline-block 元素会像 inline 元素一样在同一行内显示，但是可以设置固定的宽度和高度，同时也可以设置边距、填充等样式。常见的 inline-block 元素包括 `<input>` 和 `<button>`。例如：\n\n   ```html\n   <div style=\"display: inline-block; width: 100px; height: 50px; background-color: red;\"></div>\n   <div style=\"display: inline-block; width: 100px; height: 50px; background-color: blue;\"></div>\n   ```\n\n3. **block（块级）**：block 元素会独占一行，会在前后产生换行。block 元素的宽度默认是其父元素的 100%，可以设置固定的宽度和高度。常见的 block 元素包括 `<div>`、`<p>` 和 `<h1>` 等。例如：\n\n   ```html\n   <div>这是一个块级元素</div>\n   <div>这是另一个块级元素</div>\n   ```\n\n因此，这三种布局方式的区别在于它们在页面中的显示形式、宽度和高度的设置方式以及是否产生换行。","type":"text/markdown","created":"20240125165146116","creator":"oeyoews","modified":"20240125165216559","modifier":"oeyoews","tags":"JavaScript"},{"title":"innerHTML outerHTML","text":"`outerHTML` 和 `innerHTML` 是 JavaScript 中常用的属性，用于获取元素的 HTML 内容，它们之间有一些区别：\n\n1. `innerHTML`：这是一个 DOM 元素属性，用于获取或设置元素的 HTML 内容。当你使用 `innerHTML` 时，你可以获取到该元素的所有子元素及其内容，并且你可以修改它们。例如：\n\n```javascript\nvar element = document.getElementById(\"example\");\nconsole.log(element.innerHTML); // 获取元素内容\nelement.innerHTML = \"<p>新的 HTML 内容</p>\"; // 设置新的 HTML 内容\n```\n\n2. `outerHTML`：这也是一个 DOM 元素属性，用于获取元素及其所有子元素的 HTML 内容，包括元素本身。相比于 `innerHTML`，`outerHTML` 会返回包含当前元素的 HTML 字符串。例如：\n\n```javascript\nvar element = document.getElementById(\"example\");\nconsole.log(element.outerHTML); // 获取元素及其所有子元素的 HTML 内容\n```\n\n总的来说，`innerHTML` 返回的是元素的内部 HTML 内容，而 `outerHTML` 返回的是包含当前元素的 HTML 字符串，包括元素本身。","type":"text/markdown","created":"20240129123934913","creator":"oeyoews","modified":"20240129123956908","modifier":"oeyoews","tags":"JavaScript"},{"title":"instance","text":"`instanceof` 是 JavaScript 中的运算符，用于检测一个对象是否是某个构造函数的实例。\r\n\r\n语法格式：`object instanceof constructor`\r\n\r\n其中，`object` 是要检测的对象，`constructor` 是构造函数。该运算符返回一个布尔值，如果 `object` 是 `constructor` 的实例，则返回 `true`，否则返回 `false`。\r\n\r\n例如：\r\n\r\n```javascript\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\n\r\nconst person = new Person('Alice');\r\n\r\nconsole.log(person instanceof Person); // true\r\nconsole.log(person instanceof Object); // true\r\nconsole.log({} instanceof Object); // true\r\nconsole.log([] instanceof Object); // true\r\nconsole.log([] instanceof Array); // true\r\nconsole.log({} instanceof Array); // false\r\n```\r\n\r\n在上面的代码中，`person` 是 `Person` 的实例，因此 `person instanceof Person` 返回 `true`。同时，由于所有对象都是 `Object` 的实例，因此 `person` 也是 `Object` 的实例，`{}，[]` 也是 `Object` 的实例。`[]` 是 `Array` 的实例，因此 `[] instanceof Array` 返回 `true`，而 `{}` 不是 `Array` 的实例，因此 `{} instanceof Array` 返回 `false`。\r\n\r\n需要注意的是，`instanceof` 运算符的判断是基于原型链的。也就是说，如果 `constructor` 的原型链上有一个对象与 `object` 的原型链上的任意一个对象相等，那么 `object` 就被认为是 `constructor` 的实例。因此，如果 `constructor` 是一个自定义的构造函数，需要确保它的原型链被正确地设置。\r\n\r\n此外，如果 `constructor` 不是一个函数，`instanceof` 运算符会抛出一个 `TypeError` 异常。因此，在使用 `instanceof` 运算符时，需要确保 `constructor` 是一个函数。","type":"text/markdown","created":"20230530103539715","creator":"oeyoews","modified":"20230726045248488","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&instance","tags":"JavaScript"},{"title":"js-boolean","text":"if(link) 表示当 link 存在且不是空字符串、false、0、null、undefined 等 Falsy 值时，if 条件判断为真。如果 link 是一个 Truthy 值，则 if 语句块中的代码会被执行。","type":"text/markdown","created":"20230429114253181","creator":"oeyoews","modified":"20231019012929063","modifier":"oeyoews","tags":"JavaScript"},{"title":"js-data-type","created":"20230525045537903","creator":"oeyoews","modified":"20230525045929695","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Language_overview\n\n!! Data type\n\n* Number（数字）\r\n* String（字符串）\r\n* Boolean（布尔）\r\n* Symbol（符号）（ES2015 新增）\r\n* Object（对象）\r\n** Function（函数）\r\n** Array（数组）\r\n** Date（日期）\r\n** RegExp（正则表达式）\n\n* null（空）\r\n* undefined（未定义）"},{"title":"js-error-example01","text":"```js\r\nconst demo = {\r\n  version: 1,\r\n  log: function () {\r\n    console.log(this.version);\r\n  },\r\n};\r\n\r\nconst { log } = demo;\r\nlog()\r\n```\r\n\r\n在这个代码片段中，首先定义了一个名为 `demo` 的对象，它包含一个 `version` 属性和一个名为 `log` 的方法。`log` 方法使用 `console.log` 函数输出当前对象的 `version` 属性。\r\n\r\n接下来，使用对象解构将 `demo` 对象中的 `log` 方法分配给变量 `log`。然后，调用 `log()` 方法，但是此时 `log` 方法已经脱离了原来的对象，因此它的 `this` 指向已经发生了变化。\r\n\r\n在 JavaScript 中，函数的 `this` 值是在函数被调用时确定的，它的值取决于函数的调用方式和上下文。在这个例子中，当 `log()` 方法被调用时，它已经被解构到了全局作用域中，因此它的 `this` 值将指向全局对象（在浏览器中通常是 `window` 对象）。\r\n\r\n由于全局对象没有 `version` 属性，因此当 `log()` 方法被调用时，会在控制台中输出 `undefined`。要正确地输出 `version` 属性，可以使用 `Function.prototype.bind()` 方法将 `log` 方法绑定到原始的 `demo` 对象上，如下所示：\r\n\r\n```javascript\r\nconst { log } = demo;\r\nconst boundLog = log.bind(demo);\r\nboundLog(); // 输出：1\r\n``` \r\n\r\n这样，`log` 方法就会在 `demo` 对象的上下文中被调用，它的 `this` 值将指向 `demo` 对象，从而正确地输出 `version` 属性。","type":"text/markdown","created":"20230607033803481","creator":"oeyoews","modified":"20230726045248495","modifier":"oeyoews","tags":"JavaScript"},{"title":"js-event-delegation","created":"20230601115951295","creator":"oeyoews","modified":"20230601120153277","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"JavaScript 事件代理（Event Delegation）(事件委托)是一种常用的事件处理技术，它利用事件冒泡机制，在父元素上监听事件，通过判断事件源来触发对应的处理函数，可以避免在每个子元素上单独绑定事件处理函数，提高程序效率和可维护性。\n\n具体来说，事件代理的实现方式是在父元素上绑定事件处理函数，当子元素触发事件时，事件会沿着 DOM 树向上传递，直到被父元素捕获并触发事件处理函数。在事件处理函数中，可以通过事件对象的 `target` 属性来获取实际触发事件的子元素，进而根据需要进行相应的操作。\n\n使用事件代理可以避免在子元素上频繁绑定和解绑事件处理函数，从而提高程序的性能和可维护性。同时，当子元素动态增加或删除时，事件代理也能够自动适应，无需重新绑定事件处理函数。\n\n下面是一个使用事件代理的示例代码：\n\n```html\r\n<ul id=\"parent\">\r\n  <li>Item 1</li>\r\n  <li>Item 2</li>\r\n  <li>Item 3</li>\r\n</ul>\r\n```\n\n```javascript\r\n// 获取父元素\r\nconst parent = document.getElementById('parent');\n\n// 在父元素上绑定事件处理函数\r\nparent.addEventListener('click', function(event) {\r\n  // 判断事件源是否为子元素\r\n  if (event.target.nodeName === 'LI') {\r\n    // 对子元素进行操作\r\n    console.log(`Clicked on ${event.target.textContent}`);\r\n  }\r\n});\r\n```\n\n在上述代码中，我们在父元素 `ul` 上绑定了 `click` 事件处理函数，然后通过判断事件源的标签名是否为 `li` 元素，来确定是哪个子元素触发了事件。这样，无论子元素的数量和内容如何变化，只需要维护父元素上的事件处理函数即可。"},{"title":"js-false","text":"<$image source=\"https://images.unsplash.com/photo-1542319465-7a87c5f95757?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w0NTAyMTB8MHwxfHNlYXJjaHwxNHx8ZmFsc2V8ZW58MHwwfHx8MTY4NTExODA3NHww&ixlib=rb-4.0.3&q=80&w=1080\" alt=\"Unsplash Image\"/>\r\n\r\n在 JavaScript 中会被判断为 `false` 的有以下几种情况：\r\n\r\n1. `false`：布尔值 `false`。\r\n2. `null`：表示一个空对象指针。\r\n3. `undefined`：表示一个未定义的值。\r\n4. `0`：数值 `0`。\r\n5. `NaN`：表示非数字（Not-a-Number）值。例如 `0/0` 或者 `parseInt(\"abc\")`。\r\n6. 空字符串 `\"\"`：表示一个空字符串。\r\n\r\n这些情况都可以用于条件语句中作为 `false` 的值。相应地，除了这些值以外的所有值都会被视为 `true`。例如，非空字符串、非零数值、非空对象等都会被视为 `true`。\r\n\r\n在条件语句中，可以使用 `!` 运算符来判断一个值是否为 `false`，例如：\r\n\r\n```javascript\r\nconst x = 0;\r\n// -- 得正\r\nif (!x) {\r\n  console.log(\"x is false\");\r\n} else {\r\n  console.log(\"x is true\");\r\n}\r\n```\r\n\r\n在上面的代码中，由于 `x` 的值为 `0`，因此它会被判断为 `false`，因此条件语句会输出 `\"x is false\"`。","type":"text/markdown","created":"20230526161905269","creator":"oeyoews","modified":"20230913091808499","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&js-false","tags":"JavaScript"},{"title":"js-fullscreen","created":"20230529031226177","creator":"oeyoews","modified":"20230529031244010","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"JavaScript函数进入全屏和F11键进入全屏的本质区别在于，JavaScript函数进入全屏是通过调用浏览器提供的全屏API实现的，而F11键进入全屏是通过浏览器自身实现的全屏模式实现的。这两种方式的实现方式不同，导致在退出全屏时也有所不同。\n\n具体来说，JavaScript函数进入全屏是通过调用`document.documentElement.requestFullscreen()`方法实现的，退出全屏是通过调用`document.exitFullscreen()`方法实现的。这些方法是浏览器提供的全屏API，可以控制网页进入和退出全屏模式。在使用这些方法时，我们可以通过JavaScript代码控制进入和退出全屏模式，可以更加灵活和自由地控制全屏模式。\n\n而F11键进入全屏是浏览器自身实现的全屏模式，不同于JavaScript函数进入全屏的方式。在F11键进入全屏模式时，浏览器会将当前窗口或标签页切换到全屏模式，并隐藏浏览器工具栏、地址栏和标签栏等界面元素，以最大化显示网页内容。这种全屏模式是浏览器自身实现的，与JavaScript函数进入全屏的方式不同。在F11键进入全屏模式时，用户可以通过按下F11键再次退出全屏模式，恢复正常窗口模式。这是因为F11键是浏览器快捷键，在浏览器中具有特殊的功能，可以控制进入和退出全屏模式。但是，由于F11键是浏览器自身实现的全屏模式，因此无法通过JavaScript来控制F11键进入和退出全屏模式。"},{"title":"js-in","created":"20230603025648546","creator":"oeyoews","modified":"20230603025747516","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"```js\r\nconst nav = {\r\n  name: 'tom',\r\n};\n\n// const res = nav?.name; // tom\r\nconst res = 'name' in nav; // true\n\nif (res) {\r\n  console.log('demo');\r\n  console.log(res);\r\n} else {\r\n  console.log('failed');\r\n}\r\n```\n\n`'serviceWorker' in window.navigator` 是 JavaScript 中的一个语法，具体来说，它是一种运算符。这个运算符称为“in 运算符”，用于检测一个对象是否包含某个属性。\n\n在这个例子中，`'serviceWorker' in window.navigator` 用于检测 `window.navigator` 对象是否包含名为 `'serviceWorker'` 的属性。如果存在，则表达式的值为 `true`，否则为 `false`。这个表达式可以用于判断当前浏览器是否支持 Service Worker 技术，从而决定是否使用 PWA（渐进式 Web 应用程序）技术。\n\n`in` 运算符是 JavaScript 中的一种基本运算符，用于检测一个对象是否包含某个属性。它可以用于检测对象自身的属性，也可以用于检测对象原型链上的属性。`in` 运算符的语法如下：\n\n```\r\npropName in object\r\n```\n\n其中，`propName` 是要检测的属性名，`object` 是要检测的对象。如果 `object` 包含名为 `propName` 的属性，则表达式的值为 `true`，否则为 `false`。\n\n`in` 运算符是 JavaScript 中的一个常用运算符，可以用于许多场景，例如检测对象是否包含某个属性、遍历对象的属性等。"},{"title":"js-info","text":"https://javascript.info/js-animation?map","type":"text/markdown","created":"20230915154736041","modified":"20230915154745816","tags":"JavaScript"},{"title":"js-methods","text":"以下是 JavaScript 中需要掌握的高频方法：\r\n\r\n1. DOM 操作：获取、创建、修改、删除 DOM 元素\r\n2. 事件处理：绑定、解绑事件、事件冒泡、阻止默认事件\r\n3. 数组操作：遍历、筛选、排序、去重、合并、转换等\r\n4. 字符串处理：截取、拼接、替换、正则匹配等\r\n5. Ajax 请求：发送、接收、处理请求结果等\r\n6. 函数操作：声明、调用、参数传递、闭包、高阶函数等\r\n7. 异常处理：try-catch 语句、抛出异常等\r\n8. 定时器：setTimeout、setInterval 等\r\n9. JSON 操作：解析、转换、序列化等\r\n10. 模块化：使用模块化规范、模块的导入和导出等。\r\n\r\n1. DOM 操作：\r\n\r\n获取元素：\r\n\r\n```plain\r\nlet element = document.querySelector('#id');\r\nlet elements = document.querySelectorAll('.class');\r\n```\r\n\r\n创建元素：\r\n\r\n```plain\r\nlet element = document.createElement('div');\r\n```\r\n\r\n修改元素：\r\n\r\n```plain\r\nelement.innerHTML = 'new content';\r\nelement.setAttribute('class', 'newClass');\r\n```\r\n\r\n删除元素：\r\n\r\n```plain\r\nelement.parentNode.removeChild(element);\r\n```\r\n\r\n2. 事件处理：\r\n\r\n绑定事件：\r\n\r\n```plain\r\nelement.addEventListener('click', function(event){\r\n  // 点击事件处理逻辑\r\n});\r\n```\r\n\r\n解绑事件：\r\n\r\n```plain\r\nelement.removeEventListener('click', function(event){\r\n  // 点击事件处理逻辑\r\n});\r\n```\r\n\r\n阻止默认事件：\r\n\r\n```plain\r\nevent.preventDefault();\r\n```\r\n\r\n3. 数组操作：\r\n\r\n遍历数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3];\r\narr.forEach(function(item){\r\n  console.log(item);\r\n});\r\n```\r\n\r\n筛选数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3];\r\nlet newArr = arr.filter(function(item){\r\n  return item > 1;\r\n});\r\n```\r\n\r\n排序数组：\r\n\r\n```plain\r\nlet arr = [3, 1, 2];\r\narr.sort(function(a, b){\r\n  return a - b;\r\n});\r\n```\r\n\r\n去重数组：\r\n\r\n```plain\r\nlet arr = [1, 2, 3, 2, 1];\r\nlet newArr = Array.from(new Set(arr));\r\n```\r\n\r\n4. 字符串处理：\r\n\r\n截取字符串：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet newStr = str.slice(0, 5);\r\n```\r\n\r\n拼接字符串：\r\n\r\n```plain\r\nlet str1 = 'hello';\r\nlet str2 = 'world';\r\nlet newStr = str1 + ' ' + str2;\r\n```\r\n\r\n替换字符串：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet newStr = str.replace('world', 'javascript');\r\n```\r\n\r\n正则匹配：\r\n\r\n```plain\r\nlet str = 'hello world';\r\nlet reg = /world/;\r\nlet result = reg.test(str);\r\n```\r\n\r\n5. Ajax 请求：\r\n\r\n发送请求：\r\n\r\n```plain\r\nlet xhr = new XMLHttpRequest();\r\nxhr.open('GET', 'url');\r\nxhr.send();\r\n```\r\n\r\n接收处理请求结果：\r\n\r\n```plain\r\nxhr.onload = function(){\r\n  console.log(xhr.responseText);\r\n};\r\n```\r\n\r\n6. 函数操作：\r\n\r\n声明函数：\r\n\r\n```plain\r\nfunction add(a, b){\r\n  return a + b;\r\n}\r\n```\r\n\r\n调用函数：\r\n\r\n```plain\r\nlet sum = add(1, 2);\r\n```\r\n\r\n参数传递：\r\n\r\n```plain\r\nfunction modifyObj(obj){\r\n  obj.name = 'new name';\r\n}\r\n\r\nlet obj = {name: 'old name'};\r\nmodifyObj(obj);\r\nconsole.log(obj.name); // 输出 'new name'\r\n```\r\n\r\n闭包：\r\n\r\n```plain\r\nfunction createCounter(){\r\n  let count = 0;\r\n  return function(){\r\n    count++;\r\n    console.log(count);\r\n  };\r\n}\r\n\r\nlet counter = createCounter();\r\ncounter(); // 输出 1\r\ncounter(); // 输出 2\r\n```\r\n\r\n高阶函数：\r\n\r\n```plain\r\nfunction add(a, b){\r\n  return a + b;\r\n}\r\n\r\nfunction calculate(func, a, b){\r\n  return func(a, b);\r\n}\r\n\r\nlet sum = calculate(add, 1, 2);\r\n```\r\n\r\n7. 异常处理：\r\n\r\n```plain\r\ntry {\r\n  // 可能出现异常的代码\r\n} catch(error) {\r\n  // 异常处理逻辑\r\n}\r\n```\r\n\r\n抛出异常：\r\n\r\n```plain\r\nthrow new Error('error message');\r\n```\r\n\r\n8. 定时器：\r\n\r\n```plain\r\nlet timer = setTimeout(function(){\r\n  console.log('timer');\r\n}, 1000);\r\n\r\nclearTimeout(timer);\r\n```\r\n\r\n9. JSON 操作：\r\n\r\n解析 JSON：\r\n\r\n```plain\r\nlet str = '{\"name\": \"alice\", \"age\": 18}';\r\nlet obj = JSON.parse(str);\r\n```\r\n\r\n序列化 JSON：\r\n\r\n```plain\r\nlet obj = {name: 'alice', age: 18};\r\nlet str = JSON.stringify(obj);\r\n```\r\n\r\n10. 模块化：\r\n\r\n导入模块：\r\n\r\n```plain\r\nimport {add} from './module';\r\n```\r\n\r\n导出模块：\r\n\r\n```plain\r\nexport function add(a, b){\r\n  return a + b;\r\n}\r\n```\r\n\r\n11. Promise\r\n\r\nPromise 是一种异步编程的解决方案，它可以用来解决回调地狱的问题，提高代码的可读性和可维护性。\r\n\r\n创建 Promise 对象：\r\n\r\n```plain\r\nlet promise = new Promise(function(resolve, reject){\r\n  // 异步操作\r\n  if(/* 操作成功 */){\r\n    resolve(result);\r\n  }else{\r\n    reject(error);\r\n  }\r\n});\r\n```\r\n\r\n使用 then 方法处理 Promise：\r\n\r\n```plain\r\npromise.then(function(result){\r\n  // 操作成功的处理逻辑\r\n}, function(error){\r\n  // 操作失败的处理逻辑\r\n});\r\n```\r\n\r\n使用 catch 方法处理 Promise：\r\n\r\n```plain\r\npromise.catch(function(error){\r\n  // 操作失败的处理逻辑\r\n});\r\n```\r\n\r\n12. async/await\r\n\r\nasync/await 是 ES2017 中新增的异步编程解决方案，它基于 Promise 实现，可以进一步简化异步代码的编写。\r\n\r\n使用 async 声明异步函数：\r\n\r\n```plain\r\nasync function fetchData(){\r\n  // 异步操作\r\n  return result;\r\n}\r\n```\r\n\r\n使用 await 等待异步操作完成：\r\n\r\n```plain\r\nlet result = await fetchData();\r\n```\r\n\r\n使用 try-catch 处理异步操作的异常：\r\n\r\n```plain\r\ntry{\r\n  let result = await fetchData();\r\n}catch(error){\r\n  // 异常处理逻辑\r\n}\r\n```\r\n\r\n13. ES6 中的新特性\r\n\r\nES6 是 JavaScript 中一个重要的版本，它引入了许多新的特性，包括箭头函数、模板字符串、解构赋值、let/const 关键字、类、模块化等等。\r\n\r\n箭头函数：\r\n\r\n```plain\r\nlet add = (a, b) => a + b;\r\n```\r\n\r\n模板字符串：\r\n\r\n```plain\r\nlet name = 'alice';\r\nlet str = `hello ${name}`;\r\n```\r\n\r\n解构赋值：\r\n\r\n```plain\r\nlet [a, b] = [1, 2];\r\n```\r\n\r\nlet/const 关键字：\r\n\r\n```plain\r\nlet name = 'alice';\r\nconst PI = 3.14;\r\n```\r\n\r\n类：\r\n\r\n```plain\r\nclass Person{\r\n  constructor(name){\r\n    this.name = name;\r\n  }\r\n\r\n  sayHello(){\r\n    console.log(`hello ${this.name}`);\r\n  }\r\n}\r\n\r\nlet person = new Person('alice');\r\nperson.sayHello();\r\n```\r\n\r\n模块化：\r\n\r\n```plain\r\nexport function add(a, b){\r\n  return a + b;\r\n}\r\n\r\nimport {add} from './module';\r\n```\r\n\r\n1. 数组的常用方法：`push`、`pop`、`shift`、`unshift`、`slice`、`splice`、`concat`、`join`、`map`、`reduce`、`filter`、`sort`、`reverse` 等。\r\n\r\n2. 对象的常用方法：`Object.keys`、`Object.values`、`Object.entries`、`Object.assign`、`JSON.stringify`、`JSON.parse` 等。\r\n\r\n3. 字符串的常用方法：`charAt`、`charCodeAt`、`indexOf`、`lastIndexOf`、`substr`、`substring`、`slice`、`split`、`replace`、`match` 等。\r\n\r\n4. 函数的常用方法：`bind`、`call`、`apply`、`setTimeout`、`setInterval`、`Promise`、`async/await`、`try/catch` 等。\r\n\r\n5. DOM 操作的常用方法：`getElementById`、`querySelector`、`querySelectorAll`、`createElement`、`appendChild`、`removeChild`、`setAttribute`、`getAttribute`、`classList` 等。\r\n\r\n6. 事件的常用方法：`addEventListener`、`removeEventListener`、`preventDefault`、`stopPropagation` 等。\r\n\r\n7. 正则表达式的常用方法：`test`、`exec`、`match`、`replace`、`search` 等。\r\n\r\n8. 数学计算的常用方法：`Math.round`、`Math.ceil`、`Math.floor`、`Math.abs`、`Math.max`、`Math.min`、`Math.random` 等。\r\n\r\n以上是 JavaScript 中需要掌握的高频方法，掌握这些方法可以提高编码效率，同时也有助于更好地理解 JavaScript 的语法和运行机制。\r\n","type":"text/markdown","created":"20230522111923713","creator":"oeyoews","modified":"20230726045248499","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&js-methods","tags":"JavaScript"},{"title":"js-void","created":"20230529121010047","creator":"oeyoews","modified":"20230529121021319","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"javascript:void()和#都是用于在HTML中创建链接的特殊URL。它们的作用是让用户点击链接时不跳转或刷新页面，而是执行一些JavaScript代码或将用户滚动到页面的顶部。\n\n具体来说，javascript:void()是一个空的JavaScript语句，它不会执行任何操作。如果将javascript:void()作为链接的href属性值，当用户点击该链接时，浏览器将执行javascript:void()语句，并不会有任何变化。例如：\n\n```html\r\n<a href=\"javascript:void()\">点击我</a>\r\n```\n\n在这个例子中，我们创建了一个链接，并将其href属性设置为javascript:void()。当用户点击该链接时，浏览器将执行javascript:void()语句，但不会有任何变化。\n\n相比之下，#是用于创建锚点的特殊URL，它会将用户滚动到页面的顶部。如果将#作为链接的href属性值，当用户点击该链接时，浏览器将滚动到页面的顶部，并不会跳转或刷新页面。例如：\n\n```html\r\n<a href=\"#\">回到顶部</a>\r\n```\n\n在这个例子中，我们创建了一个链接，并将其href属性设置为#。当用户点击该链接时，浏览器将滚动到页面的顶部，但并不会跳转或刷新页面。\n\n需要注意的是，虽然javascript:void()和#都是用于在HTML中创建链接的特殊URL，但它们有所不同。javascript:void()不会执行任何操作，而#会将用户滚动到页面的顶部。在实际开发中，需要根据具体需求选择合适的URL。"},{"title":"Json-parse","created":"20230509154018889","creator":"oeyoews","modified":"20230527114419580","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&Json-parse","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在JavaScript中，可以使用`JSON.parse()`方法将一个JSON格式的字符串转换为JavaScript对象。该方法接受一个字符串参数，并尝试将其解析为有效的JSON格式。如果解析成功，则返回一个对应的JavaScript对象，否则抛出异常。\n\n以下是一个简单的例子：\n\n```javascript\r\nconst jsonString = '{\"name\": \"John\", \"age\": 30, \"hobbies\": [\"reading\", \"traveling\"]}';\r\nconst obj = JSON.parse(jsonString);\r\nconsole.log(obj);\r\n```\n\n在这个例子中，我们定义了一个名为`jsonString`的字符串，表示一个包含`name`、`age`和`hobbies`属性的JSON对象。然后我们使用`JSON.parse()`方法将该字符串解析为一个JavaScript对象，并将其保存到名为`obj`的变量中。最后，我们使用`console.log()`方法输出该对象。\n\n如果要在TypeScript中将一个字符串转换为JavaScript对象，则需要使用`JSON.parse()`方法相同的方式进行转换。例如：\n\n```typescript\r\nconst jsonString = '{\"name\": \"John\", \"age\": 30, \"hobbies\": [\"reading\", \"traveling\"]}';\r\nconst obj = JSON.parse(jsonString);\r\nconsole.log(obj);\r\n```\n\n在这个例子中，我们可以看到，JavaScript和TypeScript中的`JSON.parse()`方法的用法是一样的。"},{"title":"js默认导出","text":"```js\r\n// mjs\r\nexport default {\r\n  a: 1,\r\n};\r\n\r\nimport aa from \"./d.mjs\";\r\nconsole.log(aa.a);\r\n\r\n```\r\n\r\n```js\r\n// cjs\r\nmodule.exports = {\r\n  a: 1,\r\n};\r\n\r\nconst ab = require('./d.js')\r\nconsole.log(ab.a);\r\n```","type":"text/markdown","created":"20230902091224994","creator":"oeyoews","modified":"20230902091419244","modifier":"oeyoews","tags":"JavaScript"},{"title":"keypress-keydown","text":"这三个事件，`keydown`、`keypress`和`keyup`，都是用于监听键盘事件的，但它们之间有一些关键的区别：\n\n1. **`keydown`事件：**\n   - 触发时机：在按下键盘上的任意键时触发。\n   - 提供的信息：`keydown`事件提供被按下的键的信息，包括键码（keyCode）和字符（key）。\n   - 注意事项：这个事件在按下键的瞬间触发，而且在按住键的情况下会重复触发。\n\n2. **`keypress`事件：**\n   - 触发时机：在按下能够产生字符的键时触发，比如字母和数字键。\n   - 提供的信息：`keypress`事件提供与键关联的字符信息（charCode）。\n   - 注意事项：与`keydown`不同，`keypress`事件不会在按住键时重复触发。\n\n3. **`keyup`事件：**\n   - 触发时机：在释放键盘上的按键时触发。\n   - 提供的信息：`keyup`事件提供释放的键的信息，包括键码（keyCode）和字符（key）。\n   - 注意事项：这个事件在释放按键的瞬间触发。\n\n在实际应用中，通常使用`keydown`和`keyup`来检测按键的按下和释放，而`keypress`则在大多数情况下用得较少，因为它并不会提供所有键的信息，尤其是不可打印字符。需要注意的是，随着浏览器的发展，`keydown`和`keyup`事件现在更常用，而`keypress`事件在某些场景下可能会不被触发。\n\n如果你需要在按下某个键时触发事件，通常使用`keydown`。如果你需要在释放键时触发事件，通常使用`keyup`。","type":"text/markdown","created":"20231126073028462","creator":"oeyoews","modified":"20231126073041798","modifier":"oeyoews","tags":"JavaScript"},{"title":"learn-x-in-y-minutes-javascript","text":"```js\n// 注释方式和 C 很像，这是单行注释\n/* 这是多行\n   注释 */\n\n// 语句可以以分号结束\ndoStuff();\n\n// ... 但是分号也可以省略，每当遇到一个新行时，分号会自动插入（除了一些特殊情况）。\ndoStuff()\n\n// 因为这些特殊情况会导致意外的结果，所以我们在这里保留分号。\n```\n\n## 数字、字符串与操作符\n\n```js\n///////////////////////////////////\n\n// Javascript 只有一种数字类型 (即 64 位 IEEE 754 双精度浮点 double)。\n// double 有 52 位表示尾数，足以精确存储大到 9✕10¹⁵ 的整数。\n3; // = 3\n1.5; // = 1.5\n\n// 所有基本的算数运算都如你预期。\n1 + 1; // = 2\n0.1 + 0.2; // = 0.30000000000000004\n8 - 1; // = 7\n10 * 2; // = 20\n35 / 5; // = 7\n\n// 包括无法整除的除法。\n5 / 2; // = 2.5\n\n// 位运算也和其他语言一样；当你对浮点数进行位运算时，\n// 浮点数会转换为*至多* 32 位的无符号整数。\n1 << 2; // = 4\n\n// 括号可以决定优先级。\n(1 + 3) * 2; // = 8\n\n// 有三种非数字的数字类型\nInfinity; // 1/0 的结果\n-Infinity; // -1/0 的结果\nNaN; // 0/0 的结果\n\n// 也有布尔值。\ntrue;\nfalse;\n\n// 可以通过单引号或双引号来构造字符串。\n'abc';\n\"Hello, world\";\n\n// 用！来取非\n!true; // = false\n!false; // = true\n\n// 相等 ===\n1 === 1; // = true\n2 === 1; // = false\n\n// 不等 !=\n1 !== 1; // = false\n2 !== 1; // = true\n\n// 更多的比较操作符 \n1 < 10; // = true\n1 > 10; // = false\n2 <= 2; // = true\n2 >= 2; // = true\n\n// 字符串用 + 连接\n\"Hello \" + \"world!\"; // = \"Hello world!\"\n\n// 字符串也可以用 < 、> 来比较\n\"a\" < \"b\"; // = true\n\n// 使用“==”比较时会进行类型转换...\n\"5\" == 5; // = true\nnull == undefined; // = true\n\n// ...除非你是用 ===\n\"5\" === 5; // = false\nnull === undefined; // = false \n\n// ...但会导致奇怪的行为\n13 + !0; // 14\n\"13\" + !0; // '13true'\n\n// 你可以用 `charAt` 来得到字符串中的字符\n\"This is a string\".charAt(0);  // = 'T'\n\n// ...或使用 `substring` 来获取更大的部分。\n\"Hello world\".substring(0, 5); // = \"Hello\"\n\n// `length` 是一个属性，所以不要使用 ().\n\"Hello\".length; // = 5\n\n// 还有两个特殊的值：`null` 和 `undefined`\nnull;      // 用来表示刻意设置的空值\nundefined; // 用来表示还没有设置的值 (尽管 `undefined` 自身实际是一个值)\n\n// false, null, undefined, NaN, 0 和 \"\" 都是假的；其他的都视作逻辑真\n// 注意 0 是逻辑假而  \"0\"是逻辑真，尽管 0 == \"0\"。\n```\n\n## 变量、数组和对象\n\n```js\n///////////////////////////////////\n\n// 变量需要用 `var` 关键字声明。Javascript 是动态类型语言，\n// 所以你无需指定类型。赋值需要用 `=` \nvar someVar = 5;\n\n// 如果你在声明时没有加 var 关键字，你也不会得到错误...\nsomeOtherVar = 10;\n\n// ...但是此时这个变量就会在全局作用域被创建，而非你定义的当前作用域\n\n// 没有被赋值的变量都会被设置为 undefined\nvar someThirdVar; // = undefined\n\n// 对变量进行数学运算有一些简写法：\nsomeVar += 5; // 等价于 someVar = someVar + 5; someVar 现在是 10 \nsomeVar *= 10; // 现在 someVar 是 100\n\n// 自增和自减也有简写\nsomeVar++; // someVar 是 101\nsomeVar--; // 回到 100\n\n// 数组是任意类型组成的有序列表\nvar myArray = [\"Hello\", 45, true];\n\n// 数组的元素可以用方括号下标来访问。\n// 数组的索引从 0 开始。\nmyArray[1]; // = 45\n\n// 数组是可变的，并拥有变量 length。\nmyArray.push(\"World\");\nmyArray.length; // = 4\n\n// 在指定下标添加/修改\nmyArray[3] = \"Hello\";\n\n// javascript 中的对象相当于其他语言中的“字典”或“映射”：是键 - 值对的无序集合。\nvar myObj = {key1: \"Hello\", key2: \"World\"};\n\n// 键是字符串，但如果键本身是合法的 js 标识符，则引号并非是必须的。\n// 值可以是任意类型。\nvar myObj = {myKey: \"myValue\", \"my other key\": 4};\n\n// 对象属性的访问可以通过下标\nmyObj[\"my other key\"]; // = 4\n\n// ... 或者也可以用 . ，如果属性是合法的标识符\nmyObj.myKey; // = \"myValue\"\n\n// 对象是可变的；值也可以被更改或增加新的键\nmyObj.myThirdKey = true;\n\n// 如果你想要获取一个还没有被定义的值，那么会返回 undefined\nmyObj.myFourthKey; // = undefined\n```\n\n## 逻辑与控制结构\n\n```js\n///////////////////////////////////\n\n// 本节介绍的语法与 Java 的语法几乎完全相同\n\n// `if` 语句和其他语言中一样。\nvar count = 1;\nif (count == 3){\n    // count 是 3 时执行\n} else if (count == 4){\n    // count 是 4 时执行\n} else {\n    // 其他情况下执行 \n}\n\n// while 循环\nwhile (true) {\n    // 无限循环\n}\n\n// Do-while 和 While 循环很像，但前者会至少执行一次\nvar input;\ndo {\n    input = getInput();\n} while (!isValid(input))\n\n// `for` 循环和 C、Java 中的一样：\n// 初始化; 继续执行的条件; 迭代。\nfor (var i = 0; i < 5; i++){\n    // 遍历 5 次\n}\n\n// && 是逻辑与，|| 是逻辑或\nif (house.size == \"big\" && house.colour == \"blue\"){\n    house.contains = \"bear\";\n}\nif (colour == \"red\" || colour == \"blue\"){\n    // colour 是 red 或者 blue 时执行\n}\n\n// && 和 || 是“短路”语句，它在设定初始化值时特别有用 \nvar name = otherName || \"default\";\n\n// `switch`语句使用 `===` 检查相等性。\n// 在每一个 case 结束时使用 'break'\n// 否则其后的 case 语句也将被执行。 \ngrade = 'B';\nswitch (grade) {\n  case 'A':\n    console.log(\"Great job\");\n    break;\n  case 'B':\n    console.log(\"OK job\");\n    break;\n  case 'C':\n    console.log(\"You can do better\");\n    break;\n  default:\n    console.log(\"Oy vey\");\n    break;\n}\n```\n\n## 函数、作用域、闭包\n\n```js\n///////////////////////////////////\n\n// JavaScript 函数由 `function` 关键字定义\nfunction myFunction(thing){\n    return thing.toUpperCase();\n}\nmyFunction(\"foo\"); // = \"FOO\"\n\n// 注意被返回的值必须开始于 `return` 关键字的那一行，\n// 否则由于自动的分号补齐，你将返回 `undefined`。\n// 在使用 Allman 风格的时候要注意。\nfunction myFunction()\n{\n    return // <- 分号自动插在这里\n    {\n        thisIsAn: 'object literal'\n    }\n}\nmyFunction(); // = undefined\n\n// javascript 中函数是一等对象，所以函数也能够赋给一个变量，\n// 并且被作为参数传递 —— 比如一个事件处理函数：\nfunction myFunction(){\n    // 这段代码将在 5 秒钟后被调用\n}\nsetTimeout(myFunction, 5000);\n// 注意：setTimeout 不是 js 语言的一部分，而是由浏览器和 Node.js 提供的。\n\n// 函数对象甚至不需要声明名称 —— 你可以直接把一个函数定义写到另一个函数的参数中\nsetTimeout(function(){\n    // 这段代码将在 5 秒钟后被调用\n}, 5000);\n\n// JavaScript 有函数作用域；函数有其自己的作用域而其他的代码块则没有。\nif (true){\n    var i = 5;\n}\ni; // = 5 - 并非我们在其他语言中所期望得到的 undefined\n\n// 这就导致了人们经常使用的“立即执行匿名函数”的模式，\n// 这样可以避免一些临时变量扩散到全局作用域去。\n(function(){\n    var temporary = 5;\n    // 我们可以访问修改全局对象（\"global object\"）来访问全局作用域，\n    // 在 web 浏览器中是 `window` 这个对象。 \n    // 在其他环境如 Node.js 中这个对象的名字可能会不同。\n    window.permanent = 10;\n})();\ntemporary; // 抛出引用异常 ReferenceError\npermanent; // = 10\n\n// javascript 最强大的功能之一就是闭包。\n// 如果一个函数在另一个函数中定义，那么这个内部函数就拥有外部函数的所有变量的访问权，\n// 即使在外部函数结束之后。\nfunction sayHelloInFiveSeconds(name){\n    var prompt = \"Hello, \" + name + \"!\";\n    // 内部函数默认是放在局部作用域的，\n    // 就像是用 `var` 声明的。\n    function inner(){\n        alert(prompt);\n    }\n    setTimeout(inner, 5000);\n    // setTimeout 是异步的，所以 sayHelloInFiveSeconds 函数会立即退出，\n    // 而 setTimeout 会在后面调用 inner\n    // 然而，由于 inner 是由 sayHelloInFiveSeconds“闭合包含”的，\n    // 所以 inner 在其最终被调用时仍然能够访问 `prompt` 变量。\n}\nsayHelloInFiveSeconds(\"Adam\"); // 会在 5 秒后弹出 \"Hello, Adam!\"\n```\n\n## 对象、构造函数与原型\n\n```js\n///////////////////////////////////\n\n//  对象可以包含方法。\nvar myObj = {\n    myFunc: function(){\n        return \"Hello world!\";\n    }\n};\nmyObj.myFunc(); // = \"Hello world!\"\n\n// 当对象中的函数被调用时，这个函数可以通过 `this` 关键字访问其依附的这个对象。\nmyObj = {\n    myString: \"Hello world!\",\n    myFunc: function(){\n        return this.myString;\n    }\n};\nmyObj.myFunc(); // = \"Hello world!\"\n\n// 但这个函数访问的其实是其运行时环境，而非定义时环境，即取决于函数是如何调用的。\n// 所以如果函数被调用时不在这个对象的上下文中，就不会运行成功了。\nvar myFunc = myObj.myFunc;\nmyFunc(); // = undefined\n\n// 相应的，一个函数也可以被指定为一个对象的方法，并且可以通过 `this` 访问\n// 这个对象的成员，即使在函数被定义时并没有依附在对象上。\nvar myOtherFunc = function(){\n    return this.myString.toUpperCase();\n}\nmyObj.myOtherFunc = myOtherFunc;\nmyObj.myOtherFunc(); // = \"HELLO WORLD!\"\n\n// 当我们通过 `call`或者`apply` 调用函数的时候，也可以为其指定一个执行上下文。\nvar anotherFunc = function(s){\n    return this.myString + s;\n}\nanotherFunc.call(myObj, \" And Hello Moon!\"); // = \"Hello World! And Hello Moon!\"\n\n// `apply` 函数几乎完全一样，只是要求一个 array 来传递参数列表。\nanotherFunc.apply(myObj, [\" And Hello Sun!\"]); // = \"Hello World! And Hello Sun!\"\n\n// 当一个函数接受一系列参数，而你想传入一个 array 时特别有用。\nMath.min(42, 6, 27); // = 6\nMath.min([42, 6, 27]); // = NaN (uh-oh!)\nMath.min.apply(Math, [42, 6, 27]); // = 6\n\n// 但是 `call`和`apply` 只是临时的。如果我们希望函数附着在对象上，可以使用`bind`。\nvar boundFunc = anotherFunc.bind(myObj);\nboundFunc(\" And Hello Saturn!\"); // = \"Hello World! And Hello Saturn!\"\n\n// `bind` 也可以用来部分应用一个函数（柯里化）。\nvar product = function(a, b){ return a * b; }\nvar doubler = product.bind(this, 2);\ndoubler(8); // = 16\n\n// 当你通过 `new` 关键字调用一个函数时，就会创建一个对象，\n// 而且可以通过 this 关键字访问该函数。\n// 设计为这样调用的函数就叫做构造函数。\nvar MyConstructor = function(){\n    this.myNumber = 5;\n}\nmyNewObj = new MyConstructor(); // = {myNumber: 5}\nmyNewObj.myNumber; // = 5\n\n// 每一个 js 对象都有一个‘原型’。当你要访问一个实际对象中没有定义的一个属性时，\n// 解释器就回去找这个对象的原型。\n\n// 一些 JS 实现会让你通过 `__proto__` 属性访问一个对象的原型。\n// 这虽然对理解原型很有用，但是它并不是标准的一部分；\n// 我们后面会介绍使用原型的标准方式。\nvar myObj = {\n    myString: \"Hello world!\"\n};\nvar myPrototype = {\n    meaningOfLife: 42,\n    myFunc: function(){\n        return this.myString.toLowerCase()\n    }\n};\n\nmyObj.__proto__ = myPrototype;\nmyObj.meaningOfLife; // = 42\n\n// 函数也可以工作。\nmyObj.myFunc() // = \"hello world!\"\n\n// 当然，如果你要访问的成员在原型当中也没有定义的话，解释器就会去找原型的原型，以此类推。\nmyPrototype.__proto__ = {\n    myBoolean: true\n};\nmyObj.myBoolean; // = true\n\n// 这其中并没有对象的拷贝；每个对象实际上是持有原型对象的引用。\n// 这意味着当我们改变对象的原型时，会影响到其他以这个原型为原型的对象。\nmyPrototype.meaningOfLife = 43;\nmyObj.meaningOfLife; // = 43\n\n// 我们知道 `__proto__` 并非标准规定，实际上也没有标准办法来修改一个已存在对象的原型。\n// 然而，我们有两种方式为指定原型创建一个新的对象。\n\n// 第一种方式是 Object.create，这个方法是在最近才被添加到 Js 中的，\n// 因此并不是所有的 JS 实现都有这个方法\nvar myObj = Object.create(myPrototype);\nmyObj.meaningOfLife; // = 43\n\n// 第二种方式可以在任意版本中使用，不过必须通过构造函数。\n// 构造函数有一个属性 prototype。但是它 *不是* 构造函数本身的原型；相反，\n// 是通过构造函数和 new 关键字创建的新对象的原型。\nMyConstructor.prototype = {\n    myNumber: 5,\n    getMyNumber: function(){\n        return this.myNumber;\n    }\n};\nvar myNewObj2 = new MyConstructor();\nmyNewObj2.getMyNumber(); // = 5\nmyNewObj2.myNumber = 6\nmyNewObj2.getMyNumber(); // = 6\n\n// 字符串和数字等内置类型也有通过构造函数来创建的包装类型\nvar myNumber = 12;\nvar myNumberObj = new Number(12);\nmyNumber == myNumberObj; // = true\n\n// 但是它们并非严格等价\ntypeof myNumber; // = 'number'\ntypeof myNumberObj; // = 'object'\nmyNumber === myNumberObj; // = false\nif (0){\n    // 这段代码不会执行，因为 0 代表假\n}\n\n// 不过，包装类型和内置类型共享一个原型，\n// 所以你实际可以给内置类型也增加一些功能，例如对 string：\nString.prototype.firstCharacter = function(){\n    return this.charAt(0);\n}\n\"abc\".firstCharacter(); // = \"a\"\n\n// 这个技巧经常用在“代码填充”中，来为老版本的 javascript 子集增加新版本 js 的特性，\n// 这样就可以在老的浏览器中使用新功能了。\n\n// 比如，我们知道 Object.create 并没有在所有的版本中都实现，\n// 但是我们仍然可以通过“代码填充”来实现兼容：\nif (Object.create === undefined){ // 如果存在则不覆盖\n    Object.create = function(proto){\n        // 用正确的原型来创建一个临时构造函数\n        var Constructor = function(){};\n        Constructor.prototype = proto;\n        // 之后用它来创建一个新的对象\n        return new Constructor();\n    }\n}\n```","type":"text/markdown","created":"20230606152640462","creator":"oeyoews","modified":"20231017090030530","modifier":"oeyoews","publish":"article","tags":"JavaScript"},{"title":"listener-multi","text":"if add mulit same listener, this will execute theme orderly","type":"text/markdown","created":"20231002163212340","creator":"oeyoews","modified":"20231002163256754","modifier":"oeyoews","tags":"JavaScript"},{"title":"listener-once","text":"如果您想要在 HTML 元素上添加只监听一次的事件处理程序，可以使用 `addEventListener()` 方法的 `{once: true}` 选项。这个选项允许您在元素上添加一个只触发一次的事件监听器。\r\n\r\n以下是一个使用 `{once: true}` 选项的示例：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\nconst button = document.getElementById('myButton');\r\n\r\nfunction handleClick() {\r\n  console.log('按钮被点击了');\r\n}\r\n\r\nbutton.addEventListener('click', handleClick, {once: true});\r\n</script>\r\n```\r\n\r\n在上述示例中，我们首先获取了一个 `<button>` 元素，并为其添加了一个点击事件监听器 `handleClick`。通过将 `{once: true}` 对象作为第三个参数传递给 `addEventListener` 方法，我们指示浏览器只触发该事件监听器一次。当用户单击按钮时，将执行 `handleClick` 函数并记录一条消息。\r\n\r\n请注意，`{once: true}` 选项仅适用于当前添加的事件监听器。如果需要在将来再次添加一个只监听一次的事件监听器，您将需要重新使用 `{once: true}` 选项。","type":"text/markdown","created":"20231002164609607","creator":"oeyoews","modified":"20231002164621621","modifier":"oeyoews","tags":"JavaScript"},{"title":"localStorage-listener","text":"在 Web 应用中，有多种方法可以实现数据共享。其中一种方式是使用`localStorage`来存储和读取数据，以便多个页面之间可以共享相同的数据。\r\n\r\n使用`localStorage`进行数据共享，有以下几个步骤：\r\n\r\n1. 在一个页面中使用`localStorage.setItem()`方法将要共享的数据存储到`localStorage`中。\r\n2. 在另一个页面中使用`localStorage.getItem()`方法获取保存在`localStorage`中的数据。\r\n3. 在每个页面中使用`window.addEventListener()`方法监听`storage`事件。\r\n4. 当`storage`事件被触发时，使用`localStorage.getItem()`方法获取更新后的最新数据。\r\n\r\n以下是一个简单示例，演示如何在两个页面之间共享数据：\r\n\r\n```plain\r\n// 页面 1\r\n// 存储数据\r\nlocalStorage.setItem('name', '张三');\r\n\r\n// 页面 2\r\n// 获取数据\r\nconst name = localStorage.getItem('name');\r\nconsole.log(name); // 输出：'张三'\r\n\r\n// 监听 storage 事件\r\nwindow.addEventListener('storage', function(event) {\r\n  if (event.key === 'name') {\r\n    console.log('共享的数据已更新为：' + event.newValue);\r\n  }\r\n});\r\n```\r\n\r\n上述代码在页面 1 中存储了一个名为`name`的数据，然后在页面 2 中通过`localStorage.getItem()`方法获取存储在`localStorage`中的`name`数据。此外，在页面 2 中使用`window.addEventListener()`方法监听`storage`事件，以便在该数据发生更改时获取通知。当在页面 1 中更改`name`数据时，将触发`storage`事件，在页面 2 中会输出提示消息。\r\n\r\n需要注意的是，由于`localStorage`在同一个域名下的所有页面之间共享，因此，这种数据共享方式受到同源策略的限制，无法实现跨域数据共享。同时，为了避免数据冲突，在使用`localStorage`共享数据时，应该根据数据的使用场景和业务需求，制定良好的数据处理规则，避免不同页面之间的数据误操作。","type":"text/markdown","created":"20231002060625732","creator":"oeyoews","modified":"20231002060646179","modifier":"oeyoews","tags":"JavaScript"},{"title":"lodash","text":"Lodash 是一个流行的 JavaScript 实用工具库，提供了许多常见的函数和方法，可以帮助我们更加方便地操作数值、字符串、对象、数组等各种数据类型。Lodash 已经被广泛应用于 Web 开发、移动端开发、服务器端开发等多个领域。\r\n\r\n以下是几个 Lodash 中常用的方法：\r\n\r\n1. map：循环遍历数组或对象，并对其中的每个元素进行处理，返回处理后的新数组或对象。\r\n\r\n```javascript\r\n_.map([1, 2, 3], function(n) { return n * 2; });\r\n// => [2, 4, 6]\r\n```\r\n\r\n2. filter：过滤出符合条件的数组元素，并返回一个新的数组。\r\n\r\n```javascript\r\n_.filter([1, 2, 3, 4, 5, 6], function(n) { return n % 2 == 0; });\r\n// => [2, 4, 6]\r\n```\r\n\r\n3. reduce：对数组中的元素进行累加处理，并返回结果。\r\n\r\n```javascript\r\n_.reduce([1, 2, 3], function(sum, n) { return sum + n; }, 0);\r\n// => 6\r\n```\r\n\r\n4. find：查找符合条件的第一个数组元素，并返回该元素。\r\n\r\n```javascript\r\nvar users = [\r\n  { 'user': 'barney',  'age': 36, 'active': true },\r\n  { 'user': 'fred',    'age': 40, 'active': false },\r\n  { 'user': 'pebbles', 'age': 1,  'active': true }\r\n];\r\n\r\n_.find(users, function(o) { return o.age < 40; });\r\n// => { 'user': 'barney', 'age': 36, 'active': true }\r\n```\r\n\r\n以上是 Lodash 中的几个常用方法，Lodash 还提供了许多其他实用的函数和方法，可以根据需要使用。","type":"text/markdown","created":"20230503024016290","creator":"oeyoews","modified":"20230503024030308","modifier":"oeyoews","tags":"JavaScript"},{"title":"logic-operator","created":"20230527113455267","creator":"oeyoews","modified":"20230527113506053","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"JavaScript中有三种逻辑运算符：&&、||、!。这些逻辑运算符可以用于比较和操作布尔值。其中，&&表示逻辑与，||表示逻辑或，!表示逻辑非。\n\n逻辑与（&&）：当且仅当两个操作数都为true时，返回true。如果其中一个操作数为false，则返回false。例如：\n\n```\r\nconsole.log(true && true); // 输出true\r\nconsole.log(true && false); // 输出false\r\nconsole.log(false && false); // 输出false\r\n```\n\n逻辑或（||）：当至少有一个操作数为true时，返回true。如果两个操作数都为false，则返回false。例如：\n\n```\r\nconsole.log(true || true); // 输出true\r\nconsole.log(true || false); // 输出true\r\nconsole.log(false || false); // 输出false\r\n```\n\n逻辑非（!）：用于对布尔值进行取反操作，即将true变为false，false变为true。例如：\n\n```\r\nconsole.log(!true); // 输出false\r\nconsole.log(!false); // 输出true\r\n```\n\n逻辑运算符可以用于复杂的条件判断和流程控制，特别是在与if语句和三元运算符结合使用时非常方便。需要注意的是，逻辑运算符的运算顺序是从左到右，可以通过使用圆括号来改变运算顺序。"},{"title":"Map","text":":::abstract\n一击命中\n:::\n\nmap 是什么呢？在 JavaScript 中，map 是一种数据结构，用于存储键值对的集合。与普通的对象不同，map 的键可以是任意类型的值，包括基本类型和对象等。map 的键值对可以使用 set() 方法添加，使用 get() 方法获取。map 还有一些常用的方法，包括 has() 判断是否存在某个键、delete() 删除某个键值对、clear() 清空所有的键值对等。下面是一个使用 map 的示例：\n\n```javascript\nconst myMap = new Map(); // 创建一个空的 map\n\n// 使用 set() 方法添加键值对\nmyMap.set('name', '张三');\nmyMap.set('age', 18);\nmyMap.set({x: 1, y: 2}, '一个对象');\n\n// 使用 get() 方法获取键对应的值\nconsole.log(myMap.get('name')); // 输出：张三\nconsole.log(myMap.get('age')); // 输出：18\nconsole.log(myMap.get({x: 1, y: 2})); // 输出：undefined（注意这里的对象不是同一个对象）\n\n// 使用 has() 方法判断是否存在某个键\nconsole.log(myMap.has('name')); // 输出：true\nconsole.log(myMap.has('gender')); // 输出：false\n\n// 使用 delete() 方法删除某个键值对\nmyMap.delete('age');\nconsole.log(myMap); // 输出：Map(2) { 'name' => '张三', { x: 1, y: 2 } => '一个对象' }\n\n// 使用 clear() 方法清空所有的键值对\nmyMap.clear();\nconsole.log(myMap); // 输出：Map(0) {}\n```\n\nmap 是一种非常有用的数据结构，可以用于解决很多问题，比如需要存储键值对的场景、需要按照某种顺序存储元素的场景等。\n\n键的唯一性：在 Map 中，每个键都是唯一的，不会出现重复的键。这意味着你可以使用任意类型的值作为键，并确保键的唯一性。\n\n保持插入顺序：与普通的对象不同，Map 会维护插入键值对的顺序。这意味着当你迭代 Map 时，键值对的顺序与插入顺序保持一致。\n\n支持任意类型的键：在 Map 中，你可以使用任意类型的值作为键，包括字符串、数字、布尔值、对象或其他 Map。这使得 Map 对象非常灵活，适用于各种场景。\n\n可以快速地查找、插入和删除：Map 提供了一系列方法来操作键值对，包括 get() 获取值、set() 设置值、has() 判断键是否存在、delete() 删除指定的键值对等等。这些方法的时间复杂度通常是 O(1)，因此在大多数情况下，操作 Map 的效率非常高。\n\n可以使用迭代器遍历：Map 支持迭代器，可以使用 for...of 循环或 forEach() 方法来遍历键值对。这使得处理和操作 Map 中的数据变得非常方便。","type":"text/markdown","created":"20230527134522636","creator":"oeyoews","modified":"20231028001527916","modifier":"oeyoews","tags":"JavaScript"},{"title":"map-foreach","created":"20230602154318789","creator":"oeyoews","modified":"20231018055553751","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"`map` 和 `forEach` 是两种不同的数组遍历方法，它们的主要区别在于返回值和使用方式上。\n\n`forEach` 方法可以用来遍历数组中的每一个元素，对于每个元素都执行指定的操作。但是，`forEach` 方法没有返回值，它仅仅是执行了指定的操作，而__不会返回任何值__。\n\n`map` 方法则可以用来将数组中的每个元素映射成新的值，返回一个新的数组。它会根据回调函数的返回值来生成新的数组。也就是说，`map` 方法可以通过对数组进行转换，生成一个新的数组，而不会修改原始数组。\n\n下面是 `forEach` 和 `map` 方法的使用示例：\n\n```js\nconst arr = [1, 2, 3, 4];\n\n// 使用 forEach 方法\narr.forEach(item => {\n  console.log(item);\n});\n\n// 使用 map 方法\nconst newArr = arr.map(item => item * 2);\nconsole.log(newArr);\n```\n\n在使用这两种方法时，需要注意的是，回调函数的参数不同。`forEach` 方法的回调函数有三个参数：当前遍历的元素、当前元素的索引和整个数组。而 `map` 方法的回调函数只有两个参数：当前遍历的元素和当前元素的索引。\n\n希望这些信息可以帮助您更好地理解 `forEach` 和 `map` 方法之间的区别。"},{"title":"MethodChaining","text":"方法链（Method Chaining）是一种编程技术，它允许在一个对象上连续地调用多个方法，而不需要每次调用都使用一个中间变量保存对象的引用。通过方法链，可以在一行代码中依次调用多个方法，并且每个方法的返回值都是该对象本身，从而可以在同一个对象上连续地调用多个方法。\r\n\r\n方法链的语法通常是在对象上直接调用一个方法，然后在该方法的返回值上继续调用另一个方法，以此类推。例如：\r\n\r\n```js\r\nobj.method1().method2().method3();\r\n```\r\n\r\n```js\r\n// obj method\r\n\r\nclass Person {\r\n  constructor() {\r\n    this.name = \"John\";\r\n    this.age = 30;\r\n  }\r\n  log1 = () => {\r\n    console.log(\"one\");\r\n    return this;\r\n  };\r\n\r\n  log2 = () => {\r\n    console.log(\"two\");\r\n    return this;\r\n  };\r\n}\r\n\r\nconst p = new Person();\r\np.log1().log2();\r\n```\r\n\r\n上述代码中，obj 是一个对象，method1、method2 和 method3 是该对象上的三个方法。通过方法链的方式，可以依次调用这三个方法，并且每个方法的返回值都是该对象本身，所以可以连续调用下一个方法。\r\n\r\n方法链的好处是可以使代码更加简洁和易读，尤其是在需要对同一个对象执行多个连续操作的情况下。它可以减少临时变量的使用，并且可以在一行代码中清晰地表达多个操作的逻辑关系。\r\n\r\n需要注意的是，方法链并不适用于所有情况，特别是当某个方法的返回值类型与后续方法不兼容时，方法链就无法继续进行。此外，过度使用方法链可能会导致代码可读性下降，因此在使用方法链时需要根据具体情况进行权衡和选择。","type":"text/markdown","created":"20230612052402680","creator":"oeyoews","modified":"20230726045248512","modifier":"oeyoews","tags":"JavaScript"},{"title":"Monorepo","text":"Monorepo 是一种软件开发的管理方法，它可以帮助开发者更好地管理大型项目、团队协作和代码共享等方面的问题。具体来说，Monorepo 是指将多个相关项目组合成一个单独的存储库（或代码库）中，这些项目可以是不同的应用、服务、工具库或者是其他类型的代码库。\r\n\r\n使用 Monorepo 的主要优点包括：\r\n\r\n- 代码共享：不同项目之间可以共享代码，避免重复编写或复制粘贴代码，减少冗余代码。\r\n- 统一构建、测试和部署：由于所有项目都在同一个代码库中，因此可以方便地进行统一的构建、测试和部署。\r\n- 统一的开发规范：可以统一项目的开发规范，例如代码格式、依赖管理等，提高代码的可维护性和可读性。\r\n- 更好的团队协作：不同开发者可以更容易地共享代码、协作开发以及解决问题。\r\n\r\n然而，Monorepo 也存在一些缺点：\r\n\r\n- 单点故障：所有项目都在同一个代码库中，如果出现了严重的问题可能会影响到整个代码库的稳定性。\r\n- 版本管理较为复杂：不同项目之间的版本号需要进行管理，否则可能导致代码的兼容性问题。\r\n- 构建时间较长：由于需要构建所有项目，因此构建时间可能比较长。\r\n\r\n在实际使用 Monorepo 时，可以采用一些工具来辅助管理，例如 Lerna、Yarn Workspaces 等。这些工具可以帮助开发者更好地管理 Monorepo 中的依赖关系、版本控制等问题，提高开发效率。\r\n\r\n总之，Monorepo 是一种管理大型项目和团队协作的方法，它可以带来一些好处，但也需要注意其缺点，根据实际情况选择合适的方案。","type":"text/markdown","created":"20230502054312303","creator":"oeyoews","modified":"20230502054322664","modifier":"oeyoews","tags":"JavaScript"},{"title":"mutations","text":"```js\r\n// 要观察的元素\r\nconst targetElement = document.getElementById(\"my-element\");\r\n\r\n// 创建 MutationObserver 对象\r\nconst observer = new MutationObserver((mutations) => {\r\n  console.log(\"元素变化啦！\", mutations);\r\n\r\n  // 隐藏按钮\r\n  const button = document.getElementById(\"my-button\");\r\n  button.style.display = \"none\";\r\n});\r\n\r\n// 指定要观察的元素以及要观察的变化类型\r\nobserver.observe(targetElement, { childList: true, attributes: true, subtree: true, characterData: true });\r\n```","type":"text/markdown","created":"20230609130544421","creator":"oeyoews","modified":"20230726045248518","modifier":"oeyoews","tags":"JavaScript"},{"title":"mvc-mvvm","text":"MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）是两种常见的前端应用程序架构模式，它们的主要区别如下：\r\n\r\n1. 模型与视图的关系不同：在 MVC 中，视图和模型是分离的。控制器作为桥梁，将模型和视图链接在一起。而在 MVVM 中，视图通过数据绑定直接绑定到 ViewModel 上，ViewModel 与模型交互并提供必要的方法。\r\n\r\n2. 数据双向绑定：MVVM 引入了数据双向绑定的概念，使得视图和 ViewModel 之间的交互更加便捷。当 ViewModel 中的数据发生变化时，视图会自动更新；当用户在视图中输入数据时，ViewModel 会自动更新数据模型。\r\n\r\n3. 控制器与 ViewModel 的区别：MVVM 中没有控制器的概念，而是引入了 ViewModel。ViewModel 既可以处理视图的显示逻辑，也可以与模型进行交互。而控制器则只负责处理视图和模型之间的通信。\r\n\r\n4. 独立性不同：在 MVC 中，视图、模型和控制器都是独立的组件，彼此之间没有强耦合。而在 MVVM 中，ViewModel 是视图和模型之间的桥梁，它们之间的联系更加紧密。\r\n\r\n总的来说，MVC 和 MVVM 都是优秀的前端应用程序架构模式，它们各有优缺点，适用于不同的场景和需求。对于需要频繁更新视图的复杂单页应用程序，MVVM 更为适合；而对于传统的多页 Web 应用程序，MVC 则更加适用。","type":"text/markdown","created":"20230503031328980","creator":"oeyoews","modified":"20230503031338437","modifier":"oeyoews","tags":"JavaScript"},{"title":"network-type","text":"```js\r\nnavigator.connection\r\n```","type":"text/markdown","created":"20230926105235914","creator":"oeyoews","modified":"20230926105259297","modifier":"oeyoews","tags":"JavaScript"},{"title":"new-obj","text":"当我们使用 `new` 关键字创建一个对象时，实际上会发生下面三件事情：\r\n\r\n1. 创建一个空的 JavaScript 对象。\r\n2. 将该对象的原型指向构造函数的原型。\r\n3. 将该对象作为 `this` 关键字传递给构造函数，并执行构造函数。\r\n\r\n因此，在使用 `new` 关键字创建对象时，我们通常可以直接将对象赋值给变量，而不需要先将变量声明并赋值为 `null` 或 `undefined`。这是因为 `new` 关键字会自动为我们创建一个对象并将其赋值给变量。\r\n\r\n例如，我们可以这样创建一个对象：\r\n\r\n```js\r\nconst obj = new Object();\r\n```\r\n\r\n在这个例子中，我们使用 `new` 关键字创建了一个空的 `Object` 对象，并将其赋值给 `obj` 变量。这个过程可以简写成下面这样：\r\n\r\n```js\r\nconst obj = {};\r\n```\r\n\r\n这样就创建了一个空的对象，并将其赋值给 `obj` 变量。","type":"text/markdown","created":"20230609143145197","creator":"oeyoews","modified":"20230726045248741","modifier":"oeyoews","tags":"JavaScript"},{"title":"node-browser-cros","text":"在浏览器中，由于安全原因，存在同源策略 (Same-Origin Policy) 的限制。同源策略是一种安全机制，它阻止了通过脚本从一个源加载的文档或脚本访问另一个源的内容，除非这两个源具有相同的协议、主机名和端口号。\n\n跨域请求是指在浏览器环境下，通过脚本发起的 HTTP 请求，其目标地址与当前页面的主机、端口或协议不一致。浏览器会根据同源策略进行安全限制，通常会导致跨域请求失败。\n\n而在 Node.js 环境中，没有同源策略的限制。Node.js 是一个基于 V8 引擎的 JavaScript 运行时环境，用于服务器端开发。在 Node.js 中，你可以使用内置的`http`模块或第三方库（例如`node-fetch`）进行 HTTP 请求，并且不会受到同源策略的限制。\n\n当你在 Node 环境中使用`fetch`函数发送跨域请求时，服务器不会对请求的源进行同源策略的检查，因此可以成功获取跨域资源。这使得 Node.js 成为一个强大的工具，可以用于爬虫、数据抓取等需要访问其他域上资源的场景。\n\n需要注意的是，尽管在 Node.js 环境下可以跨域访问资源，但在浏览器中依然会受到同源策略的限制。如果你需要在浏览器中进行跨域请求，可以通过使用 CORS（跨域资源共享）或 JSONP 等技术进行解决。","type":"text/markdown","created":"20231104084254000","creator":"oeyoews","modified":"20231104084321812","modifier":"oeyoews","tags":"JavaScript"},{"title":"NodeList","text":"`NodeList` 是一个类数组对象，它包含一组 `Node` 对象，这些对象通常是由 `querySelectorAll` 方法返回的。`NodeList` 对象具有以下特点：\r\n\r\n- 它是一个类数组对象，它的每个成员都是一个 `Node` 对象。\r\n- 它是只读的，不能修改它的成员。\r\n- 它是动态的，意味着它会随着文档的变化而自动更新。\r\n\r\n你可以使用 `NodeList` 对象的属性和方法来访问和操作它的成员。例如，你可以使用 `length` 属性获取 `NodeList` 对象的长度，使用 `item` 方法或方括号语法访问 `NodeList` 对象的成员，使用 `forEach` 方法迭代 `NodeList` 对象的成员，等等。\r\n\r\n以下是一个使用 `NodeList` 对象的示例：\r\n\r\n```js\r\n// 获取所有 p 元素\r\nconst paragraphs = document.querySelectorAll('p');\r\n\r\n// 获取 paragraphs 的长度\r\nconst length = paragraphs.length;\r\n\r\n// 访问 paragraphs 的第一个元素\r\nconst firstParagraph = paragraphs[0];\r\nconst firstParagraph2 = paragraphs.item(0);\r\n\r\n// 迭代 paragraphs 中的每个元素\r\nparagraphs.forEach((paragraph) => {\r\n  console.log(paragraph.textContent);\r\n});\r\n```\r\n\r\n在这个例子中，我们使用 `querySelectorAll` 方法获取了所有 `p` 元素，并将它们存储在一个 `NodeList` 对象 `paragraphs` 中。然后，我们使用 `length` 属性获取 `paragraphs` 的长度，使用方括号语法和 `item` 方法访问 `paragraphs` 的第一个元素，使用 `forEach` 方法迭代 `paragraphs` 中的每个元素，并在控制台中打印每个段落元素的文本内容。\r\n\r\n\r\n```js\r\n// 创建 MutationObserver 对象\r\nconst observer = new MutationObserver((mutations) => {\r\n  console.log(\"tc-story-river 元素变化啦！\", mutations);\r\n\r\n  // 暂停观察目标元素\r\n  observer.disconnect();\r\n  copyButton();\r\n  // 恢复观察目标元素\r\n  observer.observe(document.querySelector(\".tc-story-river\"), {\r\n    childList: true,\r\n    subtree: true,\r\n  });\r\n});\r\n\r\n// 指定要观察的元素选择器以及要观察的变化类型\r\nobserver.observe(document.querySelector(\".tc-story-river\"), {\r\n  childList: true,\r\n  subtree: true,\r\n});\r\n```","type":"text/markdown","created":"20230609130758352","creator":"oeyoews","modified":"20230726045248742","modifier":"oeyoews","tags":"JavaScript"},{"title":"Nodelist hidden","text":"是的，HTML节点有一个hidden属性，它是一个布尔属性。当设置为true时，该属性将隐藏该节点，使其在页面中不可见。要使用hidden属性，只需将其添加到HTML标签中即可，例如：\n\n```html\n<div hidden>这是一个隐藏的节点</div>\n```\n\n```js\nxxxNodelist.hidden = true\n```\n\n在上面的示例中，div元素被隐藏起来，因此在页面上不可见。\n","type":"text/markdown","created":"20240130141510564","creator":"oeyoews","modified":"20240130141633705","modifier":"oeyoews","tags":"JavaScript"},{"title":"Null-Undefined","text":"- **null**表示一个空值或不存在的对象。当我们将变量初始化为 null 时，意味着它没有被赋予任何值。null 是一个特殊的关键字，用于表示一个空的或无效的对象。例如，如果你有一个指向对象的变量，但是你想要明确地表示该对象为空，你可以将该变量设置为 null。\r\n\r\n  以下是一个示例：\r\n  ```javascript\r\n  let obj = null;\r\n  console.log(obj); // 输出：null\r\n  ```\r\n\r\n- **undefined**表示一个未定义的值。当变量声明但没有被赋值时，它的默认值就是 undefined。此外，如果你访问一个对象的属性或函数，而该对象本身未被定义，那么该属性或函数的值也将是 undefined。\r\n\r\n  以下是一些示例：\r\n  ```javascript\r\n  let x; // 声明一个变量但未赋值\r\n  console.log(x); // 输出：undefined\r\n\r\n  let obj; // 声明一个对象变量但未定义\r\n  console.log(obj.property); // 输出：undefined\r\n  ```\r\n\r\n* 在总结上述区别时，可以将 null 视为已定义但空的值，而 undefined 表示未定义的值。\r\n\r\n* null 是一个表示“空”的对象，转为数值时为 0；undefined 是一个表示\"此处无定义\"的原始值，转为数值时为 NaN。","type":"text/markdown","created":"20230619144051106","creator":"oeyoews","modified":"20230726045248745","modifier":"oeyoews","tags":"JavaScript"},{"title":"number-boolean","text":"```js\r\nport !== Number(PORT) // right\r\n!port === Number(PORT) // wrong !port: port 不是 boolean, 是 number\r\n```","type":"text/markdown","created":"20230924062036422","creator":"oeyoews","modified":"20230924062222375","modifier":"oeyoews","tags":"JavaScript Bug"},{"title":"obj-clone","text":":::abstract\n其实主要是引用类型，浅拷贝只能针对基本数据类型\n:::\n\n我们可以通过生活中的例子来更加形象地理解深拷贝和浅拷贝。\n\n假设你有一本书，书中有很多章节，每个章节有许多页，每页上有文字和图片。这本书就可以看作是一个对象，每个章节就是一个数组，每页就是一个对象，文字和图片就是属性值。\n\n现在你想要把这本书借给你的朋友，但是你不想让朋友修改这本书的内容。如果你使用浅拷贝的方式，就相当于把这本书复制了一份，让你的朋友也可以看到这本书，但是你们两个人看到的是同一本书，如果你的朋友在书中做了标记或修改了内容，你也会看到这些标记和修改。\n\n如果你使用深拷贝的方式，就相当于把这本书复制了一份，但是你和你的朋友看到的是两本不同的书，你朋友对他的那本书做了任何修改，都不会影响你看到的那本书。\n\n另外，我们也可以举一个更加简单的例子来理解深拷贝和浅拷贝。假设你有一个盒子，里面放了一个苹果。如果你使用浅拷贝的方式，就相当于你把这个盒子复制了一份，但是两个盒子里面放的还是同一个苹果，如果你从一个盒子里取出苹果，另一个盒子里的苹果也会被取出。如果你使用深拷贝的方式，就相当于你把这个盒子复制了一份，但是两个盒子里面放的是两个完全一样的苹果，如果你从一个盒子里取出苹果，另一个盒子里的苹果还是在原地。\n\n深拷贝（deep copy）和浅拷贝（shallow copy）是在 JavaScript 中经常用到的概念。\n\n浅拷贝是指将一个对象的属性值复制到另一个对象，如果属性值是基本数据类型（如字符串、数字、布尔值等），则复制的是基本数据类型的值；如果属性值是引用数据类型（如数组、对象、函数等），则复制的是内存地址，也就是说两个对象会共享同一个引用类型的值。如果其中一个对象修改了这个引用类型的值，另一个对象也会受到影响。\n\n深拷贝则是将一个对象的所有属性值都复制到另一个对象，包括基本数据类型和引用数据类型。即使原始对象中的引用类型属性值发生了改变，拷贝后的对象中的引用类型属性值也不会受到影响，因为它们指向的是不同的内存地址。\n\n举个例子，如果我们有一个对象 obj1：\n\n```javascript\nconst obj1 = {\n  name: 'Alice',\n  age: 18,\n  hobbies: ['reading', 'dancing'],\n  address: {\n    city: 'Shanghai',\n    street: 'Nanjing Road',\n  },\n};\n```\n\n那么浅拷贝 obj2 可以通过以下方式实现：\n\n```javascript\nconst obj2 = Object.assign({}, obj1);\n```\n\n此时修改 obj1 的 hobbies 属性会影响 obj2：\n\n```javascript\nobj1.hobbies.push('swimming');\nconsole.log(obj2.hobbies); // ['reading', 'dancing', 'swimming']\n```\n\n而深拷贝 obj3 可以通过以下方式实现：\n\n```javascript\nconst obj3 = JSON.parse(JSON.stringify(obj1));\n```\n\n此时修改 obj1 的 hobbies 属性不会影响 obj3：\n\n```javascript\nobj1.hobbies.push('swimming');\nconsole.log(obj3.hobbies); // ['reading', 'dancing']\n```\n\n需要注意的是，JSON.parse(JSON.stringify()) 这种方式虽然可以实现深拷贝，但是它有一些限制，例如无法拷贝函数、正则表达式等特殊对象。在实际开发中，需要根据具体情况选择合适的方式进行拷贝。\n\n\n直接修改 `b` 对象和修改 `b` 对象里面的值是有区别的。\n\n当你直接修改 `b` 对象时，意味着你对 `b` 进行了重新赋值或者指向了另一个对象。这将导致 `b` 引用的对象完全改变，与原始对象不再有任何关联。\n\n而当你修改 `b` 对象里面的值时，即使你修改了 `b` 对象的属性值，但 `b` 仍然指向的是同一个对象。因此，如果其他地方有引用到 `b` 的地方也会受到影响。\n\n\n```javascript\nconst sourceObj = {a: 1, b: {c: 2}};\n\n// 直接修改 b 对象\nsourceObj.b = {d: 3};\nconsole.log(sourceObj); // {a: 1, b: {d: 3}}\n\n// 修改 b 对象里面的值\nsourceObj.b.c = 4;\nconsole.log(sourceObj); // {a: 1, b: {c: 4}}\n```\n\n在第一个例子中，我们直接修改了 `sourceObj.b` 对象，将其重新赋值为 `{d: 3}`。这导致 `b` 引用的对象完全改变，与原始对象 `{c: 2}` 不再有任何关联。\n\n在第二个例子中，我们修改了 `sourceObj.b.c` 的值，而 `b` 仍然指向的是同一个对象。所以，如果其他地方有引用到 `sourceObj.b` 的地方，它们也会看到这个修改。\n\n因此，直接修改 `b` 对象会改变整个对象的结构，而修改 `b` 对象里面的值只是修改了对象内部的属性值。区别在于是否影响到其他引用了该对象的地方。","type":"text/markdown","created":"20230522104023587","creator":"oeyoews","modified":"20231103055759420","modifier":"oeyoews","qrcode":"yes","tags":"JavaScript"},{"title":"obj-create","created":"20230530151848264","creator":"oeyoews","modified":"20230530151924381","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"Object.create() 是 JavaScript 中的一个方法，它可以创建一个新的对象，并将其原型指向传入的对象。传入的对象可以是 null，这种情况下创建的新对象不会继承任何属性和方法。 \n\n举个例子，如果我们想要创建一个新的对象，并让它继承一个现有的对象的属性和方法，可以这样写：\n\n```js\r\nconst parentObj = {\r\n  sayHello() {\r\n    console.log('Hello!');\r\n  }\r\n};\n\nconst childObj = Object.create(parentObj);\n\nchildObj.sayHello(); // 输出 \"Hello!\"\r\n```\n\n在这个例子中，我们创建了一个名为 parentObj 的对象，并给它定义了一个 sayHello() 方法。然后我们使用 Object.create() 创建了一个新的对象 childObj，并将其原型指向 parentObj。这样，childObj 就继承了 parentObj 的 sayHello() 方法。\n\nObject.create() 的应用场景比较多，其中最常见的就是实现对象继承。通过 Object.create()，我们可以创建一个新的对象，并将其原型指向另一个对象，从而实现对象之间的继承关系。在一些面向对象的程序设计中，继承是非常常见的操作，Object.create() 就是一个非常方便的工具。\n\n另外，Object.create() 还可以用于创建纯净的对象，在 JavaScript 中，所有的对象都会继承一些属性和方法，比如 Object.prototype 上的方法。如果我们想要创建一个完全没有继承关系的新对象，可以使用 Object.create(null) 来创建一个没有原型的纯净对象。这种对象可以用来存储键值对，不会受到原型的影响，也不会有原型链相关的性能损失。"},{"title":"Object","created":"20230530102039726","creator":"oeyoews","modified":"20230530102104129","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"Object 是 JavaScript 中的一个内置对象，它是所有对象的基础，也是所有对象之间共享的属性和方法的存储库。\n\n在 JavaScript 中，几乎所有的值都是对象，包括数字、字符串、数组、函数等。每个对象都有一组属性和方法，可以通过点运算符或方括号来访问它们。\n\nObject 对象有一些常用的属性和方法，如：\n\n- Object.prototype：Object 的原型对象，它包含了一些常用的方法，如 toString()、hasOwnProperty() 等。\r\n- Object.keys(obj)：返回一个由给定对象的所有可枚举自身属性的属性名组成的数组。\r\n- Object.values(obj)：返回一个给定对象自身的所有可枚举属性值的数组。\r\n- Object.assign(target, ...sources)：将一个或多个源对象的所有可枚举属性复制到目标对象中，并返回目标对象。\n\n除了这些常用的属性和方法，Object 还有很多其他的属性和方法，可以通过查阅相关文档来了解。"},{"title":"Object-assign","text":"`Object.assign()` 方法是一个用于将一个或多个源对象的属性复制到目标对象的方法。它接受两个或多个参数，第一个参数是目标对象，后面的参数都是源对象。\n\n语法如下：\n\n```plain\nObject.assign(target, ...sources)\n```\n\n其中，`target` 参数是目标对象，`...sources` 是一个或多个源对象。\n\n`Object.assign()` 方法会将每个源对象中可枚举的、自有的属性复制到目标对象中。如果目标对象和源对象具有相同的属性，则后来的属性会覆盖先前的属性。该方法会返回目标对象。\n\n下面是一个简单的示例，演示了如何使用 `Object.assign()` 方法将两个对象合并到一个新对象中：\n\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst newObj = Object.assign({}, obj1, obj2);\n\nconsole.log(newObj); // { a: 1, b: 2, c: 3, d: 4 }\n```\n\n在上面的示例中，我们创建了两个源对象 `obj1` 和 `obj2`，并使用 `Object.assign()` 方法将它们合并到一个新对象 `newObj` 中。注意，我们首先传递了一个空对象 `{}` 作为目标对象，这样就不会修改任何已有的对象。\n\n除了合并对象外，`Object.assign()` 方法还可以用于复制对象。例如，如果你想要创建一个新对象，该对象与现有对象具有相同的属性和值，可以使用 `Object.assign()` 方法：\n\n```javascript\nconst obj = { a: 1, b: 2 };\nconst newObj = Object.assign({}, obj);\n\nconsole.log(newObj); // { a: 1, b: 2 }\n```\n\n在上面的示例中，我们创建了一个新对象 `newObj`，它与现有对象 `obj` 具有相同的属性和值。这样做的好处是，你可以修改 `newObj`，而不会影响到原始对象 `obj`。\n\n需要注意的是，`Object.assign()` 方法只会复制源对象自有的、可枚举的属性。如果源对象的属性是继承来的，或者是不可枚举的，则不会被复制。此外，该方法只会复制属性的值，而不会复制属性所代表的特性（例如，是否可写、可枚举等）。\n\n`Object.assign(one, two)` 会将 `two` 对象的属性和值合并到 `one` 对象中，并返回合并后的 `one` 对象。如果 `one` 对象中已经存在相同的属性，则会覆盖原有的值。\n\n`Object.assign({}, one, two)` 会创建一个新的空对象，然后将 `one` 和 `two` 对象的属性和值合并到该空对象中，并返回合并后的新对象。如果 `one` 和 `two` 对象中都存在相同的属性，则后面的对象的属性值会覆盖前面的对象的属性值。\n\n因此，两者的区别在于：\n\n- `Object.assign(one, two)` 会改变 `one` 对象本身，而 `Object.assign({}, one, two)` 不会改变 `one` 和 `two` 对象本身。\n- `Object.assign({}, one, two)` 会返回一个新的合并后的对象，而 `Object.assign(one, two)` 不会返回新的对象，而是返回合并后的 `one` 对象。\n\n需要注意的是，`Object.assign()` 方法是浅拷贝，即如果属性值是一个对象，则只会复制对象的引用，而不会复制对象本身。如果要实现深拷贝，需要使用其他方法。","type":"text/markdown","created":"20231027121810815","creator":"oeyoews","modified":"20231028091118075","modifier":"oeyoews","tags":"JavaScript"},{"title":"Object-create-for-prototype","text":"`Object.create(null)` 的作用是创建一个空对象，该对象的原型链为空，即它不继承任何属性和方法。这样的对象通常被称为“纯净”对象或“字典对象”。\n\n使用 `Object.create(null)` 创建的对象不继承任何默认的属性或方法，包括那些来自 `Object` 原型链的属性和方法。这使得这个对象在某些场景下更适用，特别是在需要确保对象不受原型链上的属性影响时。\n\n例如，考虑以下情况：\n\n```javascript\n// 创建一个普通对象\nvar normalObject = {};\nconsole.log(normalObject.toString); // [Function: toString]\n\n// 创建一个使用 Object.create(null) 的纯净对象\nvar pureObject = Object.create(null);\nconsole.log(pureObject.toString); // undefined\n```\n\n在上面的例子中，`normalObject` 是一个普通对象，它继承了 `Object` 原型链上的方法，如 `toString`。相比之下，`pureObject` 是使用 `Object.create(null)` 创建的对象，它不继承任何属性，因此 `toString` 是 `undefined`。\n\n使用 `Object.create(null)` 的主要优势是可以避免意外地访问到原型链上的属性和方法，从而减少潜在的冲突或错误。这在需要一个纯净的对象来充当简单的键-值存储或字典时特别有用。\n\n`Object.create` 主要用于创建一个新对象，并将新对象的原型链指向指定的对象。这在一些特定的场景下非常有用，例如在实现对象继承时或创建具有特定原型链的对象。\n\n以下是一些 `Object.create` 的使用场景：\n\n1. **对象继承：**\n   ```javascript\n   var parent = {\n     // 父对象的属性和方法\n   };\n\n   var child = Object.create(parent);\n   // child 现在继承了 parent 的属性和方法\n   ```\n\n2. **原型继承：**\n   ```javascript\n   function Animal(name) {\n     this.name = name;\n   }\n\n   function Dog(breed) {\n     this.breed = breed;\n   }\n\n   // Dog 继承了 Animal 的原型\n   Dog.prototype = Object.create(Animal.prototype);\n\n   var myDog = new Dog('Bulldog');\n   ```\n\n3. **对象模板：**\n   ```javascript\n   var template = {\n     // 一些通用的属性和方法\n   };\n\n   var instance = Object.create(template);\n   // 创建新对象，共享 template 的属性和方法\n   ```\n\n4. **属性复制：**\n   ```javascript\n   var source = {\n     prop1: 'value1',\n     prop2: 'value2'\n   };\n\n   var target = Object.create(null);\n\n   // 将 source 的属性复制到 target\n   for (var key in source) {\n     if (source.hasOwnProperty(key)) {\n       target[key] = source[key];\n     }\n   }\n   ```\n\n在这些场景下，`Object.create` 提供了一种灵活的方式来创建对象，并指定它们的原型链关系。","type":"text/markdown","created":"20240123083830833","creator":"oeyoews","modified":"20240123083911076","modifier":"oeyoews","tags":"JavaScript"},{"title":"object-to-array","created":"20230527040826423","creator":"oeyoews","modified":"20230527040843263","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"好的，将一个对象转换成数组可以使用 JavaScript 中的 Object.keys() 方法和 Array.prototype.map() 方法。具体的步骤如下：\n\n1.使用 Object.keys() 方法获取对象中所有的属性名，返回一个由这些属性名组成的数组。\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst keys = Object.keys(obj); // [\"name\", \"age\", \"gender\"]\r\n```\n\n在这个例子中，我们定义了一个对象 obj，包含了三个属性：name、age 和 gender。然后使用 Object.keys() 方法获取 obj 对象中所有的属性名，返回一个数组 [\"name\", \"age\", \"gender\"]。\n\n2.使用 Array.prototype.map() 方法遍历属性名数组，将每个属性名对应的属性值组成一个新的数组。\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst keys = Object.keys(obj); // [\"name\", \"age\", \"gender\"]\r\nconst values = keys.map(key => obj[key]); // [\"Tom\", 18, \"male\"]\r\n```\n\n在这个例子中，我们使用 Array.prototype.map() 方法遍历属性名数组 keys，将每个属性名对应的属性值组成一个新的数组 values，返回一个数组 [\"Tom\",18, \"male\"]。\n\n3.将属性名数组和属性值数组组合成一个新的数组。\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst keys = Object.keys(obj); // [\"name\", \"age\", \"gender\"]\r\nconst values = keys.map(key => obj[key]); // [\"Tom\", 18, \"male\"]\r\nconst arr = keys.map((key, index) => [key, values[index]]); // [[\"name\", \"Tom\"], [\"age\", 18], [\"gender\", \"male\"]]\r\n```\n\n在这个例子中，我们使用 Array.prototype.map() 方法将属性名数组和属性值数组组合成一个新的数组 arr，返回一个由多个包含属性名和属性值的数组组成的二维数组。\n\n需要注意的是，使用 Object.keys() 方法获取属性名数组时，返回的数组中属性名的顺序是不确定的，因此不能保证转换后的数组中属性名和属性值的顺序一致。如果需要保持顺序一致，可以使用 ES6 中的 Map 数据结构来存储对象的属性和属性值。"},{"title":"Object-values","created":"20230527092609796","creator":"oeyoews","modified":"20230527114239058","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&Object-values","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"Object.keys() 和 Object.values() 都是 JavaScript 中内置的用于对象的遍历方法，分别用于获取对象的键名数组和键值数组。\n\nObject.keys() 方法可以获取对象的所有键名，并将其以数组的形式返回。例如：\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst keys = Object.keys(obj); // [\"name\", \"age\", \"gender\"]\r\n```\n\n在这个例子中，我们定义了一个对象 obj，包含了三个属性：name、age 和 gender。然后使用 Object.keys() 方法获取 obj 对象中所有的属性名，返回一个数组 [\"name\", \"age\", \"gender\"]。\n\nObject.values() 方法可以获取对象的所有键值，并将其以数组的形式返回。例如：\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst values = Object.values(obj); // [\"Tom\", 18, \"male\"]\r\n```\n\n在这个例子中，我们定义了一个对象 obj，包含了三个属性：name、age 和 gender。然后使用 Object.values() 方法获取 obj 对象中所有的属性值，返回一个数组 [\"Tom\", 18, \"male\"]。\n\n需要注意的是，使用 Object.keys() 和 Object.values() 方法获取属性名数组和属性值数组时，返回的数组中属性名和属性值的顺序是不确定的，因此不能保证属性名和属性值的顺序一致。如果需要保持顺序一致，可以使用 ES6 中的 Map 数据结构来存储对象的属性和属性值，并使用 Map.prototype.forEach() 方法遍历 Map 对象。例如：\n\n```\r\nconst obj = { name: 'Tom', age: 18, gender: 'male' };\r\nconst map = new Map(Object.entries(obj)); // 将对象转为 Map\r\nconst arr = []; // 定义一个空数组用于存储属性名和属性值\r\nmap.forEach((value, key) => arr.push([key, value])); // 遍历 Map\r\n```\n\n在这个例子中，我们使用 Object.entries() 方法将对象 obj 转换为 Map 对象 map，然后定义一个空数组 arr，用于存储属性名和属性值。接着使用 Map.prototype.forEach() 方法遍历 Map 对象 map，获取每个属性名和属性值，并将其分别存储到数组 arr 中。\n\n使用 Map 数据结构遍历对象的优点是，可以保证属性名和属性值的顺序与对象定义时的顺序一致。"},{"title":"Ojbect-entries","created":"20230601020125145","creator":"oeyoews","modified":"20230601020201606","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"`Object.entries` is a built-in JavaScript method that returns an array of an object's own enumerable property pairs. It provides a convenient way to iterate over the properties of an object and access both the key and value of each property.\n\nThe syntax for `Object.entries` is as follows:\n\n```javascript\r\nObject.entries(obj)\r\n```\n\nHere, `obj` represents the object whose enumerable properties you want to retrieve. When called, `Object.entries` returns an array where each element is an array containing a key-value pair from the object. The order of the key-value pairs in the resulting array is the same as the order in which they are returned by a `for...in` loop (although the `for...in` loop does not guarantee the order).\n\nHere's an example to illustrate its usage:\n\n```javascript\r\nconst person = {\r\n  name: 'John',\r\n  age: 30,\r\n  city: 'New York'\r\n};\n\nconst entries = Object.entries(person);\n\nconsole.log(entries);\r\n```\n\nOutput:\n\n```javascript\r\n[\r\n  [\"name\", \"John\"],\r\n  [\"age\", 30],\r\n  [\"city\", \"New York\"]\r\n]\r\n```\n\nIn the example above, `Object.entries` returns an array where each element is an array containing a key-value pair from the `person` object. The resulting array can be iterated over using array iteration methods such as `forEach`, `map`, or a `for...of` loop.\n\nNote that `Object.entries` only retrieves the object's own enumerable properties, not inherited properties or properties with non-enumerable flags set. If you need to include inherited properties, you can use `Object.getOwnPropertyNames(obj)` in combination with `Object.entries` or utilize `for...in` loop."},{"title":"oncefunction","text":"```js\nconst once = (fn) => {\n  let executed = false;\n  return (...args) => {\n    if (!executed) {\n      executed = true;\n      fn(...args);\n    }\n  };\n};\n```","type":"text/markdown","created":"20231217044923828","creator":"oeyoews","modified":"20231217044945014","modifier":"oeyoews","tags":"JavaScript"},{"title":"option-chain","created":"20230527112645074","creator":"oeyoews","modified":"20230527113329534","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"可选链是 JavaScript 中一个有用的语法功能。\n\n它允许读取现有对象的嵌套属性,即使该属性链中的 intermediary 属性不存在或 undefined 也没有问题。\n\n简单来说,如果你想读取:\n\n```js\r\nobj.foo.bar\r\n```\n\n但 `obj.foo` 可能是 undefined,可选链可以让你安全地这样写:\n\n```js\r\nobj.foo?.bar\r\n```\n\n如果 `obj.foo` 存在,则获取 `obj.foo.bar`,否则返回 undefined。\n\n这可以避免写大量的 nullish 合并操作:\n\n```js\r\nlet bar = (obj.foo && obj.foo.bar) || 'default';\r\n```\n\n可以简化为:\n\n```js\r\nlet bar = obj.foo?.bar || 'default';\r\n```\n\n可选链还支持方法调用:\n\n```js\r\nobj.foo?.bar();\r\n```\n\n如果 `obj.foo` 存在,则调用 `obj.foo.bar()`,否则不执行任何操作。\n\n总的来说,可选链可以让你安全地读取可能不存在的中间对象,免于频繁检查 null/undefined。"},{"title":"parentNode parentElement","text":"`parentNode` 和 `parentElement` 都是用于访问元素的父节点，但它们之间有一些微妙的区别：\n\n1. **返回类型**：\n   - `parentNode` 返回父节点，可以是任何类型的节点，包括元素节点、文档节点和文档片段节点等。\n   - `parentElement` 返回的是父元素节点，也就是说它只会返回元素节点作为父节点，如果父节点不是元素节点，则返回 null。\n\n2. **兼容性**：\n   - `parentNode` 是DOM标准中定义的，因此在所有支持DOM的浏览器中都能使用。\n   - `parentElement` 是现代浏览器的特性，它是在IE9及其以上版本和其他现代浏览器中才能使用的。在旧版本的IE中不支持。\n\n3. **语义**：\n   - `parentNode` 的命名更加通用，它强调了节点的父关系，可以用于任何类型的节点。\n   - `parentElement` 的命名更加具体，它强调了元素节点的父关系，只用于访问元素节点的父节点。\n\n因此，一般来说，如果你需要访问元素的父节点，并且只关心父节点是不是元素节点，那么你可以使用 `parentElement`。但是如果你需要处理更一般的情况，或者需要考虑兼容性，那么最好使用 `parentNode`。","type":"text/markdown","created":"20240131100613402","creator":"oeyoews","modified":"20240131100636241","modifier":"oeyoews","tags":"JavaScript"},{"title":"parseInt","created":"20230603052723856","creator":"oeyoews","modified":"20230603052751508","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"`parseInt` 是 JavaScript 中一个常用的函数，用于将字符串解析成整数。它的使用场景包括：\n\n1. 将用户输入的字符串转换为整数，例如从表单中获取用户输入的年龄、数量等数据；\r\n2. 将字符串中的数字部分提取出来，例如从 URL 中获取页码、从文本中提取序号等；\r\n3. 将字符串中以特定进制表示的数字转换为十进制整数，例如将十六进制颜色代码转换为 RGB 值；\r\n4. 将字符串中的非数字部分去除，仅保留数字部分；\r\n5. 将字符串转换为数字后进行数值运算，例如将字符串型的金额与数字型的数量相乘。\n\n需要注意的是，`parseInt` 函数在解析字符串时，会忽略开头的空格，直到遇到第一个非空格字符为止。如果字符串无法解析为整数，则返回 `NaN`。此外，还可以通过传入第二个参数指定解析时的进制，如 `parseInt(\"10\", 2)` 表示将二进制的字符串 `\"10\"` 转换为十进制整数 `2`。"},{"title":"parseInt-Number","text":"`parseInt` 和 `Number` 是 JavaScript 中用于将字符串转换为数字的两个不同方法，它们之间有一些重要的区别：\r\n\r\n1. **parseInt**:\r\n   - `parseInt` 是一个函数，用于将字符串解析为整数。\r\n   - 可以传递第二个参数 `radix`，指定解析时使用的进制（基数），通常使用 10（十进制）。\r\n   - `parseInt` 会从字符串的开头开始解析，直到遇到无法解析为数字的字符为止，然后返回解析的部分。\r\n   - 如果字符串以非数字字符开头，`parseInt` 会返回 `NaN`（Not-a-Number）。\r\n   - `parseInt` 可以用于解析带有正负号的整数，例如 `\"123\"`、`\"-456\"`。\r\n   - `parseInt` 不适用于解析浮点数。\r\n\r\n   例如：\r\n   ```javascript\r\n   parseInt(\"123\"); // 返回 123\r\n   parseInt(\"3.14\"); // 返回 3\r\n   parseInt(\"abc123\"); // 返回 NaN\r\n   parseInt(\"123abc\"); // 返回 123\r\n   ```\r\n\r\n2. **Number**:\r\n   - `Number` 是一个构造函数，用于将值转换为数字。\r\n   - 当传递一个字符串给 `Number` 时，它会尝试将整个字符串转换为一个数字。\r\n   - 如果字符串包含非数字字符（除了可能的正负号和小数点），`Number` 会返回 `NaN`。\r\n   - `Number` 也可以用于将其他类型的值转换为数字，例如布尔值、`null`、`undefined` 等，它会根据规则将它们转换为相应的数字值。\r\n\r\n   例如：\r\n   ```javascript\r\n   Number(\"123\"); // 返回 123\r\n   Number(\"3.14\"); // 返回 3.14\r\n   Number(\"abc123\"); // 返回 NaN\r\n   Number(\"123abc\"); // 返回 NaN\r\n   ```\r\n\r\n总结：\r\n- 如果你需要将字符串解析为整数，并且需要对解析的进制进行控制，可以使用 `parseInt`。\r\n- 如果你需要将字符串解析为数字（可以是整数或浮点数），可以使用 `Number`。\r\n- 无论哪种方法，都需要注意字符串中的非数字字符可能导致结果为 `NaN`。","type":"text/markdown","created":"20230924061533014","creator":"oeyoews","modified":"20230924061545760","modifier":"oeyoews","tags":"JavaScript"},{"title":"path-basename-ext","text":"`parse` 是一个常用的编程术语，代表解析（parsing）的意思。在计算机科学中，解析是从给定输入数据中提取有意义信息的过程。具体来说，在编程中，解析通常用于将复杂的数据结构或格式转换为更易于处理和理解的形式。\n\n在 Node.js 的 `path` 模块中，`parse` 是该模块提供的一个方法，用于解析文件路径。它接收一个文件路径作为参数，并返回一个解析后的对象，该对象包含了文件路径的各个部分的信息，如目录、根路径、文件名、扩展名等。\n\n以下是一个示例代码：\n\n```javascript\nconst path = require(\"path\");\nconst file = \"/home/user/docs/file.txt\";\n\nconst fileInfo = path.parse(file);\nconsole.log(fileInfo);\n```\n\n上述代码中，我们使用 `path.parse()` 方法将文件路径 `/home/user/docs/file.txt` 解析为一个对象 `fileInfo`。然后，我们通过输出 `fileInfo` 可以看到解析后的结果，其中包含了目录信息、根路径、文件名、扩展名等。\n\n对于给定的文件路径 `/home/user/docs/file.txt`，`fileInfo` 对象的属性如下：\n- `root`: 文件的根路径，对于 Unix 系统来说就是 `/`。\n- `dir`: 文件所在的目录路径，即 `/home/user/docs`。\n- `base`: 文件名和扩展名，即 `file.txt`。\n- `name`: 文件名（不包括扩展名），即 `file`。\n- `ext`: 文件扩展名，即 `.txt`。\n\n通过 `parse` 方法的使用，我们可以方便地从文件路径中提取出各个部分的信息，进而进行后续处理或操作。\n\n使用 Node.js 的 path.basename() 方法来提取文件的基本名称（不包括目录路径）是非常常见和方便的。但是，当文件名包含一个或多个句点（.）时，它就会返回带有扩展名的文件名称。这是因为在这种情况下，Node.js 会将最后一个句点和之后的文本视为文件扩展名。\n\n例如，如果你有一个文件名为 \"example.file.txt\" 的文件，当你使用 path.basename() 方法来提取它的基本名称时，它将返回 \"example.file.txt\" 而不是预期的 \"example.file\"。\n\n如果你需要去掉扩展名，可以使用 path.parse() 方法来分解文件路径并获取文件名和扩展名，然后再使用 string.slice() 或其他字符串操作方法来删除扩展名。例如：\n\n```javascript\nconst path = require('path');\nconst filename = 'example.file.txt';\nconst parsed = path.parse(filename);\nconst basenameWithoutExt = parsed.name; // \"example.file\"\n```","type":"text/markdown","created":"20231031134012060","creator":"oeyoews","modified":"20231031134046366","modifier":"oeyoews","tags":"JavaScript"},{"title":"path.resolve-join","text":"`path.join` 方法和 `path.resolve` 方法都可以用于拼接路径，但它们在处理路径的方式上有一些不同：\r\n\r\n1. `path.join`: \r\n\r\n   - 接受多个参数并将它们连接起来形成一个路径。\r\n   - 将会根据平台的特定规则来拼接路径，确保生成的路径是合法的。\r\n   - 不会解析 `..`（上级目录）和 `.`（当前目录）这样的相对路径符号。\r\n\r\n2. `path.resolve`:\r\n\r\n   - 接受一个或多个参数，并将它们视为目录或文件路径，从右到左解析它们并生成一个绝对路径。\r\n   - 解析过程中会考虑当前工作目录，并根据绝对路径规则生成最终的路径。\r\n   - 能够解析 `..`（上级目录）和 `.`（当前目录）等相对路径符号。\r\n\r\n下面是两者的使用示例：\r\n\r\n```javascript\r\nconst path = require('path');\r\n\r\n// 使用 path.join\r\nconst joinedPath = path.join('/home', 'user', 'documents', 'file.txt');\r\nconsole.log(joinedPath); // 输出：/home/user/documents/file.txt\r\n\r\n// 使用 path.resolve\r\nconst resolvedPath = path.resolve('/home', 'user', '..', 'documents', 'file.txt');\r\nconsole.log(resolvedPath); // 输出：/home/documents/file.txt\r\n```\r\n\r\n总结来说，如果你只是简单地需要将多个路径片段连接起来形成一个路径，可以使用 `path.join`。而如果你需要解析相对路径，并返回一个绝对路径，或者需要考虑当前工作目录，可以使用 `path.resolve`。","type":"text/markdown","created":"20230913054642936","creator":"oeyoews","modified":"20230924030837759","modifier":"oeyoews","tags":"JavaScript"},{"title":"picture-in-picture","text":"> https://developer.chrome.com/docs/web-platform/document-picture-in-picture/#acknowledgements\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <script src=\"https://cdn.tailwindcss.com\"></script>\r\n    <title>画中画示例</title>\r\n  </head>\r\n  <body class=\"m-2\">\r\n    <video\r\n      id=\"videoElement\"\r\n      controls\r\n      class=\"aspect-video rounded h-full w-full\"\r\n    >\r\n      <source\r\n        src=\"https://mdn.github.io/dom-examples/picture-in-picture/assets/bigbuckbunny.mp4\"\r\n        type=\"video/mp4\"\r\n      />\r\n    </video>\r\n\r\n    <button id=\"startButton\">画中画</button>\r\n\r\n    <script>\r\n      const videoElement = document.getElementById(\"videoElement\");\r\n      const startButton = document.getElementById(\"startButton\");\r\n\r\n      startButton.addEventListener(\"click\", togglePictureInPicture);\r\n\r\n      function togglePictureInPicture() {\r\n        if (document.pictureInPictureElement) {\r\n          document.exitPictureInPicture();\r\n        } else {\r\n          if (document.pictureInPictureEnabled) {\r\n            videoElement.requestPictureInPicture();\r\n          }\r\n        }\r\n      }\r\n    </script>\r\n  </body>\r\n</html>","type":"text/markdown","created":"20230925090732195","creator":"oeyoews","modified":"20230929145034501","modifier":"oeyoews","tags":"JavaScript"},{"title":"pjax","created":"20230517155225377","creator":"oeyoews","modified":"20230517155247622","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"PJAX（Partial JavaScript and XML）是一种在 Web 应用程序中实现局部页面刷新的技术，它利用 Ajax、HTML5 的 history API 和浏览器的 pushState 方法来实现无需重新加载整个页面而更新部分页面内容的效果。\n\n与传统的网页跳转方式不同，PJAX 可以通过异步请求方式获取数据，然后使用 JavaScript 将新的数据渲染到当前页面中的指定区域。这样可以提高页面加载速度、减少服务器的负载，并且可以获得更好的用户体验。\n\n以下是一个使用 PJAX 实现无刷新页面加载的示例代码：\n\n```javascript\r\n// 监听链接点击事件\r\ndocument.addEventListener('click', function(event) {\r\n  // 如果被点击的元素是链接\r\n  if (event.target.tagName === 'A') {\r\n    event.preventDefault(); // 阻止默认链接行为\n\n    // 使用 AJAX 加载新页面 HTML\r\n    fetch(event.target.href, { headers: { 'X-PJAX': true } })\r\n      .then(response => response.text())\r\n      .then(html => {\r\n        // 创建一个新的虚拟 DOM 对象\r\n        const tmp = document.createElement('div');\r\n        tmp.innerHTML = html;\n\n        // 获取需要更新的页面内容\r\n        const content = tmp.querySelector('#content');\n\n        // 更新页面内容\r\n        document.querySelector('#content').innerHTML = content.innerHTML;\n\n        // 更新浏览器历史记录\r\n        history.pushState({}, null, event.target.href);\r\n      });\r\n  }\r\n});\n\n// 监听 popstate 事件（比如点击浏览器的前进或后退按钮）\r\nwindow.addEventListener('popstate', function(event) {\r\n  // 使用 AJAX 加载当前页面 HTML\r\n  fetch(location.href, { headers: { 'X-PJAX': true } })\r\n    .then(response => response.text())\r\n    .then(html => {\r\n      // 创建一个新的虚拟 DOM 对象\r\n      const tmp = document.createElement('div');\r\n      tmp.innerHTML = html;\n\n      // 获取需要更新的页面内容\r\n      const content = tmp.querySelector('#content');\n\n      // 更新页面内容\r\n      document.querySelector('#content').innerHTML = content.innerHTML;\r\n    });\r\n});\r\n```\n\n在上面的示例中，我们使用 `fetch()` 函数来通过 PJAX 进行异步数据请求并处理响应。在点击链接时，我们通过 `fetch()` 函数异步地加载新的页面 HTML，并将其渲染到当前页面中指定的区域中。然后，我们使用浏览器的 pushState 方法将新的 URL 添加到浏览器历史记录中。在浏览器前进或后退时，我们可以通过监听 popstate 事件来异步加载当前页面的 HTML 内容，并将其渲染到当前页面中指定的区域中。\n\n需要注意的是，PJAX 技术仅适用于一部分 Web 应用程序场景，例如简单的静态网站、博客等，对于复杂的动态应用程序（例如社交网络、电子商务网站等），PJAX 可能无法满足需求。此外，在实际开发中，您还需要考虑 PJAX 在 SEO、浏览器兼容性等方面的问题。"},{"title":"pnpm-install-force","text":"```shell\npnpm store status\npnpm install --force xxx\n```\n\n如果你更改了某个包， 但是希望撤回 ","type":"text/markdown","created":"20240131131533494","creator":"oeyoews","modified":"20240131131629491","modifier":"oeyoews","tags":"JavaScript"},{"title":"process.argv","text":"```js\r\n// node main.js 1 2 3\r\nconst argv = process.argv.slice(2);\r\nconsole.log([...argv]);\r\n```","type":"text/markdown","created":"20230924021531935","creator":"oeyoews","modified":"20230924021555237","modifier":"oeyoews","tags":"JavaScript"},{"title":"promise","text":":::abstract\nPromise 是一个构造函数， 所以使用的时候需要使用new 关键字。 当然Promise 也有一些静态方法， 比如Promise.all Promise.then\n:::\n\nPromise是一种用于异步编程的对象，可以将异步任务封装成一个Promise对象，并在异步任务完成后返回相应的结果或抛出错误。\n\n## Promise对象有三种状态\n\n1. Pending\n2. Fulfilled\n3. Rejected\n\n```mermaid neutral\ngraph TB;\nsubgraph promise mermaid graph\ndirection TB\nsubgraph 状态\n  A[Pending] -->|resolve| B(fulfilled)\n  A -->|reject| C(rejected)\nend\n\nsubgraph 实例方法\n  D(Promise 实例方法) --> then & catch & finally\nend\nsubgraph 静态方法\n  E(静态方法) --> Promise.all\n  E ==> Promise.any & allSettled & race & reject & resolve\nend\nend\n```\n\n## Promise.all\n\n* 只有当所有的任务都成功后， 才执行成功\n\n## Promise.allSettled\n\n* 只要所有的任务有结果就可以,无论成功还是失败。\n\n## Promise.any\n\n* 只要有一个成功就可以\n\n## Promise.race\n\n* 只要有一个结果就行， 无论成功还是失败。\n\n## Promise.reject\n\n* 返回一个状态为reject的Promise 对象\n\n当异步任务完成后，Promise对象会由Pending转换为Fulfilled或Rejected状态。\n\nPromise对象通常包含两个方法：then和catch。then方法接受两个回调函数作为参数，分别表示异步任务成功和失败后的处理方式。catch方法用来捕获异步任务发生的错误，并进行相应的处理。\n\n以下是一个Promise对象的基本使用示例：\n\n```javascript\nfunction asyncTask() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const randomNumber = Math.random();\n      if (randomNumber > 0.5) {\n        resolve(randomNumber);\n      } else {\n        reject(new Error(\"Random number is too small\"));\n      }\n    }, 1000);\n  });\n}\n\nasyncTask()\n  .then(result => {\n    console.log(`Async task successful, result: ${result}`);\n  })\n  .catch(error => {\n    console.error(`Async task failed, error: ${error}`);\n  });\n```\n\n在以上示例中，我们创建了一个名为asyncTask的异步任务，并将它封装成了一个Promise对象。在这个任务中，我们使用setTimeout模拟了一个耗时1秒的异步操作，并随机生成了一个数值，当数值大于0.5时，任务会成功完成并返回随机数值，否则任务会失败并抛出一个Error对象。\n\n我们通过调用asyncTask方法来执行这个异步任务，并使用then和catch方法处理异步操作成功和失败的情况。当异步任务成功完成后，then方法会被调用，并接受异步操作返回的结果作为参数。当异步任务失败时，catch方法会被调用，并接受异步操作抛出的错误对象作为参数。\n\nPromise对象可以方便地处理异步操作，避免了回调函数嵌套和代码复杂度增加的问题，因此在JavaScript中得到了广泛的应用。","type":"text/markdown","created":"20230503024427738","creator":"oeyoews","modified":"20240128132215297","modifier":"oeyoews","tags":"JavaScript"},{"title":"prototype","created":"20230521035830056","creator":"oeyoews","modified":"20230605130135306","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"JavaScript中的每一个对象都有一个内部属性[[Prototype]]，也称为原型。如果我们需要访问一个对象的属性或方法，但该对象本身没有定义这个属性或方法，那么JavaScript引擎就会沿着该对象的原型链向上查找，直到找到该属性或方法为止。\n\nJavaScript中的原型可以通过以下方式来处理：\n\n1. 构造函数（Constructor）：构造函数是一种特殊的函数，用于创建新的对象。在使用构造函数创建对象时，该对象会自动继承构造函数的原型。\n\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\n```\n\n2. 原型对象（Prototype Object）：每个函数都有一个prototype属性，该属性指向函数的原型对象。该原型对象包含了该函数的所有公共属性和方法。\n\n```js\r\nPerson.prototype.greet = function() {\r\n  console.log(`Hi, my name is ${this.name} and I'm ${this.age} years old.`);\r\n};\r\n```\n\n3. 实例化对象（Instance Object）：通过new关键字调用构造函数来实例化一个新对象，该对象会自动继承构造函数的原型对象。\n\n```js\r\nconst person = new Person('John Doe', 30);\r\nperson.greet(); // Hi, my name is John Doe and I'm 30 years old.\r\n```\n\n4. 原型链（Prototype Chain）：每个对象都有一个内部属性[[Prototype]]，该属性指向该对象的原型。如果一个对象的属性或方法没有被找到，JavaScript引擎会沿着该对象的原型链向上查找，直到找到该属性或方法为止。\n\n```js\r\nconsole.log(person.__proto__ === Person.prototype); // true\r\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\r\nconsole.log(Object.prototype.__proto__ === null); // true\r\n```\n\n在JavaScript中，原型和原型链是非常重要的概念。理解它们可以帮助我们更好地理解JavaScript中的面向对象编程方式，并进一步提高我们的JavaScript编程能力。\n\n```js\r\nfunction Role() {}\n\nconst role1 = new Role();\n\nconsole.log(role1.__proto__ === Role.prototype); // true\r\n```"},{"title":"querySelector","text":"`querySelector` 和 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 这类方法都是用来查找 HTML 元素的 DOM 方法，二者的主要区别在于：\r\n\r\n1. `querySelector` 返回文档中匹配指定 CSS 选择器的第一个元素，而 `getElementById` 直接返回指定 ID 的元素（ID 必须唯一）。\r\n2. `querySelector` 返回的是一个 Element 对象，而 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 返回的是一个 HTMLCollection 或 NodeList 对象，需要通过索引访问对应元素。\r\n3. `querySelector` 可以使用更为灵活的 CSS 选择器语法进行查询，而 `getElementById`、`getElementsByClassName`、 `getElementsByTagName` 只能传入单个标签名、类名或 ID 等字符串参数。\r\n\r\n举个例子，如果我们要获取文档中 ID 为 `myDiv` 的 div 元素，可以使用以下两种方式：\r\n\r\n```js\r\nvar myDiv1 = document.querySelector('#myDiv');\r\nvar myDiv2 = document.getElementById('myDiv');\r\n```\r\n\r\n其中，`querySelector` 使用 CSS 选择器 `#myDiv` 来匹配 ID 为 `myDiv` 的元素，并返回第一个匹配的元素；而 `getElementById` 直接根据 ID 字符串 `myDiv` 返回对应的元素。","type":"text/markdown","created":"20230603044222457","creator":"oeyoews","modified":"20230726045248756","modifier":"oeyoews","tags":"JavaScript"},{"title":"readFile","created":"20230529120034491","creator":"oeyoews","modified":"20230529120050335","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在Node.js中，可以使用fs模块读取文件。fs模块提供了多种读取文件的方法，包括同步和异步方法。\n\n下面是使用fs模块异步读取JSON文件的示例：\n\n```javascript\r\nconst fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", function(err, data) {\r\n  if (err) throw err;\r\n  console.log(data);\r\n});\r\n```\n\n在这个例子中，我们首先使用require()方法引入fs模块。然后，我们使用fs.readFile()方法异步读取JSON文件，该方法接受三个参数：文件路径、文件编码方式和回调函数。当文件读取完成后，回调函数将被调用，并将读取的文件内容作为第二个参数传递给回调函数，我们可以在回调函数中处理文件内容。\n\n需要注意的是，异步读取文件时，Node.js会将文件读取请求放入事件循环中，并继续执行后续代码。当文件读取完成后，Node.js会调用回调函数来处理文件内容，因此在使用异步方法时，需要在回调函数中处理文件内容。\n\n如果需要同步读取文件，可以使用fs.readFileSync()方法，该方法会阻塞代码执行，直到文件读取完成。例如：\n\n```javascript\r\nconst fs = require(\"fs\");\n\ntry {\r\n  const data = fs.readFileSync(\"data.json\", \"utf8\");\r\n  console.log(data);\r\n} catch (err) {\r\n  console.error(err);\r\n}\r\n```\n\n在这个例子中，我们使用try-catch语句块来处理可能的异常情况。在try块中，我们使用fs.readFileSync()方法同步读取JSON文件，并将文件内容存储在data变量中。如果读取文件时出现错误，catch块将捕获该错误，并输出错误信息。\n\n以上是使用fs模块读取文件的示例，需要注意的是，在使用fs模块读取文件时，我们需要处理可能的异常情况，并根据实际情况选择异步或同步方法。"},{"title":"reduce","text":"```js\nconst arr = [1, 22, 3];\nconsole.log(arr.reduce((a, b) => a + b));\n```\n\n对一个数组进行求和，可以使用 JavaScript 的 `reduce()` 方法。该方法接受一个回调函数作为参数，该回调函数接受累加器和当前值作为参数，然后返回新的累加器值。\n\n下面是一个将数组中所有元素相加的示例代码：\n\n```javascript\nconst arr = [1, 2, 3, 4, 5];\n\nconst sum = arr.reduce((accumulator, currentValue) => {\n  return accumulator + currentValue;\n}, 0);\n\nconsole.log(sum); // 输出 15\n```\n\n在这个例子中，我们先定义了一个数组 `arr`，它包含了一些数字。然后，我们使用 `reduce()` 方法来计算这些数字之和。我们将初始值设置为 0，并且将每个元素加到累加器上。最后，我们将计算得出的总和输出到控制台。\n\n你也可以将 `reduce()` 函数写成更简洁的形式：\n\n```javascript\nconst arr = [1, 2, 3, 4, 5];\n\nconst sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n\nconsole.log(sum); // 输出 15\n```\n\n在这个例子中，我们省略了 `return` 语句，并将箭头函数缩写为一行。\n\n无论是哪种写法，`reduce()` 方法都是一个非常有用的数组方法，可以用于计算任何类型的累加器值，例如求和、求平均值等。\n\n`reduce()` 是 JavaScript 数组的一个高阶函数，用于对数组中的每个元素进行累积操作，最终返回一个单一的结果。\n\n`reduce()` 方法的语法如下：\n\n```javascript\narray.reduce(callback, initialValue)\n```\n\n参数解释：\n- `callback`：一个回调函数，用于对数组中的每个元素执行操作。它可以接收四个参数：\n  - `accumulator`：累积器，保存回调函数的返回值，也就是上一次回调的结果。\n  - `currentValue`：当前元素的值。\n  - `currentIndex`：当前元素的索引（可选）。\n  - `array`：原始数组（可选）。\n  回调函数必须返回一个值，该值将在下一次回调时作为累积器的值。\n\n- `initialValue`（可选）：作为初始累积器的值。如果没有提供初始值，则使用数组的第一个元素作为初始值，并从第二个元素开始迭代。\n\n使用 `reduce()` 方法时，它会按顺序遍历数组的每个元素，并将每个元素传递给回调函数进行处理，将处理结果作为下一次回调的输入，直到处理完所有元素并得到最终的累积结果。\n\n下面是一个使用 `reduce()` 方法计算数组元素之和的简单示例：\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((accumulator, currentValue) => {\n  return accumulator + currentValue;\n}, 0);\n\nconsole.log(sum); // 输出 15\n```\n\n在上面的示例中，初始累积器的值设置为 0。在每次回调中，回调函数将累积器与当前元素相加，并返回结果作为下一次回调的累积器。最终得到数组元素之和 15。\n\n`reduce()` 方法还有其他用法，例如可以在回调函数中进行过滤、映射或其他复杂的操作来实现更多功能。它是一个非常强大和灵活的数组方法，在处理数组数据时非常有用。\n\nreduce是JavaScript的一个数组方法，用于将数组中的元素归纳为一个单独的值。reduce方法接收一个回调函数作为参数，该回调函数接收两个参数：累加器和当前元素。在每次迭代时，回调函数都会将当前元素与累加器作为参数，并返回一个新的累加器。最终，reduce方法会返回最后一次迭代后的累加器的值。下面是一个使用reduce方法的示例：\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((accumulator, current) => accumulator + current, 0);\n\nconsole.log(sum); // 输出：15\n```\n\n在这个示例中，我们定义了一个numbers数组，包含了一些数字。然后，我们调用了该数组的reduce方法，并传入一个回调函数作为参数。回调函数接收两个参数，accumulator表示累加器的值，current表示当前元素的值。我们在回调函数中将accumulator和current相加，并返回新的累加器的值。在调用reduce方法时，我们传入了一个初始值0作为累加器的初始值。这样，reduce方法会从数组的第一个元素开始迭代，将该元素和累加器的初始值0作为参数传递给回调函数，并返回新的累加器的值1；然后，将第二个元素2和上一次迭代的结果1作为参数传递给回调函数，并返回新的累加器的值3；接着，将第三个元素3和上一次迭代的结果3作为参数传递给回调函数，并返回新的累加器的值6；以此类推，直到迭代到最后一个元素5，返回最终的累加器的值15。最终，我们输出了累加器的值15，表示数组中所有元素的和。","type":"text/markdown","created":"20230528110216050","creator":"oeyoews","modified":"20240117135814138","modifier":"oeyoews","tags":"JavaScript"},{"title":"reduce-filter-map","text":"使用 `filter()` 和 `map()` 方法时会遍历数组两次，而使用 `reduce()` 方法可以在只遍历一次数组的情况下实现相同的效果，从而更高效。\n\n`reduce()` 方法是数组的一个高阶函数，在每次迭代过程中将数组元素归约为单个值。它接受一个回调函数作为参数，并且可以传递一个初始值作为累加器的起始值。\n\n下面是一个使用 `filter()` 和 `map()` 方法的示例代码：\n\n```python\n# 使用 filter() 和 map() 遍历数组两次\narray = [1, 2, 3, 4, 5]\n\nfiltered_array = filter(lambda x: x % 2 == 0, array)\nmapped_array = map(lambda x: x * 2, filtered_array)\n\nresult = list(mapped_array)\nprint(result)  # 输出 [4, 8]\n\n```\n\n而下面是使用 `reduce()` 方法实现相同效果的示例代码：\n\n```python\n# 使用 reduce() 遍历数组一次\nfrom functools import reduce\n\narray = [1, 2, 3, 4, 5]\n\nresult = reduce(lambda acc, x: acc + [x * 2] if x % 2 == 0 else acc, array, [])\n\nprint(result)  # 输出 [4, 8]\n```\n\n在上述代码中，`reduce()` 方法的回调函数接受两个参数：`acc`（累加器）和 `x`（当前迭代的数组元素）。在每次迭代过程中，如果当前元素 `x` 满足条件（偶数），则将其乘以 2 并添加到累加器 `acc` 中；否则，直接返回累加器 `acc`。最终的结果是一个包含满足条件的元素的列表。\n\n因此，使用 `reduce()` 方法可以在只遍历一次数组的情况下完成过滤和映射的操作，提高了效率。\n\n不需要一直使用 `reduce()` 方法代替 `filter()`。实际上，根据具体的需求和代码可读性，选择使用适当的方法是更为重要的。\n\n`reduce()` 方法在某些情况下可以替代 `filter()` 和 `map()` 方法，但并不意味着它必须一直代替它们。以下是一些考虑因素：\n\n1. 可读性：使用 `filter()` 和 `map()` 方法可以更直观地表达你的意图。这些方法是广为人知的函数式编程范式，可以使代码更易于理解和维护。相比之下，使用 `reduce()` 方法可能需要更多的解释和理解成本。\n\n2. 代码简洁性： `filter()` 和 `map()` 方法通常可以更简洁地实现过滤和映射的操作，而 `reduce()` 方法可能需要更多的代码来处理边界条件和累加器的初始值。\n\n3. 性能：虽然 `reduce()` 方法只遍历一次数组，但在某些情况下，使用 `filter()` 和 `map()` 方法可能会更高效。因为这些方法具有优化的实现，并且在底层使用了高度优化的算法。\n\n因此，在选择使用 `filter()`、`map()` 或 `reduce()` 方法时，建议综合考虑以上因素，并根据具体的情况做出决策。在大多数情况下，使用 `filter()` 和 `map()` 方法会更为常见和推荐。只有在一些特定的场景下，才会选择使用 `reduce()` 方法来提高效率。","type":"text/markdown","created":"20231103080948734","creator":"oeyoews","modified":"20231103081025359","modifier":"oeyoews","tags":"JavaScript"},{"title":"reflow-repaint","text":"```mermaid\ngraph TD\n    A[页面渲染] --> B[布局计算]\n    A --> C[绘制元素]\n    B --> D[回流 reflow]\n    C --> E[重绘 repaint]\n```\n\n## Reflow\n\n指当页面中的元素位置、大小或内容发生变化时，浏览器需要重新计算元素的几何属性（如位置、大小等），然后将元素放置到正确的位置。重排通常是比较耗时的操作，因为它需要重新计算元素的布局和位置信息，所以我们应该尽量避免频繁的重排。\n\n## Repaint\n\n重绘（Repaint）是指当页面中的元素的外观发生变化时，浏览器需要重新绘制元素的外观。例如，当我们修改了一个元素的背景颜色时，浏览器需要重新绘制这个元素的背景颜色。与重排不同，重绘的代价比较小，因为它只需要重新绘制元素的外观，而不需要重新计算元素的几何属性。\n\n总的来说，重排和重绘都是浏览器渲染页面时的一些操作，但它们的开销不同。重排比重绘的代价更高，因为它需要重新计算元素的布局和位置信息。因此，我们应该尽量避免频繁的重排操作，以提高页面的性能和响应速度。\n\n## Example\n举个例子，当我们使用JavaScript动态修改一个元素的样式时，这可能会导致重排和重绘。如果我们需要多次修改这个元素的样式，那么最好将修改集中在一起，以避免多次重排和重绘操作。另外，我们可以使用CSS来实现一些动画效果，而不是使用JavaScript动态修改样式，这样可以避免频繁的重排和重绘，提高页面的性能和响应速度。","type":"text/markdown","created":"20230531120251936","creator":"oeyoews","modified":"20240130074507986","modifier":"oeyoews","tags":"JavaScript"},{"title":"remove-obj-arrt","text":"如果你想删除 JavaScript 对象的属性，但又不想改变原始对象，则可以使用 `Object.assign()` 或扩展运算符（`...`）等方法来创建新对象并复制原始对象的所有属性，然后再从新对象中删除属性。以下是一个示例：\n\n```javascript\nconst originalObj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\n// 使用 Object.assign() 复制对象并删除属性\nconst newObj = Object.assign({}, originalObj);\ndelete newObj.age;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(newObj); // 输出 { name: 'John', city: 'New York' }\n\n// 使用扩展运算符复制对象并删除属性\nconst anotherObj = { ...originalObj };\ndelete anotherObj.city;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(anotherObj); // 输出 { name: 'John', age: 30 }\n```\n\n在上面的示例中，我们首先创建了一个名为 `originalObj` 的对象，并设置了三个属性：`name`、`age` 和 `city`。然后，我们使用 `Object.assign()` 方法或扩展运算符（`...`）复制 `originalObj` 并将其存储在 `newObj` 或 `anotherObj` 中。接着，我们从 `newObj` 和 `anotherObj` 中分别删除了 `age` 和 `city` 属性。最后，我们分别打印了 `originalObj` 和 `newObj` 或 `anotherObj`，以显示删除属性后的结果。\n\n需要注意的是，这两种方法都只复制了原始对象的浅层副本。如果原始对象包含嵌套的对象或数组，则嵌套对象或数组仍然是通过引用共享的。\n\n\n使用 `filter` 方法来过滤对象属性并创建一个新的对象是不太适用的，因为 `filter` 方法是用于数组的，而不是对象。\n\n如果你想删除 JavaScript 对象的属性，但又不想改变原始对象，并且希望使用其他方法，可以考虑使用解构赋值来创建一个新对象，只包含需要保留的属性。以下是一个示例：\n\n```javascript\nconst originalObj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconst { age, ...newObj } = originalObj;\n\nconsole.log(originalObj); // 输出 { name: 'John', age: 30, city: 'New York' }\nconsole.log(newObj); // 输出 { name: 'John', city: 'New York' }\n```\n\n在上面的示例中，我们使用解构赋值语法从 `originalObj` 中提取 `age` 属性，并将其存储在变量 `age` 中。然后，我们使用剩余参数（`...`）来创建一个名为 `newObj` 的新对象，它只包含除了 `age` 以外的其他属性。最后，我们分别打印了 `originalObj` 和 `newObj`，以显示删除属性后的结果。\n\n需要注意的是，这种方法只能用于较新版本的 JavaScript（ES6+）。它通过将需要保留的属性提取到单独的变量中，并使用剩余参数来创建新对象，实现了从原始对象中删除属性的效果。","type":"text/markdown","created":"20231101020044086","creator":"oeyoews","modified":"20231101020134919","modifier":"oeyoews","tags":"JavaScript"},{"title":"removeEventListener","text":"`removeEventListener` 用于从元素中移除先前添加的事件监听器。它在以下情况下会被使用：\n\n1. 当您想要停止监听特定事件时：如果您之前使用 `addEventListener` 添加了一个事件监听器，但是后续不再需要监听该事件，可以使用 `removeEventListener` 来移除监听器。这可以防止不必要的事件处理程序执行和内存泄漏。\n\n2. 在使用匿名函数作为事件处理程序时，特别有用：当您通过匿名函数添加事件监听器时，无法直接使用 `removeEventListener` 移除监听器，因为匿名函数是无法被直接引用的。此时，您可以通过将事件处理程序保存到变量中，然后使用该变量来移除监听器。\n\n以下是使用 `removeEventListener` 的示例：\n\n```javascript\nconst element = document.getElementById(\"elementId\");  // 替换 \"elementId\" 为您要移除事件监听器的元素的 ID\n\nfunction handleClick() {\n  console.log(\"点击事件已触发\");\n}\n\n// 添加事件监听器\nelement.addEventListener(\"click\", handleClick);\n\n// 在某个条件满足时移除事件监听器\nif (shouldRemoveListener) {\n  element.removeEventListener(\"click\", handleClick);\n}\n```\n\n在上述示例中，我们首先使用 `addEventListener` 添加了一个名为 `handleClick` 的事件监听器。然后，在某个条件满足时，我们使用 `removeEventListener` 来移除该事件监听器。通过提供相同的事件类型（如 `\"click\"`）和相同的事件处理程序（如 `handleClick` 函数），我们可以确保正确地移除监听器。\n\n需要注意的是，为了成功移除事件监听器，添加和移除监听器的代码必须位于相同的作用域中。此外，请确保使用的事件类型和事件处理程序与添加监听器时的参数完全匹配。\n\n内联事件处理程序具有以下几个好处：\n\n1. 简单直观：使用内联事件处理程序可以将事件处理逻辑直接嵌入到 HTML 元素中，使代码更加简洁和易于理解。你无需在 JavaScript 代码中查找事件监听器的定义，而是直接在相关元素的属性中找到事件处理逻辑。\n\n2. 快速实现：内联事件处理程序可以快速实现基本的事件处理逻辑，特别适用于简单的交互行为。你可以直接在 HTML 元素上编写事件处理函数，无需额外的 JavaScript 代码。\n\n3. 上下文传递：使用内联事件处理程序可以方便地将当前元素的上下文信息传递给事件处理函数。通过在内联事件处理程序中使用 `this` 关键字，你可以轻松访问当前元素的属性和方法，而无需通过其他方式获取元素的引用。\n\n4. 动态生成：内联事件处理程序可以与动态生成的元素结合使用。当你通过 JavaScript 动态创建元素时，你可以直接在元素的属性中设置内联事件处理程序，无需在生成元素后再添加事件监听器。\n\n尽管内联事件处理程序具有这些好处，但它们也有一些限制和潜在的问题。例如，使用内联事件处理程序会导致 HTML 与 JavaScript 代码耦合在一起，不利于代码的维护和复用。此外，当需要在多个元素上共享相同的事件处理逻辑时，内联事件处理程序会导致代码重复。在这种情况下，使用事件监听器和事件委托等技术可能更加灵活和可扩展。\n\n在 JavaScript 中，当你销毁一个节点（例如通过 `removeChild` 方法从 DOM 中移除节点），与该节点相关的事件监听器会如何处理取决于几个因素。\n\n1. 使用 `addEventListener` 添加的事件监听器：如果你使用 `addEventListener` 方法添加了一个事件监听器，并且没有显式地移除它，那么该监听器将仍然存在于内存中，即使你移除了节点。这可能导致内存泄漏，因为该监听器仍然保留着对节点的引用，即使节点已经被移除。\n\n   解决方法：在销毁节点之前，你应该显式地使用 `removeEventListener` 方法来移除事件监听器，以确保它们不再保留对节点的引用。这样可以防止内存泄漏并释放相关资源。\n\n2. 使用内联事件处理程序（Inline Event Handlers）：如果你使用内联事件处理程序（例如 `onclick=\"...\"`）来添加事件处理逻辑，当你移除包含该处理程序的节点时，相关的事件处理逻辑也会自动被移除。这是因为内联事件处理程序是直接附加到节点上的，而不是通过事件监听器的方式。\n\n   解决方法：在销毁节点时，你无需额外处理内联事件处理程序，它们会自动被移除。\n\n总结起来，对于使用 `addEventListener` 添加的事件监听器，你需要在销毁节点之前使用 `removeEventListener` 方法显式地移除它们，以防止内存泄漏。对于使用内联事件处理程序添加的事件处理逻辑，当你移除包含该处理程序的节点时，相关的事件处理逻辑会自动被移除。","type":"text/markdown","created":"20231002164345079","creator":"oeyoews","modified":"20231028000837980","modifier":"oeyoews","tags":"JavaScript"},{"title":"replaceAll","text":"在 JavaScript 中，`replace` 和 `replaceAll` 都是用于替换字符串中指定文本的方法。它们之间的主要区别在于处理替换的方式。\n\n1. **replace:**\n   - `replace` 方法替换字符串中第一个匹配的文本。\n   - 使用方式为 `str.replace(search, replacement)`，其中 `search` 是要替换的文本或正则表达式，`replacement` 是用于替换的新文本。\n\n   示例：\n   ```javascript\n   let originalStr = \"apple orange apple banana\";\n   let newStr = originalStr.replace(\"apple\", \"grape\");\n   console.log(newStr); // 输出: \"grape orange apple banana\"\n   ```\n\n2. **replaceAll:**\n   - `replaceAll` 方法替换字符串中所有匹配的文本。\n   - 使用方式为 `str.replaceAll(search, replacement)`，其中 `search` 是要替换的文本或正则表达式，`replacement` 是用于替换的新文本。\n\n   示例：\n   ```javascript\n   let originalStr = \"apple orange apple banana\";\n   let newStr = originalStr.replaceAll(\"apple\", \"grape\");\n   console.log(newStr); // 输出: \"grape orange grape banana\"\n   ```\n\n需要注意的是，`replaceAll` 是在 ECMAScript 2021 中引入的，因此在一些较旧的 JavaScript 环境中可能不被支持。在现代环境中，推荐使用 `replaceAll` 来替换所有匹配的文本，而在需要替换第一个匹配时使用 `replace`。","type":"text/markdown","created":"20240113063310708","creator":"oeyoews","modified":"20240113063333259","modifier":"oeyoews","tags":"JavaScript"},{"title":"resolve-promise","text":"`resolve` 不是一个函数，而是 Promise 对象中的一个方法。它是 Promise 的内置方法之一，用于将一个 Promise 标记为已成功（fulfilled），并将一个值传递给与之关联的`.then`方法中的回调函数。\r\n\r\n在 JavaScript 中，Promise 对象有三种状态：待定（pending）、已成功（fulfilled）、已拒绝（rejected）。`resolve`方法用于将一个待定的 Promise 状态转变为已成功的状态，并传递一个值作为成功的结果。\r\n\r\n示例用法如下：\r\n\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  // 一些异步操作，最终成功后调用 resolve\r\n  setTimeout(() => {\r\n    resolve(\"成功的结果\");\r\n  }, 1000);\r\n});\r\n\r\nmyPromise.then((result) => {\r\n  console.log(result); // 输出：成功的结果\r\n});\r\n```\r\n\r\n在上面的示例中，`resolve`方法被调用，并将字符串\"成功的结果\"传递给了`.then`方法中的回调函数。这样，当 Promise 对象状态变为已成功时，`.then`中的回调函数就会被执行，并且可以访问到成功的结果。\r\n\r\n总之，`resolve`是 Promise 对象的方法，用于标记 Promise 为已成功状态，并传递成功的结果。","type":"text/markdown","created":"20230924062943526","creator":"oeyoews","modified":"20230924063006585","modifier":"oeyoews","tags":"JavaScript ES6"},{"title":"scrollIntoView","text":"`scrollIntoView` 是一个 JavaScript API，用于将元素滚动到可见区域。该方法被用于将页面滚动到包含指定元素的父容器中，以确保该元素在视图中可见。\n\n基本用法如下：\n\n```javascript\nelement.scrollIntoView();\n```\n\n这将使包含该元素的父容器滚动，以确保该元素出现在可见区域内。你还可以传递一个配置对象，以指定滚动行为的各种选项：\n\n```javascript\nelement.scrollIntoView({\n  behavior: 'smooth', // 平滑滚动\n  block: 'start',      // 开始位置\n  inline: 'nearest'    // 最靠近视口的位置\n});\n```","type":"text/markdown","created":"20240122090610947","creator":"oeyoews","modified":"20240122090629813","modifier":"oeyoews","tags":"JavaScript"},{"title":"self-this","created":"20230526050658400","creator":"oeyoews","modified":"20230527114256864","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&self-this","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在JavaScript中，回调函数在被调用时可能会失去其原始的`this`引用。这是因为JavaScript中的函数是基于调用的，而不是基于定义的。当一个函数作为一个回调函数传递给另一个函数时，该函数的`this`引用可能会指向全局对象（在非严格模式下）或undefined（在严格模式下），而不是原始的对象或类实例。\n\n例如，在以下代码中，`setTimeout`函数的回调函数中的`this`引用指向的是全局对象（在非严格模式下）。\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    setTimeout(function() {\r\n      console.log(this.name); // 输出undefined或全局对象的name属性\r\n    }, 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，`setTimeout`函数的回调函数中的`this`引用指向的是全局对象，而不是`Person`对象。因此，当我们尝试访问`this.name`属性时，会返回undefined或全局对象的name属性值。\n\n为了解决这个问题，我们可以使用一些技巧来保留原始的`this`引用，并在回调函数内部使用它，例如使用`bind()`方法、箭头函数或保存`this`引用到变量中。\n\n- 使用`bind()`方法显式绑定`this`引用：\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    setTimeout(function() {\r\n      console.log(this.name); // 输出John\r\n    }.bind(this), 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，我们使用`bind()`方法将回调函数中的`this`引用绑定到`Person`对象上，从而保留原始的`this`引用。\n\n- 使用箭头函数继承父级作用域的`this`引用：\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    setTimeout(() => {\r\n      console.log(this.name); // 输出John\r\n    }, 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，我们使用箭头函数来定义回调函数，箭头函数会继承父级作用域的`this`引用。因此，在回调函数中，`this`引用指向`Person`对象，从而可以访问`name`属性。\n\n- 保存`this`引用到变量中：\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    let self = this; // 保存当前对象的引用到self变量\r\n    setTimeout(function() {\r\n      console.log(self.name); // 输出John\r\n    }, 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，我们将当前对象的引用保存到`self`变量中，并在回调函数中使用`self`变量来访问`name`属性。这种方式可以避免在回调函数中直接使用`this`引用，从而避免`this`引用丢失的问题。\n\n总之，在JavaScript中，回调函数不能直接使用`this`引用，因为它可能会失去原始的引用。因此，我们需要使用一些技巧来保留原始的`this`引用，并在回调函数内部使用它，例如使用`bind()`方法、箭头函数或保存`this`引用到变量中。\n\n在JavaScript中，通常使用`self`或`that`变量来保存当前函数的`this`引用，以便在函数作用域内访问它。这种技术通常用于回调函数或嵌套函数中，这些函数的this引用可能会丢失或引用错误的对象。\n\n在例子中，`self = this`行的意思是将当前对象的引用赋值给一个名为`self`的变量。通过这种方式，我们可以在函数作用域内使用`self`变量来访问当前对象的属性和方法，而不用担心`this`引用的问题。\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    let self = this; // 将当前对象的引用赋值给self变量\r\n    setTimeout(function() {\r\n      console.log(self.name); // 使用self变量来访问当前对象的name属性\r\n    }, 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，`setTimeout`函数的回调函数中使用了`self`变量来访问当前对象的`name`属性，而不是直接使用`this`。需要注意的是，由于JavaScript中的函数作用域机制，我们可以在函数内部创建一个新的作用域，并且在该作用域中使用`self`变量。这样做可以避免在外部作用域中暴露`this`引用，从而提高代码的可维护性和安全性。\n\n然而，在ES6中，我们可以使用箭头函数来避免`self`变量的使用，因为箭头函数不会创建自己的作用域，而是继承父级作用域的`this`引用。因此，箭头函数中的`this`引用始终指向定义该函数时的对象。\n\n下面是使用箭头函数的示例：\n\n```\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  info() {\r\n    setTimeout(() => {\r\n      console.log(this.name); // 使用箭头函数中的this引用来访问当前对象的name属性\r\n    }, 1000);\r\n  }\r\n}\n\nconst person = new Person('John');\r\nperson.info();\r\n```\n\n在这个例子中，我们使用箭头函数来定义`setTimeout`的回调函数，这样就可以直接使用`this`引用来访问当前对象的`name`属性，而不需要使用`self`变量。这种方式更加简洁和易读，而且不需要额外的变量来保存`this`引用。"},{"title":"session-cookie-token","created":"20230522053602308","creator":"oeyoews","modified":"20230522053619523","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在 Web 应用中，通常会使用 Cookie、Session 和 Token 来管理用户的身份认证和数据状态。\n\nCookie 是一种存储在客户端的小型数据文件，可以用来存储用户的身份认证信息、偏好设置等数据。Cookie 通常由服务器生成，并通过 HTTP 头部发送给客户端，在客户端本地保存。每次客户端发送请求时，都会将相应的 Cookie 信息包含在请求头部中发送给服务器，服务器可以通过解析请求头部中的 Cookie 信息来判断用户的身份认证和状态。\n\nSession 是一种服务器端的存储机制，用来存储用户的身份认证和数据状态等信息。当用户第一次访问服务器时，服务器会生成一个唯一的 Session ID，并将其保存在一个名为 JSESSIONID 的 Cookie 中发送给客户端。客户端每次发送请求时，都会将 JSESSIONID 包含在请求头部中发送给服务器。服务器可以通过解析 JSESSIONID 来找到相应的 Session 数据，从而判断用户的身份认证和状态。\n\nToken 是一种轻量级的身份认证机制，通常使用 JSON Web Token（JWT）实现。JWT 由三部分组成，分别是 Header、Payload 和 Signature。其中 Header 用来描述 JWT 的类型和算法，Payload 用来存储用户的身份认证和其他数据，Signature 用来对 Header 和 Payload 进行签名，以确保数据的完整性和安全性。通常，服务器会将 JWT 发送给客户端，在客户端本地保存。客户端每次发送请求时，都会将 JWT 包含在请求头部中发送给服务器。服务器可以通过解析 JWT 来判断用户的身份认证和状态。\n\n总的来说，Cookie、Session 和 Token 都可以用来管理用户的身份认证和数据状态，但它们的实现机制和使用场景略有不同。Cookie 通常用来存储较小的数据，例如用户的身份认证信息和偏好设置等；Session 通常用来存储较大的数据，例如用户的购物车、浏览历史等；Token 通常用来实现无状态的身份认证，可以在分布式系统中使用。"},{"title":"sessionStorage","text":"sessionStorage 是会话存储，只能在同一个浏览器窗口（或者标签页）中共享数据，在浏览器窗口关闭时，存储在 sessionStorage 中的数据也会被清除。\r\n\r\n而 localStorage 是本地存储，可以在不同浏览器窗口（或者标签页）之间共享数据，并且即使关闭了浏览器窗口，存储在 localStorage 中的数据仍然存在。\r\n\r\n因此，如果您希望在刷新浏览器后仍然保留数据，应该使用 localStorage 而不是 sessionStorage。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Session Demo</title>\r\n  </head>\r\n  <body>\r\n    <h1>Session Demo</h1>\r\n\r\n    <!-- 用户输入名字和年龄 -->\r\n    <label for=\"name\">Name:</label>\r\n    <input type=\"text\" id=\"name\" /><br /><br />\r\n\r\n    <label for=\"age\">Age:</label>\r\n    <input type=\"number\" id=\"age\" /><br /><br />\r\n\r\n    <!-- 保存按钮 -->\r\n    <button onclick=\"saveData()\">Save</button>\r\n\r\n    <!-- 显示已保存的数据 -->\r\n    <h2>Saved Data:</h2>\r\n    <p id=\"saved-data\"></p>\r\n\r\n    <!-- 清除按钮 -->\r\n    <button onclick=\"clearData()\">Clear</button>\r\n\r\n    <script>\r\n      function saveData() {\r\n        // 获取用户输入的数据并保存到 sessionStorage 中\r\n        const name = document.getElementById(\"name\").value;\r\n        const age = document.getElementById(\"age\").value;\r\n\r\n        sessionStorage.setItem(\"name\", name);\r\n        sessionStorage.setItem(\"age\", age);\r\n\r\n        // 更新显示已保存的数据\r\n        updateSavedData();\r\n      }\r\n\r\n      function clearData() {\r\n        // 清除 sessionStorage 中的数据\r\n        sessionStorage.removeItem(\"name\");\r\n        sessionStorage.removeItem(\"age\");\r\n\r\n        // 更新显示已保存的数据\r\n        updateSavedData();\r\n      }\r\n\r\n      function updateSavedData() {\r\n        // 从 sessionStorage 中获取已保存的数据并更新页面上的文本内容\r\n        const name = sessionStorage.getItem(\"name\");\r\n        const age = sessionStorage.getItem(\"age\");\r\n\r\n        let savedDataText = \"\";\r\n\r\n        if (name) {\r\n          savedDataText += \"Name: \" + name + \"<br>\";\r\n        }\r\n\r\n        if (age) {\r\n          savedDataText += \"Age: \" + age + \"<br>\";\r\n        }\r\n\r\n        document.getElementById(\"saved-data\").innerHTML = savedDataText;\r\n      }\r\n\r\n      // 页面加载时更新已保存的数据\r\n      updateSavedData();\r\n    </script>\r\n  </body>\r\n</html>\r\n```","type":"text/markdown","created":"20230507093356341","creator":"oeyoews","modified":"20230507093435262","modifier":"oeyoews","tags":"JavaScript"},{"title":"set-timeout-interval","created":"20230530161245634","creator":"oeyoews","modified":"20230531031959906","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&set-timeout-interval","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"好的，setTimeout() 和 setInterval() 都是 JavaScript 中的定时器方法，用来在指定的时间间隔后执行一段代码。它们的主要区别在于时间间隔的处理方式和执行次数的限制。\n\nsetTimeout() 方法会在指定的时间间隔后，执行一次指定的函数。它只会执行一次，不会重复执行。如果我们需要在一段时间后执行一次特定的操作，可以使用 setTimeout() 方法。\n\n举个例子，我们可以编写一个名为 showMessage 的函数，用来显示一条消息。在该函数中，我们使用 setTimeout() 方法来延迟 3 秒钟后执行 showMesssage 函数：\n\n```\r\nfunction showMessage() {\r\n  alert('Hello, World!');\r\n}\n\nsetTimeout(showMessage, 3000);\r\n```\n\n在这个例子中，我们定义了一个名为 showMessage 的函数，用来显示一条消息。然后，我们使用 setTimeout() 方法来延迟 3 秒钟后执行 showMessage 函数。由于 setTimeout() 方法只会执行一次，因此 showMessage 函数只会被执行一次。\n\n相比之下，setInterval() 方法会在指定的时间间隔后，重复执行指定的函数。它会不断执行，直到我们使用 clearInterval() 方法来停止它。如果我们需要在固定的时间间隔内，重复执行一个操作，可以使用 setInterval() 方法。\n\n举个例子，我们可以编写一个名为 showTime 的函数，用来显示当前的时间。在该函数中，我们使用 setInterval() 方法来每秒钟执行一次 showTime 函数：\n\n```\r\nfunction showTime() {\r\n  const now = new Date();\r\n  const timeStr = now.toLocaleTimeString();\r\n  console.log(timeStr);\r\n}\n\nsetInterval(showTime, 1000);\r\n```\n\n在这个例子中，我们定义了一个名为 showTime 的函数，用来显示当前的时间。然后，我们使用 setInterval() 方法来每秒钟执行一次 showTime 函数。由于 setInterval() 方法会不断执行，因此 showTime 函数会每秒钟被执行一次。\n\n需要注意的是，setTimeout() 和 setInterval() 方法都是 JavaScript 中的定时器方法，它们都可以用来延迟执行一段代码。它们的主要区别在于时间间隔的处理方式和执行次数的限制。如果我们需要延迟执行一次特定的操作，可以使用 setTimeout() 方法；如果我们需要在固定的时间间隔内，重复执行一个操作，可以使用 setInterval() 方法。\n\n通常情况下，我们可以使用 clearInterval() 方法来清除 setInterval() 定时器。clearInterval() 方法接受一个参数，这个参数是 setInterval() 返回的定时器 ID。通过传入定时器 ID，我们可以清除该定时器。\n\n举个例子，我们可以先使用 setInterval() 方法创建一个定时器，并将返回的定时器 ID 保存到一个变量中。然后，我们可以使用 clearInterval() 方法来清除该定时器：\n\n```\r\nconst intervalId = setInterval(function() {\r\n  // 这里是定时器执行的代码\r\n}, 1000);\n\n// 清除定时器\r\nclearInterval(intervalId);\r\n```\n\n在这个例子中，我们使用 setInterval() 方法创建了一个每秒钟执行一次的定时器，并将返回的定时器 ID 保存到 intervalId 变量中。然后，我们可以使用 clearInterval() 方法来清除该定时器。\n\n需要注意的是，setInterval() 方法返回的定时器 ID 是一个数字，表示该定时器在定时器队列中的位置。如果我们需要清除一个定时器，需要传入该定时器的 ID。如果我们不清楚该定时器的 ID，可以将 setInterval() 方法返回的值保存到一个变量中，然后在需要清除定时器的时候使用 clearInterval() 方法来清除该定时器。\n\n另外，如果我们在使用 setInterval() 方法时，没有保存定时器 ID，可以使用 clearInterval() 方法来清除所有的定时器。可以使用一个变量来存储 setInterval() 方法返回的定时器 ID，然后在需要清除定时器的时候，通过该变量来清除定时器。如果没有保存定时器 ID，可以使用 clearInterval() 方法来清除所有的定时器，如下所示：\n\n```\r\n// 创建多个定时器\r\nsetInterval(function() {\r\n  // 代码\r\n}, 1000);\n\nsetInterval(function() {\r\n  // 代码\r\n}, 2000);\n\nsetInterval(function() {\r\n  // 代码\r\n}, 3000);\n\n// 清除所有定时器\r\nfor (var i = 0; i < 1000; i++) {\r\n  clearInterval(i);\r\n}\r\n```\n\n在这个例子中，我们创建了三个定时器，但是没有保存它们的定时器 ID。然后，我们使用一个循环来清除所有的定时器，因为 clearInterval() 方法只会清除传入的定时器 ID，所以我们可以传入一个很大的数值来清除所有的定时器。需要注意的是，这种方式可能会清除其他地方创建的定时器，因此需要谨慎使用。"},{"title":"shared-data","text":"在同源页面中，可以使用`window.postMessage()`方法实现数据共享。`postMessage()`方法允许将消息发送到另一个窗口或跨窗口的 iframe 中。\r\n\r\n以下是一些基本步骤来实现同源页面之间的数据共享：\r\n\r\n1. 在一个页面中使用`window.postMessage()`方法发送消息给另一个页面。\r\n2. 在另一个页面中使用`window.addEventListener()`方法监听`message`事件。\r\n3. 当`message`事件被触发时，使用`event.source.postMessage()`方法向原始页面发送响应数据。\r\n\r\n下面是一个简单示例，演示如何在两个同源页面之间共享数据：\r\n\r\n在源页面中：\r\n\r\n```plain\r\n// 源页面\r\nconst targetWindow = window.parent; // 获取目标窗口对象\r\ntargetWindow.postMessage('hello', 'http://localhost:8080'); // 向目标窗口发送消息\r\n```\r\n\r\n在目标页面中：\r\n\r\n```plain\r\n// 目标页面\r\nwindow.addEventListener('message', function(event) {\r\n  if (event.origin === 'http://localhost:8080') { // 确认消息来源\r\n    console.log('收到来自源页面的消息:', event.data);\r\n    event.source.postMessage('world', event.origin); // 向源页面发送响应消息\r\n  }\r\n});\r\n```\r\n\r\n在这个示例中，源页面向目标窗口发送了一个消息`hello`，并指定消息需要发送到`http://localhost:8080`。当目标页面接收到来自源页面的消息时，它会打印出消息内容，并向源页面发送响应消息`world`。\r\n\r\n需要注意的是，也同样需要在接收页面中进行安全检查，以确保消息来自预期的来源，并防止 XSS 攻击等风险。此外，在使用`postMessage()`方法时，还需要谨慎处理消息内容，避免不良用户通过此方式传递恶意代码。","type":"text/markdown","created":"20231002060651907","creator":"oeyoews","modified":"20231002060716791","modifier":"oeyoews","tags":"JavaScript"},{"title":"shift-unshift-push-pop","text":"这四个方法都是用来操作数组的，它们分别是`push()`、`pop()`、`shift()`和`unshift()`。下面是它们的区别：\n\n1. `push()`方法用于在数组的末尾添加一个或多个元素。\n2. `pop()`方法用于从数组的末尾移除最后一个元素。\n3. `shift()`方法用于从数组的开头移除第一个元素。\n4. `unshift()`方法用于在数组的开头添加一个或多个元素。\n\n这些方法在操作数组时非常有用，可以根据具体的需求选择合适的方法来对数组进行操作。","type":"text/markdown","created":"20240118052520728","creator":"oeyoews","modified":"20240118052610962","modifier":"oeyoews","tags":"JavaScript"},{"title":"sort","text":"`a.date > b.date ? 1 : -1` 是一个简洁的比较函数，用于对日期进行排序。\r\n\r\n这个比较函数可以应用于一个包含日期的数组，并根据日期的大小进行升序排序。\r\n\r\n下面是这个比较函数的工作原理：\r\n\r\n- 如果 `a.date` 大于 `b.date`，则返回 `1`，表示 `a` 应该排在 `b` 后面；\r\n- 如果 `a.date` 小于 `b.date`，则返回 `-1`，表示 `a` 应该排在 `b` 前面。\r\n\r\n通过返回不同的值，我们可以在排序时确定元素的相对位置。\r\n\r\n这种比较函数的作用是根据日期的大小来确定排序顺序。如果 `a.date` 大于 `b.date`，我们认为 `a` 较新，应该排在 `b` 后面；如果 `a.date` 小于 `b.date`，我们认为 `a` 较旧，应该排在 `b` 前面。\r\n\r\n这个比较函数是一种通用的约定，可以应用于各种排序需求，不仅限于日期。\r\n\r\n`arr.sort()` 是 JavaScript 中用于对数组进行排序的方法。它会原地修改数组，将其按照默认的排序规则进行排序。\r\n\r\n默认的排序规则是将数组元素转换为字符串，然后根据 Unicode 码点值的大小进行比较。\r\n\r\n以下是一些示例来演示 `arr.sort()` 的使用：\r\n\r\n```javascript\r\nconst numbers = [10, 5, 8, 1, 7];\r\nnumbers.sort();\r\nconsole.log(numbers);\r\n// 输出：[1, 10, 5, 7, 8]\r\n\r\nconst names = ['John', 'Alice', 'Bob', 'David'];\r\nnames.sort();\r\nconsole.log(names);\r\n// 输出：['Alice', 'Bob', 'David', 'John']\r\n\r\nconst mixed = [10, 'a', 5, 'b', 1];\r\nmixed.sort();\r\nconsole.log(mixed);\r\n// 输出：[1, 10, 5, 'a', 'b']\r\n```\r\n\r\n可以看到，默认情况下 `sort()` 方法会将元素转换成字符串，然后根据字符串的 Unicode 码点值进行比较排序。\r\n\r\n如果你希望按照其他规则进行排序，例如数字比较或自定义比较，可以传入一个比较函数作为参数。","type":"text/markdown","created":"20230722093201816","creator":"oeyoews","modified":"20230726045248773","modifier":"oeyoews","tags":"JavaScript"},{"title":"spawn-stdio","text":"在使用 \"spawn\" 命令时，可能会导致一些输出信息丢失的问题。这可能是因为 spawn 命令执行后，子进程的标准输出并没有被正确地捕获或处理。\n\n要解决这个问题，你可以尝试使用以下方法：\n\n1. **捕获标准输出：** 在使用 spawn 命令时，确保正确地捕获子进程的标准输出。你可以通过设置 spawn 的 `stdout` 选项来实现这一点。\n\n    ```javascript\n    const { spawn } = require('child_process');\n\n    const child = spawn('your_command', [], {\n        stdio: 'pipe', // 或者 'inherit'\n    });\n\n    child.stdout.on('data', (data) => {\n        // 处理标准输出\n        console.log(`stdout: ${data}`);\n    });\n\n    child.on('close', (code) => {\n        console.log(`子进程退出，退出码 ${code}`);\n    });\n    ```\n\n2. **查看错误输出：** 除了标准输出外，还可以查看子进程的错误输出，以便及时发现问题。\n\n    ```javascript\n    const { spawn } = require('child_process');\n\n    const child = spawn('your_command', [], {\n        stdio: ['pipe', 'pipe', 'pipe'], // 或者 'inherit'\n    });\n\n    child.stderr.on('data', (data) => {\n        // 处理错误输出\n        console.error(`stderr: ${data}`);\n    });\n\n    child.on('close', (code) => {\n        console.log(`子进程退出，退出码 ${code}`);\n    });\n    ```\n\n确保适当地设置 stdio 选项，并处理子进程的标准输出和错误输出，以便及时发现并解决问题。","type":"text/markdown","created":"20240123112053335","creator":"oeyoews","modified":"20240123112111441","modifier":"oeyoews","tags":"JavaScript"},{"title":"split","created":"20230527011832706","creator":"oeyoews","modified":"20230527014855506","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"split 方法是 JavaScript 中的一个字符串方法，它的作用是将一个字符串分割成子字符串，并将这些子字符串存储在一个数组中。这个方法可以接受一个参数，用来指定分割字符串的标准，也可以不传入任何参数，此时默认按照空格进行分割。下面是一个简单的例子：\n\n```\r\nconst str = 'hello world';\r\nconst arr = str.split(' ');\r\nconsole.log(arr); // [\"hello\", \"world\"]\r\n```\n\n在这个例子中，我们将字符串 'hello world' 按照空格进行分割，得到了一个包含 'hello' 和 'world' 的数组。\n\n另外，如果我们要将一个字符串按照某个字符串进行分割，可以将该字符串作为参数传入 split 方法，例如：\n\n```\r\nconst str = 'apple,orange,banana';\r\nconst arr = str.split(',');\r\nconsole.log(arr); // [\"apple\", \"orange\", \"banana\"]\r\n```\n\n在这个例子中，我们将字符串 'apple,orange,banana' 按照逗号进行分割，得到了一个包含 'apple'、'orange' 和 'banana' 的数组。"},{"title":"split-join-array-string","text":"```js\r\nconst de = \"1 2 3\";\r\nconsole.log(de.split(\" \").join(\"\"));\r\nconsole.log(...de.split(\" \"));\r\n```","type":"text/markdown","created":"20230925013202389","creator":"oeyoews","modified":"20230925013234695","modifier":"oeyoews","tags":"JavaScript"},{"title":"spread-operator","text":"剩余参数语法（Rest Parameters Syntax）和展开运算符（Spread Operator）在使用方式和作用上有所区别。\r\n\r\n1. 剩余参数语法（Rest Parameters Syntax）：`...args`\r\n\r\n剩余参数语法用于将多个参数收集到一个数组中。它在函数定义中使用，以表示函数可以接收任意数量的参数，并将它们作为数组访问。剩余参数语法只能在函数定义中使用，用于接收参数。\r\n\r\n示例：\r\n```javascript\r\nfunction sum(...numbers) {\r\n  // numbers 是一个包含所有参数的数组\r\n  let total = 0;\r\n  for (let num of numbers) {\r\n    total += num;\r\n  }\r\n  return total;\r\n}\r\n\r\nconsole.log(sum(1, 2, 3)); // 输出 6\r\nconsole.log(sum(4, 5, 6, 7)); // 输出 22\r\n```\r\n\r\n2. 展开运算符（Spread Operator）：`...array`\r\n\r\n展开运算符用于在数组或对象字面量中展开数组或对象的元素。它可以在函数调用、数组字面量、对象字面量等地方使用。展开运算符将一个数组或对象拆分成各个元素，作为独立的参数或键值对进行使用。\r\n\r\n示例：\r\n```javascript\r\n// 数组展开\r\nconst numbers = [1, 2, 3];\r\nconsole.log(...numbers); // 输出 1 2 3\r\n\r\n// 函数调用中使用展开运算符\r\nfunction sum(a, b, c) {\r\n  return a + b + c;\r\n}\r\n\r\nconsole.log(sum(...numbers)); // 输出 6\r\n\r\n// 数组拼接\r\nconst array1 = [1, 2, 3];\r\nconst array2 = [4, 5, 6];\r\nconst mergedArray = [...array1, ...array2];\r\nconsole.log(mergedArray); // 输出 [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n总结：\r\n- 剩余参数语法（Rest Parameters Syntax）用于函数定义中，将多个参数收集到一个数组中。\r\n- 展开运算符（Spread Operator）用于展开数组或对象，在函数调用、数组字面量、对象字面量等地方使用。\r\n\r\n虽然它们在语法上使用了相同的三个点（`...`），但根据它们所在的上下文和使用方式的不同，它们具有不同的作用和效果。","type":"text/markdown","created":"20230625042714181","creator":"oeyoews","modified":"20230726045248776","modifier":"oeyoews","tags":"JavaScript"},{"title":"stack-heap-js","text":"* js 由于变量作用域的原因, 不存在真正意义上的函数重载\n* 基本数据类型(string, number, boolean, symbol, null, undefined)在栈上, 引用数据类型在堆上.","type":"text/markdown","created":"20240116055430480","creator":"oeyoews","modified":"20240116081706808","modifier":"oeyoews","tags":"JavaScript"},{"title":"static-method","created":"20230602160931322","creator":"oeyoews","modified":"20230602161001099","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"```js\r\nclass MathUtils {\r\n    static pi = 3.14159;\r\n    static add(a, b) {\r\n        return a + b;\r\n    }\r\n}\n\nlet pi = MathUtils.pi; // 访问静态常量\r\nlet sum = MathUtils.add(3, 5); // 调用静态方法\r\n```"},{"title":"super","created":"20230602160306205","creator":"oeyoews","modified":"20230602160328714","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在 JavaScript 中，\"super\" 关键字也用于访问父类的属性和方法。它通常在 ES6 中的类和继承中使用。\n\n在使用 \"super\" 关键字时，它可以在子类构造函数中作为函数调用来调用父类构造函数，也可以在子类方法中作为对象来调用父类方法。在子类构造函数中，使用 \"super\" 关键字调用父类构造函数时，可以通过传递参数来设置父类的属性。在子类方法中使用 \"super\" 关键字时，它可以用来引用父类的方法，并在子类方法中进行进一步的处理。\n\n以下是使用 \"super\" 关键字的示例：\n\n```js\r\nclass Animal {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n  speak() {\r\n    console.log(this.name + ' makes a noise.');\r\n  }\r\n}\n\nclass Dog extends Animal {\r\n  constructor(name) {\r\n    super(name); // 调用父类的构造函数\r\n  }\r\n  speak() {\r\n    super.speak(); // 调用父类的方法\r\n    console.log(this.name + ' barks.');\r\n  }\r\n}\n\nlet d = new Dog('Mitzie');\r\nd.speak(); // 输出 \"Mitzie makes a noise.\" 和 \"Mitzie barks.\"\r\n```\n\n在这个例子中，子类 `Dog` 继承自父类 `Animal`，并且在子类构造函数中使用 \"super\" 关键字调用了父类的构造函数，以便为父类的属性进行初始化。在子类方法 `speak` 中，使用 \"super\" 关键字调用了父类的 `speak` 方法，并在其后添加了额外的行为。"},{"title":"super-contructor","text":"在面向对象编程中，`constructor` 和 `super` 是两个重要的概念，尤其是在继承关系中的使用。\r\n\r\n`constructor` 是一个类中的特殊方法，用于初始化对象的实例。当你创建一个对象的实例时，构造函数会被调用，以便执行一些初始化操作，例如设置对象的属性和状态。\r\n\r\n`super` 是一个关键字，用于调用父类的构造函数。在子类中的构造函数中，你可以使用 `super()` 来调用父类的构造函数，从而执行父类的初始化操作。这对于继承来自父类的属性和方法非常有用。\r\n\r\n以下是一个简单的示例代码，演示了如何在子类的构造函数中使用 `super`：\r\n\r\n```javascript\r\nclass Animal {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nclass Dog extends Animal {\r\n  constructor(name, breed) {\r\n    super(name); // 调用父类的构造函数\r\n    this.breed = breed;\r\n  }\r\n}\r\n\r\nconst myDog = new Dog(\"Buddy\", \"Golden Retriever\");\r\nconsole.log(myDog.name);  // 输出：Buddy\r\nconsole.log(myDog.breed); // 输出：Golden Retriever\r\n```\r\n\r\n在这个示例中，`Animal` 是父类，`Dog` 是子类。`Dog` 类的构造函数使用了 `super(name)` 来调用 `Animal` 类的构造函数，并传递了一个参数 `name`。\r\n\r\n总之，`constructor` 用于初始化对象实例，`super` 用于在子类的构造函数中调用父类的构造函数以进行初始化操作。","type":"text/markdown","created":"20230828092302112","creator":"oeyoews","modified":"20230828092318571","modifier":"oeyoews","tags":"JavaScript"},{"title":"switch-case","created":"20230527013557450","creator":"oeyoews","modified":"20230527114251266","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&switch-case","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"使用 switch case 重写代码的主要思路是将 if 语句中的条件判断改为 switch case 语句中的分支判断，这样可以提高代码的可读性和可维护性。\n\nswitch case 语句是 JavaScript 中的一种流程控制语句，用于根据一个变量的值进行分支判断。switch case 语句的基本语法如下：\n\n```\r\nswitch (variable) {\r\n  case value1:\r\n    // 当 variable 等于 value1 时执行的代码\r\n    break;\r\n  case value2:\r\n    // 当 variable 等于 value2 时执行的代码\r\n    break;\r\n  // ...\r\n  default:\r\n    // 当 variable 不等于任何一个值时执行的代码\r\n    break;\r\n}\r\n```\n\n在这个语法中，variable 表示需要进行分支判断的变量，value1、value2 等表示每个分支的值，default 表示当变量不等于任何一个值时需要执行的代码。\n\nswitch case 语句的执行流程是先计算 variable 的值，然后与每个 case 对应的值进行比较，如果匹配成功，则执行相应的代码，直到遇到 break 关键字或者整个 switch case 语句结束。如果所有的 case 都不匹配，则执行 default 分支中的代码。\n\n需要注意的是，在 switch case 语句中，case 后面的值可以是数字、字符串、布尔值等基本类型，也可以是对象或函数等复杂类型。另外，case 后面的值可以是常量表达式，也可以是变量和表达式的组合。\n\n下面是一个简单的例子，展示了 switch case 语句的基本用法：\n\n```\r\nconst fruit = 'apple';\r\nswitch (fruit) {\r\n  case 'apple':\r\n    console.log('这是一个苹果');\r\n    break;\r\n  case 'banana':\r\n    console.log('这是一个香蕉');\r\n    break;\r\n  case 'orange':\r\n    console.log('这是一个橘子');\r\n    break;\r\n  default:\r\n    console.log('这不是一个水果');\r\n    break;\r\n}\r\n```\n\n在这个例子中，我们定义了一个变量 fruit，然后使用 switch case 语句对其进行分支判断，输出相应的信息。由于变量 fruit 的值为 'apple'，因此执行第一个 case 中的代码，输出 '这是一个苹果'。"},{"title":"textcontent-innerHTML","created":"20230531110026964","creator":"oeyoews","modified":"20230531110048623","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"`textContent`和`innerHTML`都是用于获取或设置HTML元素文本内容的属性，但它们的用途略有不同。\n\n`textContent`用于获取或设置HTML元素的纯文本内容，即不包含任何HTML标记的文本。例如，如果您有一个`<p>`元素，其中包含一些文本和一些HTML标记，使用`textContent`将只返回文本内容，而不包含任何HTML标记。例如：\n\n```html\r\n<p id=\"my-paragraph\">这是一些文本内容<span>带有HTML标记</span></p>\r\n```\n\n```javascript\r\nvar paragraph = document.getElementById('my-paragraph');\r\nconsole.log(paragraph.textContent); // 输出：\"这是一些文本内容带有HTML标记\"\r\n```\n\n`innerHTML`用于获取或设置HTML元素的HTML内容，即包含所有HTML标记的内容。例如，使用`innerHTML`将返回包含HTML标记的完整HTML字符串，例如：\n\n```html\r\n<p id=\"my-paragraph\">这是一些文本内容<span>带有HTML标记</span></p>\r\n```\n\n```javascript\r\nvar paragraph = document.getElementById('my-paragraph');\r\nconsole.log(paragraph.innerHTML); // 输出：\"<span>带有HTML标记</span>\"\r\n因此，如果您只需要获取或设置HTML元素的文本内容，而不需要包含HTML标记，那么使用`textContent`将更适合您的需求。如果您需要获取或设置HTML元素的完整HTML内容，包括所有HTML标记，那么使用`innerHTML`将更适合您的需求。"},{"title":"This","text":"## JavaScript this 关键字\r\n\r\n### 面向对象语言中 this 表示当前对象的一个引用\r\n\r\n但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。\r\n\r\n在方法中，this 表示该方法所属的对象。\r\n如果单独使用，this 表示全局对象。\r\n在函数中，this 表示全局对象。\r\n在函数中，在严格模式下，this 是未定义的 (undefined)。\r\n在事件中，this 表示接收事件的元素。\r\n类似 call() 和 apply() 方法可以将 this 引用到任何对象。\r\n\r\nJavaScript 中的 this 关键字是一个指向当前执行上下文的引用，它的值取决于函数的调用方式。this 关键字可以用于访问当前对象的属性和方法，也可以用于创建新的对象。\r\n\r\n在 JavaScript 中，this 关键字的值取决于函数的调用方式。当函数被作为方法调用时，this 关键字会指向调用该方法的对象。例如：\r\n\r\n```javascript\r\nvar person = {\r\n  firstName: \"John\",\r\n  lastName : \"Doe\",\r\n  fullName : function() {\r\n    return this.firstName + \" \" + this.lastName;\r\n  }\r\n};\r\n\r\nconsole.log(person.fullName()); // 输出 \"John Doe\"\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 person 的对象，该对象包含了 firstName、lastName 和 fullName 三个属性。fullName 属性是一个函数，用于返回 person 对象的完整姓名。当我们调用 person.fullName() 方法时，this 关键字会指向 person 对象，因此函数中的 this.firstName 和 this.lastName 都会返回 person 对象的属性值。\r\n\r\n当函数不作为对象的方法调用时，this 关键字会指向全局对象。例如：\r\n\r\n```javascript\r\nfunction myFunction() {\r\n  return this;\r\n}\r\n\r\nconsole.log(myFunction()); // 输出全局对象\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 myFunction 的函数，该函数没有被任何对象调用。当我们调用 myFunction() 函数时，this 关键字会指向全局对象，因此函数中的 this 将返回全局对象。\r\n\r\n除了作为方法调用和全局调用之外，this 关键字还可以用于构造函数和事件处理程序等场景。在构造函数中，this 关键字用于创建新的对象。例如：\r\n\r\n```javascript\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n  this.fullName = function() {\r\n    return this.firstName + \" \" + this.lastName;\r\n  }\r\n}\r\n\r\nvar person = new Person(\"John\", \"Doe\");\r\nconsole.log(person.fullName()); // 输出 \"John Doe\"\r\n```\r\n\r\n在这个例子中，我们定义了一个名为 Person 的构造函数，用于创建具有 firstName 和 lastName 属性的 Person 对象。当我们使用 new 关键字调用 Person 构造函数时，this 关键字会指向新创建的 Person 对象，因此函数中的 this.firstName 和 this.lastName 都会被设置为新创建的对象的属性值。\r\n\r\n总之，JavaScript 中的 this 关键字是一个非常重要的概念，它的值取决于函数的调用方式，可以用于访问当前对象的属性和方法，也可以用于创建新的对象。在不同的场景中，需要根据具体情况来使用 this 关键字，以确保程序的正确性和可维护性。\r\n\r\n在 JavaScript 中，事件处理程序中的 this 关键字通常指向触发事件的元素。例如，当用户点击一个按钮时，按钮的 click 事件处理程序中的 this 关键字将指向该按钮元素。\r\n\r\n举个例子：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function() {\r\n  console.log(this); // 输出按钮元素\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们使用 addEventListener() 方法将一个 click 事件处理程序绑定到按钮元素上。当用户点击按钮时，该事件处理程序将被触发，此时 this 关键字将指向按钮元素，因此在函数中输出 this 将返回按钮元素。\r\n\r\n需要注意的是，如果事件处理程序使用箭头函数定义，则 this 关键字将不指向当前元素，而是指向定义该函数时的执行上下文。例如：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", () => {\r\n  console.log(this); // 输出全局对象\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们使用箭头函数定义 click 事件处理程序。由于箭头函数没有自己的 this 值，因此在事件处理程序中使用箭头函数定义时，this 关键字将不指向当前元素，而是指向定义该函数时的执行上下文。在这个例子中，事件处理程序中的 this 关键字将指向全局对象，因此在函数中输出 this 将返回全局对象。\r\n\r\n如果需要在事件处理程序中访问当前元素，可以使用 event.target 属性来获取当前触发事件的元素。例如：\r\n\r\n```html\r\n<button id=\"myButton\">点击我</button>\r\n\r\n<script>\r\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function(event) {\r\n  console.log(event.target); // 输出按钮元素\r\n});\r\n</script>\r\n```\r\n\r\n在这个例子中，我们在 click 事件处理程序中使用 event.target 属性来获取当前触发事件的元素，因此在函数中输出 event.target 将返回按钮元素。\r\n\r\n总之，事件处理程序中的 this 关键字通常指向触发事件的元素，但如果使用箭头函数定义事件处理程序，则 this 关键字将指向定义该函数时的执行上下文。如果需要在事件处理程序中访问当前元素，可以使用 event.target 属性来获取当前触发事件的元素。","type":"text/markdown","created":"20230529051917713","creator":"oeyoews","modified":"20230726045248780","modifier":"oeyoews","tags":"JavaScript"},{"title":"this-addeventlistener","text":"在 JavaScript 中，事件监听器中的 this 关键字通常指向触发事件的元素。例如，当你给一个按钮添加点击事件监听器时，事件处理函数中的 this 将指向这个按钮元素本身。这使得你可以在事件处理函数中访问和操作触发事件的元素，而不需要显式地引用它们的 ID 或类名。所以使用箭头函数改变 this","type":"text/markdown","created":"20231219061430091","creator":"oeyoews","modified":"20231219061509015","modifier":"oeyoews","tags":"JavaScript"},{"title":"throw-try-cache","text":"`throw`和`try...catch`是 JavaScript 中用于处理异常的两种不同机制。\r\n\r\n- `throw`关键字用于在代码中主动抛出异常。您可以使用`throw`关键字创建一个异常对象，并指定错误消息。抛出异常后，程序会立即停止执行当前代码块，并开始查找能够处理该异常的异常处理代码。如果没有找到合适的异常处理代码，程序将终止，并在控制台或浏览器中显示相应的错误消息。`throw`关键字用于主动引发异常，使得代码能够在错误或异常情况下中断正常的执行流程。\r\n\r\n- `try...catch`语句用于捕获和处理异常。您可以使用`try`块将可能抛出异常的代码包装起来，然后使用`catch`块来捕获和处理异常。如果`try`块中的代码抛出了异常，控制流会转到`catch`块，执行其中的代码来处理异常。`catch`块中可以访问异常对象，并根据需要进行处理。使用`try...catch`语句可以使得程序能够在遇到异常时进行适当的处理，而不会直接终止程序的执行。\r\n\r\n总结来说，`throw`关键字用于主动抛出异常，而`try...catch`语句用于捕获和处理异常。`throw`用于异常的产生，而`try...catch`用于异常的捕获和处理。它们是异常处理机制中的两个重要组成部分，可以帮助您编写更健壮和可靠的代码。","type":"text/markdown","created":"20230704055314327","creator":"oeyoews","modified":"20230726045248788","modifier":"oeyoews","tags":"JavaScript"},{"title":"try-catch","created":"20230425132750106","creator":"oeyoews","modified":"20230531065248701","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在 JavaScript 中，try...catch 语句中的 catch 代码块会自动接收一个异常对象作为参数。当 try 代码块中的代码发生异常时，JavaScript 引擎会创建一个异常对象，并将其传递给 catch 代码块。这个异常对象包含了异常的类型、消息、堆栈等信息，可以在 catch 代码块中使用这个对象来诊断和处理异常。\n\n例如，在下面的示例中，try 代码块中的 throw 语句会抛出一个 Error 类型的异常，catch 代码块中的 error 参数就会接收到这个异常对象。\n\n```javascript\r\ntry {\r\n  throw new Error('Something went wrong');\r\n} catch (error) {\r\n  console.error(error.name); // 输出 \"Error\"\r\n  console.error(error.message); // 输出 \"Something went wrong\"\r\n}\r\n```\n\n* 需要注意的是，catch 代码块中的参数名（如上面的 error）是任意的，只要符合标识符的命名规范即可。通常情况下，它被命名为 error 或 err，以表明它是一个异常对象。\r\n* finally 代码块时，通常用于释放资源或执行清理操作"},{"title":"ts-node-tsc","text":"你正在提到\"tsc\"和\"ts-node\"，它们是与 TypeScript 相关的工具。下面是它们的简要说明：\n\n1. **tsc**：这是 TypeScript 编译器的命令行工具。你可以使用它来将 TypeScript 代码编译成 JavaScript 代码。例如，你可以运行以下命令来编译一个 TypeScript 文件：\n\n   ```plain\n   tsc myfile.ts\n   ```\n\n   这将生成一个名为`myfile.js`的 JavaScript 文件。\n\n2. **ts-node**：这是一个 Node.js 运行时 (TypeScript) 的工具。它允许你直接运行 TypeScript 文件，而不需要事先编译成 JavaScript。你可以使用以下命令运行 TypeScript 文件：\n\n   ```plain\n   ts-node myfile.ts\n   ```\n\n   这将在 Node.js 环境中执行`myfile.ts`文件，而不需要手动编译成 JavaScript。\n\n这两个工具都对 TypeScript 开发者非常有用，tsc 用于编译项目，而 ts-node 用于快速运行 TypeScript 代码而不需要中间步骤。","type":"text/markdown","created":"20231021133046115","creator":"oeyoews","modified":"20231021133059624","modifier":"oeyoews","tags":"JavaScript"},{"title":"type-infer-on-loop","text":"在 TypeScript 中，如果你使用 for...in 循环遍历对象的属性，通常会丢失属性的具体类型信息，因此 TypeScript 无法正确进行类型推断。为了解决这个问题，你可以使用 Object.keys 方法结合数组的 forEach 方法，以便 TypeScript 正确推断属性的类型","type":"text/markdown","created":"20231221081427977","creator":"oeyoews","modified":"20231221081447038","modifier":"oeyoews","tags":"JavaScript"},{"title":"typescript","created":"20230507134954757","creator":"oeyoews","modified":"20230507135029257","modifier":"oeyoews","tags":"JavaScript TypeScript","type":"text/vnd.tiddlywiki","text":"* strong type\r\n* custome type"},{"title":"URLSearchParams","text":"`const params = new URLSearchParams();` 是创建一个新的 URLSearchParams 对象的代码。URLSearchParams 是一个内建的 JavaScript 对象，用于处理 URL 查询参数。\r\n\r\nURLSearchParams 对象提供了一种方便的方式来构建、解析和操作 URL 查询参数。您可以使用它来添加、获取、删除和迭代查询参数。\r\n\r\n以下是一些常见的 URLSearchParams 方法示例：\r\n\r\n- `append(name, value)`: 向 URLSearchParams 对象中添加一个新的查询参数。\r\n- `get(name)`: 获取指定名称的查询参数的值。\r\n- `delete(name)`: 删除指定名称的查询参数。\r\n- `toString()`: 将 URLSearchParams 对象转换为字符串，以便于在 URL 中使用。\r\n\r\n下面是一个使用 URLSearchParams 的示例：\r\n\r\n```javascript\r\nconst params = new URLSearchParams();\r\nparams.append(\"name\", \"John\");\r\nparams.append(\"age\", \"25\");\r\n\r\nconsole.log(params.get(\"name\")); // 输出：\"John\"\r\nconsole.log(params.toString()); // 输出：\"name=John&age=25\"\r\n\r\nparams.delete(\"age\");\r\nconsole.log(params.toString()); // 输出：\"name=John\"\r\n```\r\n\r\n在这个示例中，我们首先创建了一个空的 URLSearchParams 对象，然后使用 `append` 方法添加了两个查询参数：`name` 和 `age`。我们可以使用 `get` 方法获取指定名称的查询参数的值，并使用 `toString` 方法将 URLSearchParams 对象转换为字符串，以便于在 URL 中使用。最后，我们使用 `delete` 方法删除了名为 `age` 的查询参数。\r\n\r\nURLSearchParams 对象在处理 URL 查询参数时非常有用，使得操作和处理查询参数变得更加简单和方便。","type":"text/markdown","created":"20230704055911310","creator":"oeyoews","modified":"20230726045248794","modifier":"oeyoews","tags":"JavaScript"},{"title":"use-strict","text":"\"use strict\" 是 JavaScript 中的一个指令，用于指定在严格模式下执行代码。严格模式是一种更加限制性的代码执行环境，它会强制执行更严格的规则和最佳实践，以帮助开发人员避免一些常见的错误和不安全的行为。\r\n\r\n当使用 \"use strict\" 时，JavaScript 引擎会对代码进行更严格的解析和错误检查，一些原本被视为合法的代码行为将会受到限制或禁止。\r\n\r\n\"use strict\" 可以在全局作用域中使用，也可以放在函数体的开头，以指定在函数内部启用严格模式。\r\n\r\n严格模式下的一些特点和限制包括：\r\n\r\n1. 变量必须声明后再使用：在严格模式下，对未声明的变量进行赋值操作将会引发错误。\r\n2. 禁止删除变量、函数和函数参数：在严格模式下，使用 `delete` 操作符删除变量、函数和函数参数将会引发错误。\r\n3. 禁止对只读属性赋值：在严格模式下，对只读属性进行赋值操作将会引发错误。\r\n4. 禁止使用未声明的变量：在严格模式下，对未声明的变量进行访问将会引发错误。\r\n5. 禁止使用八进制字面量：在严格模式下，以零开头的数字将被解析为八进制数值将会引发错误。\r\n6. 禁止使用 `this` 指向全局对象：在严格模式下，当函数没有明确的调用对象时，`this` 的值将会是 `undefined`，而不是指向全局对象。\r\n\r\n严格模式有助于提高代码的可靠性和安全性，推荐在 JavaScript 开发中使用它。","type":"text/markdown","created":"20230626031121112","creator":"oeyoews","modified":"20230726045248803","modifier":"oeyoews","tags":"JavaScript"},{"title":"virtual-list","text":"虚拟列表是一种优化大型数据集的常见方式，通常与滚动到底部加载更多数据结合使用。下面是一个简单的示例，使用React和React Hooks创建一个虚拟列表，并在滚动到底部时加载更多数据。\n\n```jsx\nimport React, { useState, useRef, useCallback, useEffect } from 'react';\n\nconst VirtualList = () => {\n  const [data, setData] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const containerRef = useRef(null);\n\n  const fetchData = async () => {\n    // 模拟异步加载数据\n    setIsLoading(true);\n    const newData = await fetchMoreData(); // 你需要替换为实际的数据获取逻辑\n    setData((prevData) => [...prevData, ...newData]);\n    setIsLoading(false);\n  };\n\n  const handleScroll = useCallback(() => {\n    if (\n      containerRef.current &&\n      containerRef.current.scrollTop + containerRef.current.clientHeight >=\n        containerRef.current.scrollHeight - 20 &&\n      !isLoading\n    ) {\n      fetchData();\n    }\n  }, [isLoading]);\n\n  useEffect(() => {\n    // 初始加载数据\n    fetchData();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        height: '400px',\n        overflowY: 'auto',\n        border: '1px solid #ccc',\n      }}\n      onScroll={handleScroll}\n    >\n      <ul>\n        {data.map((item, index) => (\n          <li key={index} style={{ padding: '20px', borderBottom: '1px solid #ddd' }}>\n            {item}\n          </li>\n        ))}\n      </ul>\n      {isLoading && <p>Loading...</p>}\n    </div>\n  );\n};\n\n// 模拟异步加载更多数据的函数\nconst fetchMoreData = () => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const newData = Array.from({ length: 10 }, (_, index) => `Item ${index}`);\n      resolve(newData);\n    }, 1000);\n  });\n};\n\nexport default VirtualList;\n```\n\n在这个例子中，我们创建了一个 `VirtualList` 组件，它包含一个滚动容器（`<div>`）和一个虚拟列表。通过监控滚动事件，当用户滚动到底部时，触发 `fetchData` 函数加载更多数据。加载数据时，显示一个加载提示。\n\n请注意，这只是一个简单的示例，实际项目中你需要根据你的需求进行调整。此外，`fetchMoreData` 函数是一个模拟异步加载更多数据的函数，你需要替换为实际的数据获取逻辑。","type":"text/markdown","created":"20240124074804256","creator":"oeyoews","modified":"20240124074822379","modifier":"oeyoews","tags":"React JavaScript"},{"title":"webpack","text":"Webpack 和 Babel 是两个常用的前端工具，通常会一起使用，下面对它们分别进行简单介绍。\r\n\r\n### Webpack\r\n\r\nWebpack 是一个模块打包工具，主要用于打包 JavaScript 文件，但也可以处理 CSS、图片等资源文件。它将多个文件打包成一个或多个 bundle 文件，以便在浏览器中使用。Webpack 最重要的功能是代码分割和生成 source map，这些都有助于提高应用程序性能并方便调试。此外，Webpack 还具有插件系统，可以通过插件实现代码压缩、文件拆分、语法检查等功能。\r\n\r\nWebpack 具有以下特点：\r\n\r\n- 模块化：支持 import 和 export 语法。\r\n- 动态加载：提供 import() 方法实现动态加载模块。\r\n- 插件机制：插件可以自定义 webpack 的行为。\r\n- 优化功能：支持 tree shaking、Scope Hoisting、Code Splitting 等优化功能。\r\n\r\n### Babel\r\n\r\nBabel 是一个 JavaScript 编译器，它可以将新版本的 ECMAScript 代码转换为兼容性更好的旧版代码，以便于在老旧的浏览器中运行。Babel 可以将 ES6/7/8 等新语法转换为 ES5 代码，也可以将 React 的 JSX 语法转换为普通的 JavaScript 代码，以便于在浏览器环境中运行。\r\n\r\nBabel 具有以下特点：\r\n\r\n- 插件架构：可以通过插件扩展，满足不同项目的需求。\r\n- 预设：包含一些常用的插件集，例如 babel-preset-env、babel-preset-react 等。\r\n- Polyfill：提供 polyfill 方案，以便在老旧浏览器中支持新 API。\r\n- 编译时转换：转换是在编译时进行的，而不是运行时，因此性能较好。\r\n\r\nWebpack 和 Babel 可以结合使用，Webpack 可以作为 Babel 的执行环境，Webpack 会在打包时调用 Babel 将 ES6 代码转换为 ES5 代码，以便浏览器支持。例如，在 Webpack 配置文件中，可以使用 babel-loader 加载器来处理 JavaScript 文件，这样就能够实现将 ES6 代码转换为 ES5 代码的功能。\r\n\r\n总之，Webpack 和 Babel 是前端开发的两个重要工具，主要用于代码打包和转换。如果需要使用新的 ECMAScript 语法或写 React 代码，那么 Babel 就是必不可少的工具；而在打包和优化工作中，Webpack 则是不可或缺的工具。","type":"text/markdown","created":"20230502054337665","creator":"oeyoews","modified":"20230726045248809","modifier":"oeyoews","tags":"JavaScript"},{"title":"webview","created":"20230503031608258","creator":"oeyoews","modified":"20230503031626994","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"WebView是一种Android和iOS平台上的浏览器控件，它可以嵌入到应用程序中，以便在应用程序中显示Web页面或HTML内容。WebView允许开发者通过JavaScript与原生代码进行交互，例如调用原生功能、获取位置信息、弹出对话框等。\n\nWebView的优点如下：\n\n1. 简单易用：使用WebView可以非常方便地在应用程序中显示Web页面或HTML内容，而无需启动系统自带的浏览器。\n\n2. 定制性强：通过自定义WebView的配置选项，开发者可以控制WebView的各种行为，包括缓存策略、JavaScript支持、文件上传、Cookie管理等。\n\n3. 交互性好：WebView提供了JavaScript与原生代码之间的通信机制，使得应用程序可以更加灵活地与用户交互。\n\n4. 多平台支持：WebView不仅可以在Android和iOS平台上使用，还可以通过Cordova等跨平台工具在其他平台上使用。\n\n然而，WebView也有其不足之处。由于WebView是一个嵌入式浏览器控件，因此它的性能和渲染效果可能不如原生应用程序。同时，WebView也会受到Web安全漏洞的影响，因此开发者需要对WebView进行一些安全性处理，以避免应用程序受到攻击。\n\n总的来说，WebView是一种非常有用的技术，可以帮助开发者实现应用程序中的Web页面显示和交互功能。不过，在使用WebView时需要注意安全问题，并根据具体场景选择合适的方案。"},{"title":"when-to-use-reduce","text":"在某些特定情况下，使用 `reduce()` 方法可能更适合。以下是一些可能的情况：\n\n1. 累加操作：如果你需要对数组中的元素进行累加操作，例如计算总和、计算平均值或找到最大/最小值等，那么使用 `reduce()` 方法可以更直接地实现这些操作。\n\n2. 复杂的数据转换：如果你需要对数组中的元素进行复杂的转换操作，并且每次转换都依赖于前一次转换的结果，那么使用 `reduce()` 方法可以提供更灵活的处理方式。\n\n3. 自定义聚合操作：如果你需要进行自定义的聚合操作，而不仅仅是简单的过滤或映射，那么使用 `reduce()` 方法可以让你更好地控制聚合的逻辑。\n\n需要注意的是，在这些情况下，使用 `reduce()` 方法可能会比较适合，但也要考虑代码的可读性和维护性。如果使用 `reduce()` 方法导致代码变得复杂、难以理解，或者与团队内其他开发人员的编码习惯不一致，那么可以选择使用 `filter()` 和 `map()` 方法来保持代码的清晰性。","type":"text/markdown","created":"20231103081109138","creator":"oeyoews","modified":"20231103081123092","modifier":"oeyoews","tags":"JavaScript"},{"title":"why-super","created":"20230603014140777","creator":"oeyoews","modified":"20230603014154247","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"在 JavaScript 中，如果一个子类继承了一个父类，子类的构造函数中必须调用 `super()` 函数，以便调用父类的构造函数。这是因为，在 JavaScript 中，子类实例需要继承父类的属性和方法，而且父类的构造函数中可能会对这些属性和方法进行初始化。\n\n如果子类的构造函数中没有调用 `super()` 函数，那么父类的构造函数就不会被调用，子类实例就无法继承父类的属性和方法。这会导致子类实例在使用父类的属性和方法时出现错误。\n\n此外，在 JavaScript 中，如果子类定义了自己的构造函数，则必须在构造函数的开头显式地调用 `super()` 函数，以便调用父类的构造函数。这是因为，如果子类没有显式地调用 `super()` 函数，则默认的构造函数会被创建，该构造函数会自动调用父类的构造函数，但是如果子类定义了自己的构造函数，则默认的构造函数就不会被创建。因此，如果子类定义了自己的构造函数，就必须在其中调用 `super()` 函数，以便调用父类的构造函数。\n\n总之，调用 `super()` 函数是为了确保子类实例能够正确地继承父类的属性和方法，并且能够正确地进行初始化。如果不调用 `super()` 函数，则可能会导致子类实例无法正确地继承父类的属性和方法，从而导致程序出现错误。"},{"title":"window-global","text":"```js\r\nfunction main() {\r\n  demo = 2;\r\n  console.log(demo);\r\n}\r\n\r\nmain();\r\nconsole.log(demo);\r\n``` \r\n\r\n\r\ndemo = 2 === window.demo = 2","type":"text/markdown","created":"20230920101156217","modified":"20230920101227465","tags":"JavaScript"},{"title":"三目运算符","text":"```js\r\n${ci.isCI && ci.name}  // false\r\n${ci.isCI ? ci.name : ''} ''\r\n```","type":"text/markdown","created":"20230912013658571","modified":"20230912013749438","tags":"JavaScript"},{"title":"不可变数据01","text":"在编程中，不可变数据是指一旦创建，就不能被修改的数据。使用不可变数据有一些优点，包括：\n\n1. **防止意外的修改：** 不可变数据可以防止在程序的运行过程中意外地修改数据。这有助于避免由于数据被意外更改而导致的错误。\n\n2. **简化状态管理：** 不可变数据使得状态管理变得更为简单，特别是在涉及并发或异步操作时。因为数据不会改变，你不需要担心在多个地方同时修改数据时可能出现的问题。\n\n3. **更容易进行状态追踪：** 由于不可变数据的特性，你可以更容易地追踪数据的变化。每当需要新的数据时，都会创建一个新的不可变对象，而不是修改现有对象。\n\n4. **支持函数式编程：** 不可变数据是函数式编程的一个核心概念。在函数式编程中，函数是无副作用的，而不可变数据正好符合这个原则。\n\n5. **提高性能：** 由于不可变数据的特性，某些情况下可以进行更有效的内存优化，例如共享相同的不可变结构而不是复制数据。\n\n让我们看一个简单的例子：\n\n```javascript\n// 使用不可变数据\nconst originalArray = [1, 2, 3];\nconst newArray = [...originalArray, 4];  // 创建了一个新的数组，而不是修改原始数组\n\nconsole.log(originalArray);  // [1, 2, 3]\nconsole.log(newArray);       // [1, 2, 3, 4]\n```\n\n在这个例子中，通过使用不可变数据的方式，我们创建了一个新的数组 `newArray`，而不是直接修改 `originalArray`。这种方式遵循了不可变数据的原则。","type":"text/markdown","created":"20240109093533942","creator":"oeyoews","modified":"20240109093622919","modifier":"oeyoews","tags":"JavaScript"},{"title":"不可变数据02","text":"```js\nclass MyClass {\n  constructor(x) {\n    // Use a different name, such as `_x`, to store the property value.\n    this._x = x === undefined ? 0 : x;\n  }\n\n  // Use a different name for the getter method.\n  get x() {\n    return this._x;\n  }\n}\n\nconst c = new MyClass();\nc.x = 99;\nconsole.log(c.x); // 0\n```\n\n\n```js\n// error\nclass MyClass {\n    constructor(x) {\n        this.x = x === undefined ? 0 : x;  // 使用不同的名称存储属性值\n    }\n\n    get x() {\n\t\t\t\t// 这将会getter导致无限递归\n        return this.x;\n    }\n}\n```","type":"text/markdown","created":"20240109093632460","creator":"oeyoews","modified":"20240109093825565","modifier":"oeyoews","tags":"JavaScript"},{"title":"兜底","text":"在 JavaScript 中，所谓的\"兜底\"是指在代码执行出现异常情况时，可以给出一个备用方案，避免程序崩溃或不可用的情况。","type":"text/markdown","created":"20230421082847072","creator":"oeyoews","modified":"20230421082901383","modifier":"oeyoews","tags":"JavaScript"},{"title":"内部外部方法","text":"为了使`sayName`方法在实例之间共享，我们可以使用原型（prototype）来优化代码。使用原型的方式，可以将方法定义在构造函数的原型对象上，从而使所有实例对象都共享同一个方法。\r\n\r\n下面是使用原型来优化`Student`构造函数的示例代码：\r\n```js\r\nclass Student {\r\n    constructor(name, gender, age) {\r\n        this.name = name;\r\n        this.gender = gender;\r\n        this.age = age;\r\n    }\r\n    sayName() {\r\n        console.log(this.name); \r\n    }\r\n}\r\n```\r\n\r\n```javascript\r\nfunction Student(name, gender, age) {\r\n  this.name = name;\r\n  this.gender = gender;\r\n  this.age = age;\r\n}\r\n\r\nStudent.prototype.sayName = function() {\r\n  console.log(\"我是\" + this.name);\r\n}\r\n\r\nlet 小明 = new Student(\"小明\", '男', 12);\r\nlet 小红 = new Student(\"小红\", '女', 13);\r\n\r\n小明.sayName(); // -> \"我是小明\"\r\n小红.sayName(); // -> \"我是小红\"\r\n```\r\n\r\n在上面的代码中，我们将`sayName`方法定义在`Student`构造函数的原型对象上，而不是在构造函数内部定义。这样，所有使用`Student`构造函数创建的实例对象都可以共享同一个`sayName`方法。\r\n\r\n接着，我们创建了两个`Student`实例对象`小明`和`小红`，并分别调用它们的`sayName`方法，输出了它们的姓名。\r\n\r\n需要注意的是，使用原型定义方法时，方法中的`this`关键字指向的是调用该方法的实例对象，而不是构造函数本身。因此，在`sayName`方法中的`this.name`实际上是指实例对象的`name`属性，而不是构造函数的`name`属性。\r\n\r\n* https://juejin.cn/post/7241114001323819063\r\n* https://www.bilibili.com/video/BV11h411F7nd/?spm_id_from=333.1007.tianma.4-2-12.click&vd_source=d6afd7eedd9f9c940321c63f0a1539e3","type":"text/markdown","created":"20230606014925596","creator":"oeyoews","modified":"20230726045248360","modifier":"oeyoews","tags":"JavaScript"},{"title":"函数柯里化","text":"```js\r\n// bind 也可以用来部分应用一个函数（柯里化）。\r\nvar product = function(a, b){ return a * b; }\r\nvar doubler = product.bind(this, 2);\r\ndoubler(8); // = 16\r\n```\r\n\r\n`bind` 方法也可以用来实现函数的部分应用（partial application），也称为函数柯里化（currying）。\r\n\r\n函数的部分应用是指固定函数的一个或多个参数，生成一个新的函数。这个新函数只需要接收剩余的参数，就可以完成原函数的调用。通过部分应用，我们可以将一个接收多个参数的函数转换为一个接收少量参数的函数，从而可以更加灵活地复用函数。\r\n\r\n在上面的例子中，我们定义了一个乘法函数 `product`，然后使用 `bind` 方法将其部分应用到参数 `2` 上，生成一个新的函数 `doubler`。这个新函数只需要接收一个参数 `b`，然后将其与 `2` 相乘，就可以得到原来函数的结果。通过部分应用，我们将原来需要两个参数的函数转换为只需要一个参数的函数，从而可以更加方便地使用这个函数。\r\n\r\n需要注意的是，`bind` 方法可以同时绑定多个参数，而且可以在绑定参数的同时改变函数的 `this` 值。如果部分应用后的函数还需要继续部分应用，可以再次调用 `bind` 方法。","type":"text/markdown","created":"20230607043231525","creator":"oeyoews","modified":"20230726045248280","modifier":"oeyoews","tags":"JavaScript"},{"title":"剩余参数","text":":::see-also\n[[arguments]]\n:::\n\n`...args` 是 ES6 中的扩展语法，被称为剩余参数（Rest Parameters）。它允许你将函数的参数表示为一个数组，这在处理可变数量的参数时非常有用。\n\n具体来说，`...args` 用于收集函数的剩余参数，其中 `args` 是你定义的任意变量名。当函数被调用时，所有传递给函数的参数都被收集到 `args` 数组中。\n\n举个例子，假设有一个函数 `sum` 用于计算任意数量的数字的总和：\n\n```javascript\nfunction sum(...numbers) {\n    let total = 0;\n    for (let number of numbers) {\n        total += number;\n    }\n    return total;\n}\n\nconsole.log(sum(1, 2, 3, 4, 5)); // 输出: 15\n```\n\n\n在这个例子中，`...numbers` 将所有传递给 `sum` 函数的参数收集到一个名为 `numbers` 的数组中。在函数体内，我们可以像操作普通数组一样操作 `numbers`，从而实现对任意数量参数的求和。\n","type":"text/markdown","created":"20240125081335726","creator":"oeyoews","modified":"20240125081521738","modifier":"oeyoews","tags":"JavaScript"},{"title":"回调地狱","text":":::tip\n当一个请求需要依赖上一个请求返回结果的时候, 就会形成下面的回调地狱。\n:::\n\n假设你有一个简单的异步任务，比如使用`fetch`来获取数据并在页面上显示。使用回调函数可能会导致回调地狱，如下所示：\n\n```javascript\nfetch('https://api.example.com/data', function(response) {\n    response.json(function(data) {\n        processData(data, function(result) {\n            displayResult(result, function() {\n                // 更多嵌套的回调...\n            });\n        });\n    });\n});\n```\n\n通过使用Promise和async/await，你可以改写成更清晰的形式：\n\n```javascript\nasync function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        const data = await response.json();\n        const result = await processData(data);\n        await displayResult(result);\n        // 更多代码...\n    } catch (error) {\n        console.error('发生错误：', error);\n    }\n}\n\nfetchData();\n```\n\n这种方式使代码更易读，更易维护，并且避免了深度嵌套的回调结构。","type":"text/markdown","created":"20240117100728433","creator":"oeyoews","modified":"20240127041836341","modifier":"oeyoews","tags":"JavaScript"},{"title":"宏任务微任务","text":"__事件循环（Event Loop）__ 是 JavaScript 运行时环境中的一个重要概念，它负责管理和执行异步任务。事件循环使得 JavaScript 可以处理非阻塞的 I/O 操作，使得程序在执行异步任务时不需要等待，而是可以继续执行其他任务。\n\n__事件队列（Event Queue）__ 是事件循环中的一个组成部分，用于存储异步任务的回调函数。当异步任务完成并准备好执行其回调函数时，这些回调函数会被放入事件队列中等待执行。事件循环会不断地检查事件队列，当主线程空闲时，会从事件队列中取出一个回调函数，并将其执行，然后继续检查事件队列中是否还有其他任务需要执行。\n\n简而言之，事件循环负责不断地从事件队列中取出任务执行，使得 JavaScript 可以有效地处理异步操作，提高了程序的性能和响应速度。\n\n在 JavaScript 中，宏任务（macrotask）和微任务（microtask）是用于管理 __异步代码__ 执行顺序的重要概念。\n\n- **宏任务（macrotask）**：宏任务是由浏览器提供的任务队列中执行的任务。常见的宏任务包括\n\n1. setTimeout\n2. setInterval\n3. requestAnimationFrame\n4. I/O 操作等。\n\n当执行一个宏任务时，会等待任务完成后再执行下一个宏任务，因此它们之间有一个较大的时间间隔。\n\n- **微任务（microtask）**：微任务是在 JavaScript 引擎内部的微队列中执行的任务。常见的微任务包括\n\n1. Promise 的 then 方法\n2. async/await(promise)\n3. MutationObserver 的回调函数等。\n\n:::abstract\n先同后异，主线程轮询, 先微后宏,\n:::\n\n微任务会在当前任务执行结束后立即执行，因此它们的优先级比宏任务要高，且微任务队列会在每个任务执行结束后立即清空。\n\n这两者之间的区别在于执行时机和优先级，了解它们有助于更好地理解 JavaScript 中的异步编程。\n\n```mermaid\ngraph LR;\n    A[开始] --> B{宏任务队列是否为空}\n    B -->|是| C[等待用户交互]\n    B -->|否| D[执行下一个宏任务]\n    D --> E[执行微任务队列]\n    E --> F[执行下一个微任务]\n    F -->|微任务队列为空| D\n    F -->|微任务队列不为空| E\n    C -->|用户交互完成| D\n```\n\n## 调用栈在处理同步任务和异步任务时有所不同\n\n1. **同步任务**：\n   当执行同步任务时，函数调用会按照顺序一个接一个地被添加到调用栈中，并按照后进先出（LIFO）的顺序执行。也就是说，最后被添加到调用栈的函数会最先执行，直到调用栈为空。\n\n2. **异步任务**：\n   异步任务在执行时，通常**不会立即进入调用栈执行，而是被放入任务队列中等待执行**。当满足某些条件时（比如网络请求完成、定时器到期等），异步任务会被推送到任务队列中。然后，事件循环会不断地从任务队列中取出任务，并将其放入调用栈中执行。\n\n总的来说，同步任务会立即执行，而异步任务会在满足特定条件时才被执行。异步任务的执行顺序不是由调用栈决定的，而是由事件循环和任务队列协同决定的。\n\n```mermaid\ngraph LR;\n    A[开始] --> B[同步任务1];\n    B --> C[同步任务2];\n    C --> D[异步任务1等待];\n    D --> E[同步任务3];\n    E --> F[异步任务2等待];\n    F --> G[结束];\n\n    subgraph 任务队列\n        H[异步任务1执行] --> I[异步任务1完成];\n        J[异步任务2执行] --> K[异步任务2完成];\n    end\n\n```\n\n\n```mermaid\n---\ntitle: 执行顺序\n---\n\ngraph LR;\n a[开始] --> b[同步代码] \n b --> c[异步代码]\n subgraph 异步代码\n c --> d[宏任务]\n c --> e[微任务]\nend\n```\n\n:::tip\n异步事件的执行更像是一个trigger, 满足条件后就触发了。\n:::\n\n:::tip\n对于宏任务和微任务的嵌套， 执行流程遵循DFS深度优先。 宏任务优先级小于微任务。\n:::\n\n【字节前端面试真题解析：彻底打通事件循环(Event Loop)及事件队列(Event Queue)机制、同步异步、宏任务微任务】 https://www.bilibili.com/video/BV1GV411s7G6/?p=3&share_source=copy_web&vd_source=96bbb7beeae76632120bcfdbb20a632f","type":"text/markdown","created":"20240127090357536","creator":"oeyoews","modified":"20240130141801468","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random/1920x1080?fm=blurhash&sea","tags":"JavaScript"},{"title":"展开运算符","text":"展开运算符在处理数组时会去重。如果在展开过程中出现重复的元素，JavaScript 会自动去除重复的部分，确保最终结果中不含重复元素。\n\n例如：\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [3, 4, 5];\nconst arr3 = [...arr1, ...arr2];\nconsole.log(arr3); // 输出：[1, 2, 3, 4, 5]\n```\n\n在上面的例子中，当将 arr1 和 arr2 展开后合并为 arr3 时，重复的元素 3 只会出现一次，确保了最终的合并数组不含重复元素。","type":"text/markdown","created":"20231116080337003","creator":"oeyoews","modified":"20231116080354641","modifier":"oeyoews","tags":"JavaScript"},{"title":"展开运算符-浅拷贝","text":"在这两行代码中，`const originalArray = [...array];` 和 `const originalArray = array;` 之间存在一些区别。\r\n\r\n1. `const originalArray = [...array];`：这行代码使用了扩展运算符 `...`，它创建了一个原数组 `array` 的浅拷贝。这意味着 `originalArray` 现在引用的是一个与 `array` 具有相同内容的新数组，但是两个数组在内存中是独立的，互不影响。如果你修改 `originalArray` 或 `array` 中的任何一个数组，另一个数组不会受到影响。\r\n\r\n2. `const originalArray = array;`：这行代码直接将 `originalArray` 设置为引用了 `array`。这意味着 `originalArray` 和 `array` 实际上引用了同一个数组对象。如果你修改 `originalArray` 或 `array` 中的元素，两个变量引用的是同一数组，所以另一个变量也会受到影响。\r\n\r\n综上所述，`const originalArray = [...array];` 创建了一个独立的数组副本，而 `const originalArray = array;` 则创建了两个变量引用同一个数组。通常情况下，如果你希望在不影响原数组的情况下对数组进行修改，使用 `const originalArray = [...array];` 是更安全的选项。","type":"text/markdown","created":"20230827145001426","creator":"oeyoews","modified":"20230827145028778","modifier":"oeyoews","tags":"JavaScript"},{"title":"排序sort","text":"JavaScript 中内置的 `Array.prototype.sort()` 方法的具体排序算法是不确定的，因为它可以根据不同的 JavaScript 引擎和浏览器实现而异。不同的引擎可能会选择不同的排序算法来实现这个方法。\r\n\r\n一些 JavaScript 引擎可能会使用快速排序（Quick Sort）或合并排序（Merge Sort）等高效的排序算法来实现 `sort()` 方法。这些算法通常在平均情况下表现良好，但在某些特定情况下可能会退化为较差的性能。\r\n\r\n有些引擎还可能根据数组的长度和内容使用不同的排序算法，以优化性能。例如，当数组的长度较小时，可能会选择使用插入排序（Insertion Sort）等简单但在小规模数据上效果不错的算法。\r\n\r\n由于 JavaScript 引擎的实现会不断演化，具体的排序算法可能会有所变化。因此，在编写依赖于排序算法的代码时，最好不要对排序算法的实现细节作出假设，而是依赖于内置的 `Array.prototype.sort()` 方法来进行排序。\r\n\r\n学习排序算法仍然是有意义的，尽管现代编程语言和框架提供了内置的排序功能。以下是一些学习排序算法仍然有价值的理由：\r\n\r\n1. **算法理解与优化：** 学习排序算法可以帮助你更深入地理解算法设计和优化的原理。理解不同排序算法的时间复杂度、空间复杂度、最佳和最差情况等，有助于你在编写性能优化的代码时做出明智的选择。\r\n\r\n2. **面试和编程挑战：** 在技术面试和编程挑战中，排序算法是常见的问题。了解多种排序算法可以帮助你在面试中表现更出色，并且在解决各种编程问题时能够选择合适的排序策略。\r\n\r\n3. **特定场景需求：** 尽管内置排序方法足够满足大多数情况，但在某些特定场景下，你可能需要实现或优化排序算法。例如，你可能需要针对特定数据分布或数据量较小的情况进行性能优化，而不同的排序算法在不同的情况下可能会表现更好。\r\n\r\n4. **编程能力的提升：** 学习排序算法可以培养你的算法思维，让你在解决各种问题时能够更加灵活和创新。这种思维方式有助于你在编写高效和可维护的代码时更好地选择合适的算法和数据结构。\r\n\r\n5. **深入计算机科学：** 排序算法是计算机科学的基础知识之一。通过学习排序算法，你可以更好地理解计算机科学的核心概念，为进一步深入学习其他算法和数据结构打下坚实基础。\r\n\r\n综上所述，学习排序算法仍然具有很大的价值。尽管你可能不需要在日常开发中手动实现排序算法，但理解它们可以帮助你成为更出色的程序员，并在特定情况下做出更明智的选择。","type":"text/markdown","created":"20230827144601753","creator":"oeyoews","modified":"20230827144720519","modifier":"oeyoews","tags":"JavaScript"},{"title":"条件运算符","created":"20230531045935749","creator":"oeyoews","modified":"20230531050231061","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"条件运算符号是 JavaScript 中的一个运算符，用于根据某个条件返回不同的值。条件运算符号通常包含三个部分，分别是条件表达式、如果条件为真时返回的值和如果条件为假时返回的值。当条件表达式为真时，返回第二个部分的值，否则返回第三个部分的值。\n\n下面是一个示例代码，用于演示条件运算符号的使用：\n\n```js\r\nconst a = 5;\r\nconst b = 10;\n\nconst result = a > b ? 'a > b' : 'a <= b';\n\nconsole.log(result); // 输出 'a <= b'\n\nconst isDemo = false;\r\nconst demo = (isDemo) ? 'isdmeo' : 'notdemo'\r\n```\n\n在这个示例代码中，我们定义了两个变量 a 和 b，并将它们的值分别设置为 5 和 10。然后，我们使用条件运算符号来比较 a 和 b 的大小，如果 a 大于 b，则返回 'a > b'，否则返回 'a <= b'。最后，我们将返回的值保存在 result 变量中，并使用 console.log() 方法将其输出到控制台中。\n\n需要注意的是，在使用条件运算符号时，需要仔细考虑条件表达式的取值和返回值的类型，以避免出现不必要的错误。同时，也需要在代码中添加适当的注释和格式化，以提高代码的可读性和可维护性。"},{"title":"测试数据的JS库","text":"* https://github.com/faker-js/faker\r\n* https://github.com/typicode/json-server","type":"text/markdown","created":"20230624033301396","creator":"oeyoews","modified":"20230726045248271","modifier":"oeyoews","tags":"JavaScript"},{"title":"浏览器最小字号的限制","text":"浏览器有一个最小字号的限制， 12px， 用户可以更改浏览器的最小字号设置， 但是这仅仅会在用户自己的浏览器上生效。 解决办法就是使用scale.\n\n:::tip\n新版的谷歌浏览器已经取消了这个限制\n:::","type":"text/markdown","created":"20240122063315853","creator":"oeyoews","modified":"20240122063513063","modifier":"oeyoews","tags":"JavaScript"},{"title":"深浅拷贝","text":"浅拷贝和深拷贝是两种不同的对象复制方式，它们的区别在于拷贝的深度和引用关系。让我们详细了解一下它们的区别：\r\n\r\n1. **浅拷贝（Shallow Copy）**：\r\n   浅拷贝是创建一个新对象，将原始对象的属性值复制到新对象中。如果属性值是基本数据类型（例如数字、字符串、布尔值等），那么拷贝的是值本身。但如果属性值是引用类型（例如数组、对象、函数等），拷贝的是引用地址，新对象与原对象会共享同一个引用，因此对其中一个对象的修改会影响到另一个对象。\r\n\r\n   示例：\r\n   ```javascript\r\n   const originalArray = [1, 2, 3];\r\n   const shallowCopyArray = originalArray.slice();\r\n\r\n   originalArray[0] = 0;\r\n\r\n   console.log(shallowCopyArray); // Output: [1, 2, 3]\r\n   ```\r\n\r\n2. **深拷贝（Deep Copy）**：\r\n   深拷贝是创建一个新对象，同时递归复制原始对象的所有属性和嵌套对象。这意味着新对象和原对象完全独立，不共享任何引用关系，即使嵌套属性也会被递归地复制。\r\n\r\n   示例：\r\n   ```javascript\r\n   const originalObject = { a: 1, b: { c: 2 } };\r\n   const deepCopyObject = JSON.parse(JSON.stringify(originalObject));\r\n\r\n   originalObject.b.c = 0;\r\n\r\n   console.log(deepCopyObject); // Output: { a: 1, b: { c: 2 } }\r\n   ```\r\n\r\n需要注意的是，深拷贝有一些限制。它无法正确地处理一些特殊类型，如函数、正则表达式、循环引用等。此外，深拷贝会在复制过程中创建大量的临时对象，可能会导致性能问题。因此，在选择拷贝方式时，需要根据具体情况进行权衡。\r\n\r\n总结起来，浅拷贝只复制一层属性，深拷贝会递归复制所有嵌套属性，确保创建了一个完全独立的对象。\r\n\r\n浅拷贝和深拷贝在不同的使用场景中具有不同的应用。让我们看看它们在实际开发中的一些常见用途：\r\n\r\n**浅拷贝的使用场景：**\r\n\r\n1. **快速复制：** 当你只需要复制一个对象的第一层属性时，浅拷贝是一个快速且有效的方法。\r\n\r\n2. **性能优化：** 浅拷贝通常比深拷贝更快，因为它只复制了引用地址，而不是递归复制整个对象结构。在对性能要求较高的情况下，可以考虑使用浅拷贝。\r\n\r\n3. **共享状态：** 如果你希望多个对象共享一部分相同的属性，浅拷贝可以实现这种共享。修改其中一个对象的属性会影响其他对象。\r\n\r\n**深拷贝的使用场景：**\r\n\r\n1. **独立性要求：** 当你需要创建一个与原对象完全独立的对象，且不希望修改一个对象对另一个对象产生影响时，深拷贝是必需的。\r\n\r\n2. **递归属性：** 当对象中包含嵌套的对象或数组，而你需要递归地复制所有层级的属性时，深拷贝是唯一的选择。\r\n\r\n3. **数据传递：** 在数据传递过程中，特别是在多层嵌套的数据结构中，使用深拷贝可以确保传递的数据保持独立性，不受外部影响。\r\n\r\n4. **特殊数据类型：** 深拷贝可以正确地复制包括函数、正则表达式等特殊数据类型，而浅拷贝不能实现这些。\r\n\r\n综上所述，根据你的具体需求，选择浅拷贝还是深拷贝是很重要的。浅拷贝适用于快速复制和性能优化，而深拷贝适用于创建独立的对象、处理递归属性和传递数据等情况。","type":"text/markdown","created":"20230827145157329","creator":"oeyoews","modified":"20230827145234135","modifier":"oeyoews","tags":"JavaScript"},{"title":"继承","created":"20230524110639902","creator":"oeyoews","modified":"20230525022835904","modifier":"oeyoews","page-cover":"https://source.unsplash.com/random?fm=blurhash&w=50&继承","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"JavaScript中的继承可以通过原型链实现。具体来说，可以使用`Object.create()`方法创建一个新对象，将父类的原型作为参数传入，然后再将子类的原型设置为这个新对象。这样，子类就可以继承父类的属性和方法了。\n\n下面是一个简单的例子，展示了如何使用原型链实现继承：\n\n```javascript\r\n// 定义一个父类\r\nfunction Animal(name) {\r\n  this.name = name;\r\n}\n\n// 父类的原型方法\r\nAnimal.prototype.sayName = function() {\r\n  console.log('My name is ' + this.name);\r\n};\n\n// 定义一个子类\r\nfunction Dog(name, breed) {\r\n  Animal.call(this, name); // 调用父类构造函数\r\n  this.breed = breed;\r\n}\n\n// 子类的原型继承父类\r\nDog.prototype = Object.create(Animal.prototype);\r\nDog.prototype.constructor = Dog;\n\n// 子类的原型方法\r\nDog.prototype.bark = function() {\r\n  console.log('Woof!');\r\n};\n\n// 创建一个实例\r\nvar myDog = new Dog('Fido', 'Labrador');\n\n// 调用父类的方法\r\nmyDog.sayName(); // 输出 \"My name is Fido\"\n\n// 调用子类的方法\r\nmyDog.bark(); // 输出 \"Woof!\"\r\n```\n\n在上面的例子中，`Dog`类继承了`Animal`类的属性和方法，同时还定义了自己的属性和方法。注意，为了确保`Dog`类的原型指向正确，需要将其`constructor`属性设置为`Dog`本身。\n\n除了使用原型链实现继承之外，JavaScript还提供了其他几种继承方式：\n\n1. 构造函数继承\n\n这种方式是在子类构造函数内部调用父类构造函数，从而实现继承。具体来说，可以使用`call()`或`apply()`方法来调用父类构造函数，并将子类实例作为上下文对象，这样就可以在子类实例上定义父类的属性和方法了。这种方式的缺点是无法继承父类原型上的方法。\n\n```javascript\r\n// 定义一个父类\r\nfunction Animal(name) {\r\n  this.name = name;\r\n}\n\n// 父类的方法\r\nAnimal.prototype.sayName = function() {\r\n  console.log('My name is ' + this.name);\r\n};\n\n// 定义一个子类\r\nfunction Dog(name, breed) {\r\n  Animal.call(this, name); // 调用父类构造函数\r\n  this.breed = breed;\r\n}\n\n// 创建一个实例\r\nvar myDog = new Dog('Fido', 'Labrador');\n\n// 调用父类的方法\r\nmyDog.sayName(); // TypeError: myDog.sayName is not a function\r\n```\n\n2. 组合继承\n\n组合继承是将原型链继承和构造函数继承结合起来的一种方式。具体来说，可以通过在子类构造函数内部调用父类构造函数来继承父类的属性，然后再将子类的原型设置为一个新的父类实例，从而继承父类的方法。这种方式的缺点是会调用两次父类构造函数，一次是在子类构造函数内部，一次是在设置子类原型时。这种方式也可以称为伪经典继承。\n\n```javascript\r\n// 定义一个父类\r\nfunction Animal(name) {\r\n  this.name = name;\r\n}\n\n// 父类的方法\r\nAnimal.prototype.sayName = function() {\r\n  console.log('My name is ' + this.name);\r\n};\n\n// 定义一个子类\r\nfunction Dog(name, breed) {\r\n  Animal.call(this, name); // 调用父类构造函数\r\n  this.breed = breed;\r\n}\n\n// 子类的原型继承父类\r\nDog.prototype = new Animal();\r\nDog.prototype.constructor = Dog;\n\n// 创建一个实例\r\nvar myDog = new Dog('Fido', 'Labrador');\n\n// 调用父类的方法\r\nmyDog.sayName(); // 输出 \"My name is Fido\"\r\n```\n\n3. ES6的class继承\n\nES6引入了`class`关键字，使得JavaScript的面向对象编程更加符合传统的类继承方式。使用`class`定义一个类，可以使用`extends`关键字来继承另一个类，从而实现继承。这种方式的优点是语法更加简洁，易于理解。\n\n```javascript\r\n// 定义一个父类\r\nclass Animal {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\n\n  sayName() {\r\n    console.log('My name is ' + this.name);\r\n  }\r\n}\n\n// 定义一个子类\r\nclass Dog extends Animal {\r\n  constructor(name, breed) {\r\n    super(name); // 调用父类构造函数\r\n    this.breed = breed;\r\n  }\n\n  bark() {\r\n    console.log('Woof!');\r\n  }\r\n}\n\n// 创建一个实例\r\nvar myDog = new Dog('Fido', 'Labrador');\n\n// 调用父类的方法\r\nmyDog.sayName(); // 输出 \"My name is Fido\"\n\n// 调用子类的方法\r\nmyDog.bark(); // 输出 \"Woof!\"\r\n```\n\n以上是几种常见的JavaScript继承方式，每种方式都有其优缺点，选择哪种方式取决于具体的需求和场景。"},{"title":"解构01","text":"```js\r\n// const widget = require('widget').widget\r\n// const { widget } = require(\"widget\");\r\n\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: 3,\r\n};\r\n\r\n// const { a } = obj;\r\nconst a = obj.a;\r\n```","type":"text/markdown","created":"20230613042644173","creator":"oeyoews","modified":"20230726045248307","modifier":"oeyoews","tags":"JavaScript"},{"title":"解构语法","text":"解构语法是一种方便的 JavaScript 语法，用于从对象或数组中提取数据，然后将提取的数据赋值给变量。解构语法通常使用花括号 `{}` 或方括号 `[]` 来表示要提取的数据的结构。\r\n\r\n以下是一个从对象中提取数据的示例：\r\n\r\n```javascript\r\nconst person = { name: \"Alice\", age: 30, gender: \"female\" };\r\n\r\n// 使用解构语法从 person 对象中提取 name 和 age 属性\r\n// const name = person.name;\r\n// const age = person.age;\r\nconst { name, age } = person;\r\n\r\nconsole.log(name); // 输出 \"Alice\"\r\nconsole.log(age);  // 输出 30\r\n```\r\n\r\n在这个示例中，我们使用解构语法从 `person` 对象中提取 `name` 和 `age` 属性，并将它们分别赋值给变量 `name` 和 `age`。因此，在调用 `console.log(name)` 和 `console.log(age)` 时，分别输出了 \"Alice\" 和 30。\r\n\r\n解构语法也可以用于从数组中提取数据。以下是一个从数组中提取数据的示例：\r\n\r\n```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\n// 使用解构语法从 numbers 数组中提取第一个和第二个元素\r\nconst [first, second] = numbers;\r\n\r\nconsole.log(first);  // 输出 1\r\nconsole.log(second); // 输出 2\r\n```\r\n\r\n在这个示例中，我们使用解构语法从 `numbers` 数组中提取第一个和第二个元素，并将它们分别赋值给变量 `first` 和 `second`。因此，在调用 `console.log(first)` 和 `console.log(second)` 时，分别输出了 1 和 2。","type":"text/markdown","created":"20230607031640950","creator":"oeyoews","modified":"20230726045248307","modifier":"oeyoews","tags":"JavaScript"},{"title":"闭包","created":"20230603143406153","creator":"oeyoews","modified":"20230603143419574","modifier":"oeyoews","tags":"JavaScript","type":"text/vnd.tiddlywiki","text":"一个常见的实际应用闭包的例子是事件监听器。在 JavaScript 中，可以使用闭包来实现事件监听器，以便在函数之外访问事件处理程序中的变量。下面是一个示例：\n\n```javascript\r\nfunction createButton() {\r\n  var count = 0;\r\n  var button = document.createElement('button');\r\n  button.innerHTML = 'Click me';\r\n  button.addEventListener('click', function() {\r\n    count++;\r\n    console.log('Button clicked ' + count + ' times');\r\n  });\r\n  return button;\r\n}\n\nvar button = createButton();\r\ndocument.body.appendChild(button);\r\n```\n\n在上述代码中，`createButton` 函数返回一个新的按钮元素，并向其添加了一个 `click` 事件监听器。这个事件监听器访问了 `count` 变量，而 `count` 变量是在 `createButton` 函数内部定义的，并且只有事件监听器才能访问它。因此，事件监听器形成了一个闭包，可以访问 `count` 变量并在每次点击按钮时将其值加一。\n\n通过使用闭包，可以将 `count` 变量封装在函数作用域内，避免了全局变量的污染，同时也让代码更加模块化和可维护。"},{"title":"闭包函数","text":"```js\n// 创建一个对象\nvar obj = {\n  name: \"My Object\",\n  logName: function() {\n    // 在这里使用了闭包\n    setTimeout(function() {\n      // 这里的 this 指向的是全局对象（在浏览器中是 window）\n      console.log(this.name);\n    }, 1000);\n  }\n};\n\n// 调用对象的方法\nobj.logName(); // 输出 undefined\n```\n\n```js\nvar obj = {\n  name: \"My Object\",\n  logName: function() {\n    // 使用箭头函数\n    setTimeout(() => {\n      // 这里的 this 指向的是 logName 方法中的 this\n      console.log(this.name);\n    }, 1000);\n  }\n};\n\nobj.logName(); // 输出 \"My Object\"\n```\n\n```js\nvar obj = {\n  name: \"My Object\",\n  logName: function() {\n    // 保存 this 的值到变量 that\n    var that = this;\n    setTimeout(function() {\n      // 这里使用了保存的变量 that\n      console.log(that.name);\n    }, 1000);\n  }\n};\n\nobj.logName(); // 输出 \"My Object\"\n```\n\n```js\nfunction outerFunction() {\n  var outerVariable = 'I am from the outer function';\n  \n  // 内部函数引用了外部作用域中的变量 outerVariable\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n  \n  // 返回内部函数\n  return innerFunction;\n}\n\n// 调用外部函数，得到内部函数\nvar myFunction = outerFunction();\n\n// 调用内部函数\nmyFunction(); // 输出 \"I am from the outer function\"\n```","type":"text/markdown","created":"20231217044243193","creator":"oeyoews","modified":"20231217044612812","modifier":"oeyoews","tags":"JavaScript"},{"title":"闭包注意事项","text":"闭包是指在一个函数内部创建的函数，并且这个内部函数可以访问外部函数的变量和作用域。闭包可以在许多情况下非常有用，但如果不正确地使用闭包，可能会导致内存泄漏的问题。\r\n\r\n当一个函数形成闭包时，它会创建一个引用外部函数作用域的闭包环境。这意味着在闭包中引用的外部函数的变量和对象将被保存在内存中，而不会被垃圾回收机制清理掉。如果闭包持有大量的数据或者引用了很多对象，但不再使用它们，就会导致内存泄漏。\r\n\r\n以下是一些可能导致闭包内存问题的情况：\r\n\r\n1. 未正确释放闭包：如果闭包被长时间持有，而不被释放或不再需要，它会一直引用外部函数的作用域，导致相关的变量和对象无法被垃圾回收。\r\n\r\n2. 循环引用：如果闭包引用了外部函数中的对象，而这些对象又引用了闭包，就会形成循环引用，导致这些对象无法被垃圾回收。\r\n\r\n为避免闭包内存问题，可以采取以下措施：\r\n\r\n1. 避免不必要的闭包：仔细考虑是否真正需要闭包。如果没有必要访问外部函数的作用域，可以避免创建闭包。\r\n\r\n2. 及时释放闭包：当不再需要闭包时，确保及时解除对闭包的引用，以便让垃圾回收机制回收相关的内存。\r\n\r\n3. 减少闭包中的引用数量：尽量减少闭包中引用的变量和对象的数量，特别是大型对象或数据结构。在闭包中引用的对象如果不再使用，应该主动释放对它们的引用。\r\n\r\n4. 注意循环引用：避免形成循环引用的情况，确保对象之间的引用关系能够被垃圾回收。\r\n\r\n正确使用闭包并合理处理闭包的引用可以帮助避免内存泄漏问题。注意在编写代码时考虑内存管理，并且进行适当的测试和性能分析，以确保不会出现潜在的内存泄漏情况。","type":"text/markdown","created":"20230625043330584","creator":"oeyoews","modified":"20230726045248269","modifier":"oeyoews","tags":"JavaScript"},{"title":"静态方法-实例方法-原型方法","text":"## 静态方法\r\n\r\n静态方法是属于类的方法，不需要实例化类就可以使用，可以直接通过类名调用。静态方法通常用于与类本身相关的操作，例如创建工具函数等。\r\n\r\n## 实例方法\r\n\r\n实例方法是属于类的实例的方法，需要实例化类后才能使用。实例方法通常用于处理类实例的属性和状态，例如对实例属性的修改、获取等操作。\r\n\r\n## 原型方法\r\n\r\n原型方法是属于类的原型的方法，需要实例化类后才能使用。原型方法通过类的原型对象来定义和访问。原型方法通常用于处理类实例的属性和状态，例如对实例属性的修改、获取等操作。\r\n\r\n总之，静态方法、实例方法和原型方法都是类中定义的方法，主要区别在于访问方式和用途。其中静态方法是属于类本身的方法，实例方法和原型方法是属于类的实例的方法，且原型方法的效率通常比实例方法高。\r\n\r\n好的，以下是举例说明静态方法、实例方法和原型方法的区别：\r\n\r\n1. 静态方法\r\n\r\n静态方法通常用于创建工具函数或者实现一些通用的操作。例如，假设我们需要实现一个计算两个数之和的函数，可以使用静态方法来实现：\r\n\r\n```js\r\n// es6\r\nclass MathUtils {\r\n  static add(a, b) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\n// es5\r\nfunction MathUtils() {}\r\n\r\n// static method\r\nMathUtils.add = function () {\r\n  return a + b;\r\n};\r\n\r\n// test\r\nconst sum = MathUtils.add(1, 2);\r\nconsole.log(sum); // 3\r\n```\r\n\r\n在上面的代码中，`add`是一个静态方法，可以直接通过类名调用。\r\n\r\n2. 实例方法\r\n\r\n实例方法通常用于处理类实例的属性和状态。例如，假设我们需要实现一个表示人的类，并实现一个方法来输出人的名字：\r\n\r\n```js\r\n// es6\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  sayHello() {\r\n    console.log(`Hello, my name is ${this.name}`);\r\n  }\r\n}\r\n\r\n// es5\r\nfunction Person {\r\n\tthis.sayHello = function() {\r\n\t\tconsole.log('xxx')\r\n\t}\r\n}\r\n\r\n// 构造函数中定义的方法会在每个实例中复制一份\r\nconst john = new Person('John');\r\n// instance method\r\njohn.sayHello = function() {\r\n\tconsole.log('xxx')\r\n}\r\njohn.sayHello(); // Hello, my name is John\r\n```\r\n\r\n在上面的代码中，`sayHello`是一个实例方法，只能通过类的实例来调用。\r\n\r\n3. 原型方法\r\n\r\n原型方法通常用于处理类实例的属性和状态，与实例方法类似。例如，假设我们需要实现一个表示人的类，并实现一个方法来输出人的名字：\r\n\r\n```js\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nPerson.prototype.sayHello = function () {\r\n  console.log(`Hello, my name is ${this.name}`);\r\n};\r\n\r\nconst john = new Person('John');\r\njohn.sayHello(); // Hello, my name is John\r\n```\r\n\r\n在上面的代码中，`sayHello`是一个原型方法，可以通过类的实例来调用，与实例方法类似。区别是原型方法通过类的原型对象来定义和访问。\r\n\r\n## 静态属性\r\n\r\n静态属性是属于类本身的属性，不需要实例化类就可以使用，可以直接通过类名调用。静态属性通常用于存储类的元信息或者与类本身相关的数据。\r\n\r\n## 原型属性\r\n\r\n原型属性是属于类的原型的属性，需要实例化类后才能使用。原型属性通过类的原型对象来定义和访问。原型属性通常用于存储类的共享数据或者与类实例相关的数据。\r\n\r\n## 实例属性\r\n\r\n实例属性是属于类实例的属性，需要实例化类后才能使用。实例属性通常用于存储类实例的数据和状态。\r\n\r\n以下是一个使用 ES6 语法定义静态属性、原型属性和实例属性的例子：\r\n\r\n```js\r\nclass Person {\r\n  // 静态属性\r\n  static COUNT = 0;\r\n\r\n  // 原型属性\r\n  logging = {\r\n    name: 'name',\r\n    age: 20,\r\n  };\r\n\r\n  constructor(name, age) {\r\n    // 实例属性\r\n    this.name = name;\r\n    this.age = age;\r\n    Person.COUNT++; // 计数器自增\r\n  }\r\n}\r\n\r\nconst p1 = new Person('demo', 20);\r\nconst p2 = new Person('demo1', 21);\r\nconsole.log(Person.COUNT); // 输出 2\r\nconsole.log(p1.logging); // 输出 { name: 'name', age: 20 }\r\nconsole.log(p2.logging); // 输出 { name: 'name', age: 20 }\r\n```\r\n\r\n在上面的代码中，我们使用 ES6 语法定义了一个`Person`类，包含了静态属性、原型属性和实例属性。静态属性通过`static`关键字来定义，原型属性和实例属性则直接在类的构造函数中定义。我们创建了两个`Person`类的实例，每创建一个实例，静态属性`COUNT`都会自增 1。我们还输出了每个实例的`logging`属性，可以看到它是原型属性，可以被所有实例共享。\r\n","type":"text/markdown","created":"20230607142246917","creator":"oeyoews","modified":"20230726045248310","modifier":"oeyoews","tags":"JavaScript"},{"title":"静态方法-实例方法-原型方法01","text":"> https://es6.ruanyifeng.com/#docs/class\n\n1. 静态属性\n\nES5 中通常使用类的构造函数来定义静态属性：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.COUNT = 0;\n```\n\nES6 中使用`static`关键字来定义静态属性：\n\n```js\nclass Person {\n  static COUNT = 0;\n\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    Person.COUNT++;\n  }\n}\n```\n\n2. 原型属性\n\nES5 中通常使用类的原型对象来定义原型属性：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.logging = {\n  name: 'name',\n  age: 20,\n};\n```\n\nES6 中可以直接在类的构造函数中定义原型属性：\n\n```js\nclass Person {\n  logging = {\n    name: 'name',\n    age: 20,\n  };\n\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n```\n\n3. 实例属性\n\nES5 中通常在类的构造函数中使用`this`关键字来定义实例属性：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n```\n\nES6 中也是在类的构造函数中定义实例属性：\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n```\n\n4. 静态方法\n\nES5 中可以使用类的构造函数来定义静态方法：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.hello = function() {\n  console.log('hello method');\n};\n```\n\nES6 中使用`static`关键字来定义静态方法：\n\n```js\nclass Person {\n  static hello() {\n    console.log('hello method');\n  }\n\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n```\n\n5. 原型方法\n\nES5 中可以使用类的原型对象来定义原型方法：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.log = function() {\n  console.log('log method');\n};\n```\n\nES6 中可以直接在类的原型对象上定义原型方法：\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  log() {\n    console.log('log method');\n  }\n}\n```\n\n6. 实例方法\n\nES5 中可以在类的构造函数中使用`this`关键字来定义实例方法：\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n\n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\n```\n\nES6 中也是在类的构造函数中定义实例方法：\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  sayHello() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n```\n\n以上是 ES5 和 ES6 中定义静态属性、原型属性、实例属性、静态方法、原型方法和实例方法的对比。总的来说，ES6 语法更加简洁明了，同时也提供了更多的语法糖和特性。","type":"text/markdown","created":"20230607150354831","creator":"oeyoews","modified":"20240124091832483","modifier":"oeyoews","tags":"JavaScript"}]