{
    "title": "$:/plugins/oeyoews/codemirror-keymap-vimjk",
    "name": "CodeMirror Keymap VimJK",
    "description": "VimJK",
    "author": "oeyoews",
    "version": "v0.1.4",
    "core-version": "5.2.3",
    "source": "",
    "list": "readme",
    "parent-plugin": "$:/plugins/tiddlywiki/codemirror",
    "dependents": "$:/plugins/tiddlywiki/codemirror-search-replace $:/plugins/tiddlywiki/codemirror-closebrackets",
    "plugin-type": "plugin",
    "type": "application/json",
    "text": "{\"tiddlers\":{\"$:/plugins/oeyoews/codemirror-keymap-vimjk/readme\":{\"title\":\"$:/plugins/oeyoews/codemirror-keymap-vimjk/readme\",\"text\":\"<a style=\\\"text-decoration:none;\\\" href=\\\"https://github.com/oeyoews/neotw\\\" target=\\\"_blank\\\">\\n  <img src=\\\"https://img.shields.io/badge/Powered by-Neotw-green?style=flat\\\" />\\n</a>\\n<$image source={{{ [[][https://img.shields.io/badge/Version-]] [<currentTiddler>get[version]] [[-red?style=flat&logo=dev.to&logoColor=red]] +[join[]]}}} />\\n<$image source={{{ [[][https://img.shields.io/badge/Author-]] [<currentTiddler>get[author]] [[-lightblue?style=flat]] +[join[]]}}} />\\n\\nOverwrite codemirror-keymap-vim by [[@oeyoews|https://github.com/oeyoews]]\\n\\n* support `jk` mapping\\n* support H L replace 0 $\\n\"},\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/nvim\":{\"title\":\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/nvim\",\"text\":\"<svg stroke=\\\"currentColor\\\" fill=\\\"currentColor\\\" stroke-width=\\\"0\\\" role=\\\"img\\\" viewBox=\\\"0 0 24 24\\\" height=\\\"1em\\\" width=\\\"1em\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><title></title><path d=\\\"M2.214 4.954v13.615L7.655 24V10.314L3.312 3.845 2.214 4.954zm4.999 17.98l-4.557-4.548V5.136l.59-.596 3.967 5.908v12.485zm14.573-4.457l-.862.937-4.24-6.376V0l5.068 5.092.034 13.385zM7.431.001l12.998 19.835-3.637 3.637L3.787 3.683 7.43 0z\\\"></path></svg>\\n\"},\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/vim\":{\"title\":\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/vim\",\"text\":\"<svg stroke=\\\"currentColor\\\" fill=\\\"gray\\\" stroke-width=\\\"0\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 34 32\\\" height=\\\"1em\\\" width=\\\"1em\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M18.752 19.442c0.042 0.042 0.125 0.105 0.188 0.105h1.109c0.063 0 0.146-0.063 0.188-0.105l0.293-0.314c0.042-0.042 0.063-0.084 0.063-0.125l0.314-1.067c0.021-0.105 0-0.209-0.063-0.272l-0.23-0.188c-0.042-0.042-0.125-0.021-0.188-0.021h-1.004l-0.063-0.063c-0.042 0-0.084-0.021-0.126 0.021l-0.398 0.251c-0.042 0-0.063 0.105-0.084 0.146l-0.335 1.025c-0.042 0.105-0.021 0.23 0.063 0.314l0.272 0.293zM18.919 24.966l-0.084 0.021h-0.251l1.507-4.415c0.042-0.146-0.021-0.314-0.167-0.356l-0.084-0.021h-2.532c-0.105 0.021-0.188 0.105-0.209 0.209l-0.146 0.523c-0.042 0.146 0.063 0.272 0.209 0.314l0.063-0.021h0.377l-1.528 4.373c-0.042 0.146 0.021 0.335 0.167 0.398l0.084 0.063h2.344c0.125 0 0.23-0.105 0.272-0.23l0.146-0.502c0.063-0.147-0.021-0.314-0.167-0.356v0zM30.031 20.844l-0.398-0.523v-0.021c-0.063-0.063-0.125-0.125-0.209-0.125h-1.507c-0.084 0-0.146 0.084-0.209 0.125l-0.419 0.502h-0.649l-0.439-0.502v-0.021c-0.042-0.063-0.126-0.105-0.209-0.105h-0.837l4.227-4.227-4.729-4.687 4.227-4.352v-1.883l-0.586-0.753h-8.558l-0.691 0.732v0.607l-2.365-2.385-1.611 1.569-0.502-0.523h-8.454l-0.67 0.774v1.967l0.628 0.607h0.628v5.461l-2.929 2.929 2.929 2.93v6.696l1.088 0.607h2.427l1.904-1.988 4.52 4.52 3.034-3.034c0.021 0.084 0.084 0.105 0.188 0.146l0.084-0.042h1.967c0.126 0 0.23-0.021 0.251-0.125l0.146-0.418c0.042-0.146-0.021-0.272-0.167-0.314l-0.084 0.021h-0.084l0.712-2.239 0.481-0.481h1.046l-1.046 3.327c-0.042 0.146 0.042 0.23 0.188 0.293l0.084-0.042h1.904c0.105 0 0.209-0.021 0.251-0.125l0.167-0.377c0.063-0.146-0.021-0.272-0.146-0.335-0.021-0.021-0.063 0-0.105 0h-0.084l0.879-2.72h1.276l-1.067 3.327c-0.042 0.146 0.042 0.23 0.188 0.272l0.084-0.063h2.093c0.105 0 0.209-0.021 0.251-0.125l0.167-0.418c0.063-0.146-0.021-0.272-0.167-0.314-0.021-0.021-0.063 0.021-0.105 0.021h-0.146l1.172-3.871c0.042-0.105 0.021-0.23-0.021-0.293v0zM16.68 3.623l2.365 2.365v0.984l0.711 0.858h0.335l-6.068 5.859v-5.859h0.691l0.565-0.879v-1.862l-0.042-0.063 1.444-1.402zM4.167 16.010l2.532-2.532v5.064l-2.532-2.532zM12.307 24.025l12.22-12.555 4.478 4.499-4.227 4.227h-0.021c-0.063 0.021-0.105 0.063-0.146 0.105l-0.439 0.502h-0.607l-0.46-0.502c-0.042-0.063-0.126-0.125-0.209-0.125h-1.841c-0.125 0-0.23 0.084-0.272 0.209l-0.167 0.523c-0.042 0.146 0.021 0.272 0.167 0.335h0.314l-1.339 3.955-3.16 3.181-4.29-4.352z\\\"></path></svg>\\n\"},\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon\":{\"title\":\"$:/plugins/oeyoews/codemirror-keymap-vimjk/icon\",\"caption\":\"vim\",\"tags\":\"$:/tags/Image\",\"type\":\"image/png\",\"text\":\"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAADsQAAA7EB9YPtSQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA5/SURBVHic7Z17eFT1mcc/75mEhABeENF62/XOrnehIkIwkQRXWHWlC60X7MOyrtL1hkHF3cea3a6u2qvWS1lWXa0KT2wf8fIQDSipSKKSoIjWuhapN1TE9RJbSTLz++4fM6GREjhzO3Nmej5PHiZzTubM+/4+X85l5swZiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIKCms0AVE9EOyCQ++vVvf3WffOOAzGs3l8ymjABSAcU3vDI4l4mNxNgE4AhiFtI9gBJKX/CuBcKBNwCakDcALclraNuuwl3JVS9EEYHqTYh/vGh9vcpMQBwNDER87tNlMr/Wae3Ll3wx5v9B1DsToxzZWVXUlpoGmC01GVIKSM6Xkb0rdT8rnT+anpgv92nP8uPztjf/T2lgbz6au0Adg8pMaGSd+icEsnPaFAQdLiBecucbWqUOfKFjB21Dd9P6eJHovR1wo2GNAuT7lf+XWeMUSzFo1e1RHpvWFNgA1K7RbrDt+LcYcpMF9TQ84WNo6F3O66ekzhs4vRN191NyzoTJRUT4X03xJuySn5lA+oOTjuiU3+7nZRzyQSZ2hC8D0JsU+3sVdYLjvASP6N+1Hft98ocbW04f9W8DlAzBx0XvHOdx9BkdqZ3Kzk9833WHuvPZ/OHJRurWGKgD1Lb0nO3m3Ind0ckpm8vsmyjSx9fRdng2uA6he/O4cpFuA8oDk903f4uGqV80+Kq3NQSgCcPpjqvr9oMSNBhcjpWrKSj6pf9aO2DJs9EMzLJHvHqY3KfZB4r3bQBclywlUfupxeqXy3c3HpbNj6KXVZR6ob9H4Lwcl1hpckmP5SDrmo8Fdp+e7h+lNin0Q33hvYeUDcGT3fntclE7tBQvAaUtVMakl8QOnxDOCQ7Y3KFnKT052Lq0BSRvJPoy/dzfmzv3K8wYuPzVdzJ3e1BTzW35BAnDqEzqkt8ytQmoAvLzJR0jU1z32fwfkq5fqRe82ynT+ts9bEPnJfg9659NRk/3WH3gA6pbFp8U9t1rSaGC7g5Ir+QgMefFe8rIZqF707lSMa7f3vIWQ/8f5OstvD4EFYFybBtctSyyQ7JdIyde78yx/663lPgATmjYeALoPsHDJB6QpfvsIJAB1y3VQ1ReuXeKftg5GUPKTj6ypado0NGcNSWbx+F3A8BDKR7Dv+LvW7OOnlbwHoL5Fk3FuNXBMgeSDVKGYV5+rniYueu98zOpCKh8QvT3e8X56yV8AJKtv0dXCLRUML6D85OwcbQbqmtbvKtP3wywfgee5g/z0U+ar6zSpWaGhZct0t9D0rwxGoeQnp09BMsz6JmZET7ziSuH23F49YZEPQtL+fvrJ+Rpg8pPaP9arZwmXfEB71fzy48Oz6W3Sg2/u5XCXb6+eMMkHwGmkn55yGoD6Fh3rTKsMHRMy+QA4c+Oz6W+LlV0KDAm9fAnzvMF+espZAOqWaZrQKtD+YZSfGqyMA1DTtGmoiTnFIB/AOVflp6+cBKC+RVcjPQSqCrF8TMo4AIneLTNBuxeD/NRy+xa+Q7IKQM0KldUtS9whdCPIC7N8JBCH1TRt2juTXmWaXUTyEer201fGAZj6uHYvi6sF2Zw/kRBG+fT9vcal2+uExW8egxhdLPJBmGyLn94yCsCpT+iQ7gq1I2qLST4CKYMdQVc2vpjkI8ASG/20lnYAJi1XdSKmdsThxSYfBEZ1uj0biVd3utz+8wstH4G8t/30llYAJi3XuSYtQ8lz9YpOfnK5x6f7vsDKcw78laQ5gueQlsn4D7nE35m8E53pUIu5gz3TaMFM0N2ILwsqPzlKb/npzfcpYZOW6xqTrkdYEctPNi1OfeZb+7T47T1dah58fURPD/cg/e2A/fSvN8fykXAx76iOOV9/ZWe1+loD1LfoLJNuKAX5qfsT/fSdKa3nHL75s6r4N4C1hZAPfHLgHhte81OrrwDI09nbleBP/mbQIkn/LrQA+KSg8gWORF4DAPDqjCN6hG7eYb35kY8z/eqhGTN8nQjr680gOXVb39P4lC9pg2E3V1jFPc1TbOsxafXSrmvLEt4ScCcVQj4Ik51Qc8+GytZZB/o6VMoUQZsFLF8IS2iF3xr97QR63h0C51P+FyYuV1XlYU9PrfxZf/kAK6cM+0jxnqk4/rcQ8lO3FYmKsrG+es+C3h7vi6DlI3CW4wA8VWftJq7r/2QDSFqKdORTUytvaa21Ac9Nbz1r908NLkj2FLh8AJyU981AzNOwoOWD1ndePG6nO399+D4MXD7Zux5pybZFpCR8acZFT0+pnPr01MG+Dj+ePnPYM0iLt11eEPIlYZbfHUGAslji6K/Um3/5CH6ezjkP/l8HMNMgV/Zt0IvbSFpn2JinTqtc4HtZW5fpXS/kgpafmj9u9IKO8rRrTgMnqoOUj5DF4z9Pp8a0XghqnmKfb+kuPxnT1Q7dZU4Xu8EVJzw1peLX6SynjxVnDHsV2eMFkA9iSMWwEWMyqdsPp936RoWhmQHKB9PK1XOr30ynzrRPCVt1pnUBN6f7uIEwl1iI2RkByweEJ5sItOeql/58MqTn7xEjA5OPkLg33ToL/tnAPeO7N4PeCVp+8m4i7fcFfNEoD+mqIOUDm8rjpP3x8IIH4KEZlpCxOHj5AmzC9Cb5/hydX8bu9+oM0NEBygf00/YrTvoy3VoLHgAAL8Ejyd+Ck6/k/F3f711/bC57md7UFDPTdYHKl7q2lLnbM6k3FAFYsW73dtCHQcrf+rJpgkm57OXtz0adj2NUgPIRLFz3nepPMqk3FAGg0RzSY0HLB2FmOQtAze2vDvWw6wOW3yt0S6Y1hyMAgFlqMxCg/NR2YMJpt75RkYsetlQkrhb6WoDyMbk7Oy+b4Ovkj+0RmgAMrvx0GVJXoPKT/1R1DSPt8wS3ZezCtfshrghSPqiru9e7Ppu6QxOA5imHdguWBSwfJJypLtv6DbsJURWgfAQ3vHzl+E3Z1B2aAKR4NHkTnHwBWHY7gicuXFeDODtI+Yi3ByW8jLf9fYQqAHHPNdP/vQECkJ+cPmb0gvW7ZlJzTeOKMqRbIHWBq2DkY7h/zeS4f1tCFYC2aXtvQqwJWD6gsspBiYzWAt37Dp8LGvhdv3515Eo+uNWrP61+MJN6tyVUAQAwUzMEKj/146amW+vYhWv3k/jugMvtV0fu5CvhzObk6jLyoQsA8pqDlg/CSF0/IA08cRswNED5gH665rLqznTq3GEPuVpQrhjJyBeAj4OUD+Ckvcfe+xtfl1UBGLdw7dmCM4OVz/va0t3ot0Y/hC4Aycu6qiVI+X3L9Ry+NgOjF3SMkPhJwPKR9J3O+fWf+anRL6ELAICcNQctPzldvgJQboNuRxoZpHzQ0s65E5f4qS8dQhkAi9kTJL8uBQhKPoDGjF24bq8d1Tbuv146C7kZgcqXPrOE8nLJ21AGYOWMr30Erh0ClQ/gmefNGKiuk+5cO1LizoDlg9mlqxtOfmegurIhlAEAMFhSiEuxIZ03UE3OcwsFewUqHx7puLz6voFqypbQBiBuPJz8LTj5qb84YdyCl0dtW8+JP3vpIpE8dzFA+R/FrOfCHQxT1oQ2AG3fOmA9aF3A8pM/Mc7tX8uJCzv/SsYPApYPTv/4/OV1H+50sLIgtAEAMNmSoOWDwGlm32cGTrjt+T3kYo+ChgQs/+6OhpMf9T1YGRLuAHguuRkIUn5ywl+UWfkFoxd0VNmgil+ADglUvvRmrLxiru+ByoJQfGfQjhh//4YNwF8GJ3/r/C8FH4AODFh+D1h1xxUTX/A/SpkT6jVAiiUFkI9gcAHkAzY/KPlQBAGQacdHA/mRv93pO1tu8l7m8oUe75hb/RPfg5MDQh+AtnMOXInpd6Uvn3dxmpXt1czTJfQBwEzmaCpx+XGcO7tzXu3mNEcna8IfAACz5NkvpSkfoes659UG+g2nfRRFAJ6dedBapFdKUT7iyYP323RT2oOSI4oiACkWlZx89Dq9Pd/0e0WvfFA0AVBZ7IGtI14a8ruc86bl+gSPdCmaALSde9BbhtpKRL6TdM6L8yZmdGWVXFI0AQBAdn8JyEeOa9c01D6e4SjklOIKgHMPAF3FLB/x8JqGk/8z4zHIMUUVgFWzR3VJSn0gogjlw8u9rntm0C/27IiiCgCAi9kdRSlfbHQuccbLV576+yyHIKcUXQCe//aolxHtRSb/c4eb8uK8Sb4uohkkRRcAABN3AsUiv8fz9I0XG05Zm33nuacoA7DrH8qbQJuKQL4Dzls9t3Z5LvrOB0UZgOZLD+12zu4NuXyEGjobah7KVd/5oCgDAGBlPXcg4mGVD7ppTUNtoO/tZ0LRBuC5Wcf9DrQ4lPKlH3Y21M7PVa/5pGgDkMRuACU/Jx8S+Sb3/c55tfNy2mYeKeoAPHfBUa+BPRIW+eC+1zHvlKty22V+KeoAAJj4F7H9fYHkTXDb/M6GU76b8wbzTNEHoP3Co39j6IECyhdofrFs87el6AMA4PXqOlDyG8CClf8H4JudDbUFO6MnW0oiAG0XH/+WzG4MWP77nqgJ+3H+ziiJAADs0T30RuD1QOQ7XqKs98TV82pW57GlQCiZADRfemg3TnMgdWWRPMk3cT/DusZ3Xlaf8QWaw0ToPxuYLl+/o+MGk67Jg/zPzXFxx7yatL6VK+yUzBqgDxfjOlAbkDP5Mj3qyY4sNflQgmsASF7GLdabeBY4PEv5vxW6as0VNQ8HWX+QlNwaAKDzwjGby4ifKlifmXzeEvpnhgz561KWDyW6Buhj3I/ahsfLbTGi3of8BKIV+O+hnyd+0dpYO+B3H5cSJR0AABrljRneNs2wa5CO7ye/F/RbsE5ItCZiseYXL5mwscDVBk7pB6Afx/54xW7llA13ifjnw77g0z+X/+URERERERERERERERERERERERERERERERERERERERERERF/Rvw/hxqNeyK/yBgAAAAASUVORK5CYII=\\n\"},\"$:/core/ui/Buttons/edit\":{\"title\":\"$:/core/ui/Buttons/edit\",\"tags\":\"$:/tags/ViewToolbar\",\"description\":\"Code edit\",\"caption\":\"{{$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/vim}} edit\",\"list-before\":\"$:/core/ui/Buttons/close\",\"text\":\"\\\\whitespace trim\\n<$button message=\\\"tm-edit-tiddler\\\" tooltip={{$:/language/Buttons/Edit/Hint}} aria-label={{$:/language/Buttons/Edit/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/plugins/oeyoews/codemirror-keymap-vimjk/icon/vim}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text={{$:/language/Buttons/Edit/Caption}}/>\\n</span>\\n</$list>\\n</$button>\\n\"},\"$:/plugins/tiddlywiki/codemirror/keymap/vim.js\":{\"title\":\"$:/plugins/tiddlywiki/codemirror/keymap/vim.js\",\"module-type\":\"codemirror\",\"type\":\"application/javascript\",\"text\":\"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: https://codemirror.net/LICENSE\\n!(function (e) {\\n  \\\"object\\\" == typeof exports && \\\"object\\\" == typeof module\\n    ? e(\\n        require(\\\"../lib/codemirror\\\"),\\n        require(\\\"../addon/search/searchcursor\\\"),\\n        require(\\\"../addon/dialog/dialog\\\"),\\n        require(\\\"../addon/edit/matchbrackets.js\\\")\\n      )\\n    : \\\"function\\\" == typeof define && define.amd\\n    ? define(\\n        [\\n          \\\"../lib/codemirror\\\",\\n          \\\"../addon/search/searchcursor\\\",\\n          \\\"../addon/dialog/dialog\\\",\\n          \\\"../addon/edit/matchbrackets\\\",\\n        ],\\n        e\\n      )\\n    : e(CodeMirror);\\n})(function (Ze) {\\n  \\\"use strict\\\";\\n  var Ge = [\\n      { keys: \\\"<Left>\\\", type: \\\"keyToKey\\\", toKeys: \\\"h\\\" },\\n      { keys: \\\"<Right>\\\", type: \\\"keyToKey\\\", toKeys: \\\"l\\\" },\\n      { keys: \\\"<Up>\\\", type: \\\"keyToKey\\\", toKeys: \\\"k\\\" },\\n      { keys: \\\"<Down>\\\", type: \\\"keyToKey\\\", toKeys: \\\"j\\\" },\\n      { keys: \\\"<Space>\\\", type: \\\"keyToKey\\\", toKeys: \\\"l\\\" },\\n      { keys: \\\"<BS>\\\", type: \\\"keyToKey\\\", toKeys: \\\"h\\\", context: \\\"normal\\\" },\\n      { keys: \\\"<Del>\\\", type: \\\"keyToKey\\\", toKeys: \\\"x\\\", context: \\\"normal\\\" },\\n      { keys: \\\"<C-Space>\\\", type: \\\"keyToKey\\\", toKeys: \\\"W\\\" },\\n      { keys: \\\"<C-BS>\\\", type: \\\"keyToKey\\\", toKeys: \\\"B\\\", context: \\\"normal\\\" },\\n      { keys: \\\"<S-Space>\\\", type: \\\"keyToKey\\\", toKeys: \\\"w\\\" },\\n      { keys: \\\"<S-BS>\\\", type: \\\"keyToKey\\\", toKeys: \\\"b\\\", context: \\\"normal\\\" },\\n      { keys: \\\"<C-n>\\\", type: \\\"keyToKey\\\", toKeys: \\\"j\\\" },\\n      { keys: \\\"<C-p>\\\", type: \\\"keyToKey\\\", toKeys: \\\"k\\\" },\\n      { keys: \\\"jk\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\" },\\n      { keys: \\\"<C-[>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\" },\\n      { keys: \\\"<C-c>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\" },\\n      { keys: \\\"jk\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\", context: \\\"insert\\\" },\\n      { keys: \\\"<C-[>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\", context: \\\"insert\\\" },\\n      { keys: \\\"<C-c>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<Esc>\\\", context: \\\"insert\\\" },\\n      { keys: \\\"s\\\", type: \\\"keyToKey\\\", toKeys: \\\"cl\\\", context: \\\"normal\\\" },\\n      { keys: \\\"s\\\", type: \\\"keyToKey\\\", toKeys: \\\"c\\\", context: \\\"visual\\\" },\\n      { keys: \\\"H\\\", type: \\\"keyToKey\\\", toKeys: \\\"0\\\", context: \\\"normal\\\" },\\n      { keys: \\\"L\\\", type: \\\"keyToKey\\\", toKeys: \\\"$\\\", context: \\\"normal\\\" },\\n      { keys: \\\"S\\\", type: \\\"keyToKey\\\", toKeys: \\\"cc\\\", context: \\\"normal\\\" },\\n      { keys: \\\"S\\\", type: \\\"keyToKey\\\", toKeys: \\\"VdO\\\", context: \\\"visual\\\" },\\n      { keys: \\\"<Home>\\\", type: \\\"keyToKey\\\", toKeys: \\\"0\\\" },\\n      { keys: \\\"<End>\\\", type: \\\"keyToKey\\\", toKeys: \\\"$\\\" },\\n      { keys: \\\"<PageUp>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<C-b>\\\" },\\n      { keys: \\\"<PageDown>\\\", type: \\\"keyToKey\\\", toKeys: \\\"<C-f>\\\" },\\n      { keys: \\\"<CR>\\\", type: \\\"keyToKey\\\", toKeys: \\\"j^\\\", context: \\\"normal\\\" },\\n      {\\n        keys: \\\"<Ins>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"toggleOverwrite\\\",\\n        context: \\\"insert\\\",\\n      },\\n      {\\n        keys: \\\"H\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToTopLine\\\",\\n        motionArgs: { linewise: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"M\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToMiddleLine\\\",\\n        motionArgs: { linewise: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"L\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToBottomLine\\\",\\n        motionArgs: { linewise: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"h\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByCharacters\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"l\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByCharacters\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"j\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByLines\\\",\\n        motionArgs: { forward: !0, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"k\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByLines\\\",\\n        motionArgs: { forward: !1, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"gj\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByDisplayLines\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"gk\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByDisplayLines\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"w\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !0, wordEnd: !1 },\\n      },\\n      {\\n        keys: \\\"W\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !0, wordEnd: !1, bigWord: !0 },\\n      },\\n      {\\n        keys: \\\"e\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !0, wordEnd: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"E\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !0, wordEnd: !0, bigWord: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"b\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !1, wordEnd: !1 },\\n      },\\n      {\\n        keys: \\\"B\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !1, wordEnd: !1, bigWord: !0 },\\n      },\\n      {\\n        keys: \\\"ge\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !1, wordEnd: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"gE\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !1, wordEnd: !0, bigWord: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"{\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByParagraph\\\",\\n        motionArgs: { forward: !1, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"}\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByParagraph\\\",\\n        motionArgs: { forward: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"(\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveBySentence\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\")\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveBySentence\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"<C-f>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByPage\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"<C-b>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByPage\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"<C-d>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByScroll\\\",\\n        motionArgs: { forward: !0, explicitRepeat: !0 },\\n      },\\n      {\\n        keys: \\\"<C-u>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByScroll\\\",\\n        motionArgs: { forward: !1, explicitRepeat: !0 },\\n      },\\n      {\\n        keys: \\\"gg\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToLineOrEdgeOfDocument\\\",\\n        motionArgs: {\\n          forward: !1,\\n          explicitRepeat: !0,\\n          linewise: !0,\\n          toJumplist: !0,\\n        },\\n      },\\n      {\\n        keys: \\\"G\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToLineOrEdgeOfDocument\\\",\\n        motionArgs: {\\n          forward: !0,\\n          explicitRepeat: !0,\\n          linewise: !0,\\n          toJumplist: !0,\\n        },\\n      },\\n      { keys: \\\"0\\\", type: \\\"motion\\\", motion: \\\"moveToStartOfLine\\\" },\\n      {\\n        keys: \\\"^\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToFirstNonWhiteSpaceCharacter\\\",\\n      },\\n      {\\n        keys: \\\"+\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByLines\\\",\\n        motionArgs: { forward: !0, toFirstChar: !0 },\\n      },\\n      {\\n        keys: \\\"-\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByLines\\\",\\n        motionArgs: { forward: !1, toFirstChar: !0 },\\n      },\\n      {\\n        keys: \\\"_\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveByLines\\\",\\n        motionArgs: { forward: !0, toFirstChar: !0, repeatOffset: -1 },\\n      },\\n      {\\n        keys: \\\"$\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToEol\\\",\\n        motionArgs: { inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"%\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToMatchedSymbol\\\",\\n        motionArgs: { inclusive: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"f<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToCharacter\\\",\\n        motionArgs: { forward: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"F<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToCharacter\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"t<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveTillCharacter\\\",\\n        motionArgs: { forward: !0, inclusive: !0 },\\n      },\\n      {\\n        keys: \\\"T<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveTillCharacter\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\";\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"repeatLastCharacterSearch\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\",\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"repeatLastCharacterSearch\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"'<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"goToMark\\\",\\n        motionArgs: { toJumplist: !0, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"`<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"goToMark\\\",\\n        motionArgs: { toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"]`\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"jumpToMark\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"[`\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"jumpToMark\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"]'\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"jumpToMark\\\",\\n        motionArgs: { forward: !0, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"['\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"jumpToMark\\\",\\n        motionArgs: { forward: !1, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"]p\\\",\\n        type: \\\"action\\\",\\n        action: \\\"paste\\\",\\n        isEdit: !0,\\n        actionArgs: { after: !0, isEdit: !0, matchIndent: !0 },\\n      },\\n      {\\n        keys: \\\"[p\\\",\\n        type: \\\"action\\\",\\n        action: \\\"paste\\\",\\n        isEdit: !0,\\n        actionArgs: { after: !1, isEdit: !0, matchIndent: !0 },\\n      },\\n      {\\n        keys: \\\"]<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToSymbol\\\",\\n        motionArgs: { forward: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"[<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToSymbol\\\",\\n        motionArgs: { forward: !1, toJumplist: !0 },\\n      },\\n      { keys: \\\"|\\\", type: \\\"motion\\\", motion: \\\"moveToColumn\\\" },\\n      {\\n        keys: \\\"o\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToOtherHighlightedEnd\\\",\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"O\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"moveToOtherHighlightedEnd\\\",\\n        motionArgs: { sameLine: !0 },\\n        context: \\\"visual\\\",\\n      },\\n      { keys: \\\"d\\\", type: \\\"operator\\\", operator: \\\"delete\\\" },\\n      { keys: \\\"y\\\", type: \\\"operator\\\", operator: \\\"yank\\\" },\\n      { keys: \\\"c\\\", type: \\\"operator\\\", operator: \\\"change\\\" },\\n      { keys: \\\"=\\\", type: \\\"operator\\\", operator: \\\"indentAuto\\\" },\\n      {\\n        keys: \\\">\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"indent\\\",\\n        operatorArgs: { indentRight: !0 },\\n      },\\n      {\\n        keys: \\\"<\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"indent\\\",\\n        operatorArgs: { indentRight: !1 },\\n      },\\n      { keys: \\\"g~\\\", type: \\\"operator\\\", operator: \\\"changeCase\\\" },\\n      {\\n        keys: \\\"gu\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"changeCase\\\",\\n        operatorArgs: { toLower: !0 },\\n        isEdit: !0,\\n      },\\n      {\\n        keys: \\\"gU\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"changeCase\\\",\\n        operatorArgs: { toLower: !1 },\\n        isEdit: !0,\\n      },\\n      {\\n        keys: \\\"n\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"findNext\\\",\\n        motionArgs: { forward: !0, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"N\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"findNext\\\",\\n        motionArgs: { forward: !1, toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"gn\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"findAndSelectNextInclusive\\\",\\n        motionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"gN\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"findAndSelectNextInclusive\\\",\\n        motionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"x\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"delete\\\",\\n        motion: \\\"moveByCharacters\\\",\\n        motionArgs: { forward: !0 },\\n        operatorMotionArgs: { visualLine: !1 },\\n      },\\n      {\\n        keys: \\\"X\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"delete\\\",\\n        motion: \\\"moveByCharacters\\\",\\n        motionArgs: { forward: !1 },\\n        operatorMotionArgs: { visualLine: !0 },\\n      },\\n      {\\n        keys: \\\"D\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"delete\\\",\\n        motion: \\\"moveToEol\\\",\\n        motionArgs: { inclusive: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"D\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"delete\\\",\\n        operatorArgs: { linewise: !0 },\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"Y\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"yank\\\",\\n        motion: \\\"expandToLine\\\",\\n        motionArgs: { linewise: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"Y\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"yank\\\",\\n        operatorArgs: { linewise: !0 },\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"C\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"change\\\",\\n        motion: \\\"moveToEol\\\",\\n        motionArgs: { inclusive: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"C\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"change\\\",\\n        operatorArgs: { linewise: !0 },\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"~\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"changeCase\\\",\\n        motion: \\\"moveByCharacters\\\",\\n        motionArgs: { forward: !0 },\\n        operatorArgs: { shouldMoveCursor: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"~\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"changeCase\\\",\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"<C-w>\\\",\\n        type: \\\"operatorMotion\\\",\\n        operator: \\\"delete\\\",\\n        motion: \\\"moveByWords\\\",\\n        motionArgs: { forward: !1, wordEnd: !1 },\\n        context: \\\"insert\\\",\\n      },\\n      { keys: \\\"<C-w>\\\", type: \\\"idle\\\", context: \\\"normal\\\" },\\n      {\\n        keys: \\\"<C-i>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"jumpListWalk\\\",\\n        actionArgs: { forward: !0 },\\n      },\\n      {\\n        keys: \\\"<C-o>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"jumpListWalk\\\",\\n        actionArgs: { forward: !1 },\\n      },\\n      {\\n        keys: \\\"<C-e>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scroll\\\",\\n        actionArgs: { forward: !0, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"<C-y>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scroll\\\",\\n        actionArgs: { forward: !1, linewise: !0 },\\n      },\\n      {\\n        keys: \\\"a\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"charAfter\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"A\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"eol\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"A\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"endOfSelectedArea\\\" },\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"i\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"inplace\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"gi\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"lastEdit\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"I\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"firstNonBlank\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"gI\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"bol\\\" },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"I\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { insertAt: \\\"startOfSelectedArea\\\" },\\n        context: \\\"visual\\\",\\n      },\\n      {\\n        keys: \\\"o\\\",\\n        type: \\\"action\\\",\\n        action: \\\"newLineAndEnterInsertMode\\\",\\n        isEdit: !0,\\n        interlaceInsertRepeat: !0,\\n        actionArgs: { after: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"O\\\",\\n        type: \\\"action\\\",\\n        action: \\\"newLineAndEnterInsertMode\\\",\\n        isEdit: !0,\\n        interlaceInsertRepeat: !0,\\n        actionArgs: { after: !1 },\\n        context: \\\"normal\\\",\\n      },\\n      { keys: \\\"v\\\", type: \\\"action\\\", action: \\\"toggleVisualMode\\\" },\\n      {\\n        keys: \\\"V\\\",\\n        type: \\\"action\\\",\\n        action: \\\"toggleVisualMode\\\",\\n        actionArgs: { linewise: !0 },\\n      },\\n      {\\n        keys: \\\"<C-v>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"toggleVisualMode\\\",\\n        actionArgs: { blockwise: !0 },\\n      },\\n      {\\n        keys: \\\"<C-q>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"toggleVisualMode\\\",\\n        actionArgs: { blockwise: !0 },\\n      },\\n      { keys: \\\"gv\\\", type: \\\"action\\\", action: \\\"reselectLastSelection\\\" },\\n      { keys: \\\"J\\\", type: \\\"action\\\", action: \\\"joinLines\\\", isEdit: !0 },\\n      {\\n        keys: \\\"gJ\\\",\\n        type: \\\"action\\\",\\n        action: \\\"joinLines\\\",\\n        actionArgs: { keepSpaces: !0 },\\n        isEdit: !0,\\n      },\\n      {\\n        keys: \\\"p\\\",\\n        type: \\\"action\\\",\\n        action: \\\"paste\\\",\\n        isEdit: !0,\\n        actionArgs: { after: !0, isEdit: !0 },\\n      },\\n      {\\n        keys: \\\"P\\\",\\n        type: \\\"action\\\",\\n        action: \\\"paste\\\",\\n        isEdit: !0,\\n        actionArgs: { after: !1, isEdit: !0 },\\n      },\\n      { keys: \\\"r<character>\\\", type: \\\"action\\\", action: \\\"replace\\\", isEdit: !0 },\\n      { keys: \\\"@<character>\\\", type: \\\"action\\\", action: \\\"replayMacro\\\" },\\n      { keys: \\\"q<character>\\\", type: \\\"action\\\", action: \\\"enterMacroRecordMode\\\" },\\n      {\\n        keys: \\\"R\\\",\\n        type: \\\"action\\\",\\n        action: \\\"enterInsertMode\\\",\\n        isEdit: !0,\\n        actionArgs: { replace: !0 },\\n        context: \\\"normal\\\",\\n      },\\n      {\\n        keys: \\\"R\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"change\\\",\\n        operatorArgs: { linewise: !0, fullLine: !0 },\\n        context: \\\"visual\\\",\\n        exitVisualBlock: !0,\\n      },\\n      { keys: \\\"u\\\", type: \\\"action\\\", action: \\\"undo\\\", context: \\\"normal\\\" },\\n      {\\n        keys: \\\"u\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"changeCase\\\",\\n        operatorArgs: { toLower: !0 },\\n        context: \\\"visual\\\",\\n        isEdit: !0,\\n      },\\n      {\\n        keys: \\\"U\\\",\\n        type: \\\"operator\\\",\\n        operator: \\\"changeCase\\\",\\n        operatorArgs: { toLower: !1 },\\n        context: \\\"visual\\\",\\n        isEdit: !0,\\n      },\\n      { keys: \\\"<C-r>\\\", type: \\\"action\\\", action: \\\"redo\\\" },\\n      { keys: \\\"m<character>\\\", type: \\\"action\\\", action: \\\"setMark\\\" },\\n      { keys: '\\\"<character>', type: \\\"action\\\", action: \\\"setRegister\\\" },\\n      {\\n        keys: \\\"zz\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"center\\\" },\\n      },\\n      {\\n        keys: \\\"z.\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"center\\\" },\\n        motion: \\\"moveToFirstNonWhiteSpaceCharacter\\\",\\n      },\\n      {\\n        keys: \\\"zt\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"top\\\" },\\n      },\\n      {\\n        keys: \\\"z<CR>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"top\\\" },\\n        motion: \\\"moveToFirstNonWhiteSpaceCharacter\\\",\\n      },\\n      {\\n        keys: \\\"z-\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"bottom\\\" },\\n      },\\n      {\\n        keys: \\\"zb\\\",\\n        type: \\\"action\\\",\\n        action: \\\"scrollToCursor\\\",\\n        actionArgs: { position: \\\"bottom\\\" },\\n        motion: \\\"moveToFirstNonWhiteSpaceCharacter\\\",\\n      },\\n      { keys: \\\".\\\", type: \\\"action\\\", action: \\\"repeatLastEdit\\\" },\\n      {\\n        keys: \\\"<C-a>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"incrementNumberToken\\\",\\n        isEdit: !0,\\n        actionArgs: { increase: !0, backtrack: !1 },\\n      },\\n      {\\n        keys: \\\"<C-x>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"incrementNumberToken\\\",\\n        isEdit: !0,\\n        actionArgs: { increase: !1, backtrack: !1 },\\n      },\\n      {\\n        keys: \\\"<C-t>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"indent\\\",\\n        actionArgs: { indentRight: !0 },\\n        context: \\\"insert\\\",\\n      },\\n      {\\n        keys: \\\"<C-d>\\\",\\n        type: \\\"action\\\",\\n        action: \\\"indent\\\",\\n        actionArgs: { indentRight: !1 },\\n        context: \\\"insert\\\",\\n      },\\n      {\\n        keys: \\\"a<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"textObjectManipulation\\\",\\n      },\\n      {\\n        keys: \\\"i<character>\\\",\\n        type: \\\"motion\\\",\\n        motion: \\\"textObjectManipulation\\\",\\n        motionArgs: { textObjectInner: !0 },\\n      },\\n      {\\n        keys: \\\"/\\\",\\n        type: \\\"search\\\",\\n        searchArgs: { forward: !0, querySrc: \\\"prompt\\\", toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"?\\\",\\n        type: \\\"search\\\",\\n        searchArgs: { forward: !1, querySrc: \\\"prompt\\\", toJumplist: !0 },\\n      },\\n      {\\n        keys: \\\"*\\\",\\n        type: \\\"search\\\",\\n        searchArgs: {\\n          forward: !0,\\n          querySrc: \\\"wordUnderCursor\\\",\\n          wholeWordOnly: !0,\\n          toJumplist: !0,\\n        },\\n      },\\n      {\\n        keys: \\\"#\\\",\\n        type: \\\"search\\\",\\n        searchArgs: {\\n          forward: !1,\\n          querySrc: \\\"wordUnderCursor\\\",\\n          wholeWordOnly: !0,\\n          toJumplist: !0,\\n        },\\n      },\\n      {\\n        keys: \\\"g*\\\",\\n        type: \\\"search\\\",\\n        searchArgs: {\\n          forward: !0,\\n          querySrc: \\\"wordUnderCursor\\\",\\n          toJumplist: !0,\\n        },\\n      },\\n      {\\n        keys: \\\"g#\\\",\\n        type: \\\"search\\\",\\n        searchArgs: {\\n          forward: !1,\\n          querySrc: \\\"wordUnderCursor\\\",\\n          toJumplist: !0,\\n        },\\n      },\\n      { keys: \\\":\\\", type: \\\"ex\\\" },\\n    ],\\n    Ye = Ge.length,\\n    et = [\\n      { name: \\\"colorscheme\\\", shortName: \\\"colo\\\" },\\n      { name: \\\"map\\\" },\\n      { name: \\\"imap\\\", shortName: \\\"im\\\" },\\n      { name: \\\"nmap\\\", shortName: \\\"nm\\\" },\\n      { name: \\\"vmap\\\", shortName: \\\"vm\\\" },\\n      { name: \\\"unmap\\\" },\\n      { name: \\\"write\\\", shortName: \\\"w\\\" },\\n      { name: \\\"undo\\\", shortName: \\\"u\\\" },\\n      { name: \\\"redo\\\", shortName: \\\"red\\\" },\\n      { name: \\\"set\\\", shortName: \\\"se\\\" },\\n      { name: \\\"setlocal\\\", shortName: \\\"setl\\\" },\\n      { name: \\\"setglobal\\\", shortName: \\\"setg\\\" },\\n      { name: \\\"sort\\\", shortName: \\\"sor\\\" },\\n      { name: \\\"substitute\\\", shortName: \\\"s\\\", possiblyAsync: !0 },\\n      { name: \\\"nohlsearch\\\", shortName: \\\"noh\\\" },\\n      { name: \\\"yank\\\", shortName: \\\"y\\\" },\\n      { name: \\\"delmarks\\\", shortName: \\\"delm\\\" },\\n      { name: \\\"registers\\\", shortName: \\\"reg\\\", excludeFromCommandHistory: !0 },\\n      { name: \\\"global\\\", shortName: \\\"g\\\" },\\n    ],\\n    tt = Ze.Pos;\\n  Ze.Vim = (function () {\\n    function e(e, t) {\\n      var r, n;\\n      this == Ze.keyMap.vim &&\\n        (Ze.rmClass(e.getWrapperElement(), \\\"cm-fat-cursor\\\"),\\n        \\\"contenteditable\\\" == e.getOption(\\\"inputStyle\\\") &&\\n          null != document.body.style.caretColor &&\\n          (a((r = e)),\\n          r.off(\\\"cursorActivity\\\", i),\\n          (r.state.fatCursorMarks = null),\\n          (e.getInputField().style.caretColor = \\\"\\\"))),\\n        (t && t.attach == o) ||\\n          ((n = e).setOption(\\\"disableInput\\\", !1),\\n          n.off(\\\"cursorActivity\\\", Ue),\\n          Ze.off(n.getInputField(), \\\"paste\\\", c(n)),\\n          (n.state.vim = null));\\n    }\\n    function o(e, t) {\\n      var r, n;\\n      this == Ze.keyMap.vim &&\\n        (Ze.addClass(e.getWrapperElement(), \\\"cm-fat-cursor\\\"),\\n        \\\"contenteditable\\\" == e.getOption(\\\"inputStyle\\\") &&\\n          null != document.body.style.caretColor &&\\n          (((r = e).state.fatCursorMarks = []),\\n          i(r),\\n          r.on(\\\"cursorActivity\\\", i),\\n          (e.getInputField().style.caretColor = \\\"transparent\\\"))),\\n        (t && t.attach == o) ||\\n          ((n = e).setOption(\\\"disableInput\\\", !0),\\n          n.setOption(\\\"showCursorWhenSelecting\\\", !1),\\n          Ze.signal(n, \\\"vim-mode-change\\\", { mode: \\\"normal\\\" }),\\n          n.on(\\\"cursorActivity\\\", Ue),\\n          E(n),\\n          Ze.on(n.getInputField(), \\\"paste\\\", c(n)));\\n    }\\n    function i(e) {\\n      if (e.state.fatCursorMarks) {\\n        a(e);\\n        for (var t = e.listSelections(), r = [], n = 0; n < t.length; n++) {\\n          var o,\\n            i = t[n];\\n          i.empty() &&\\n            ((o = e.getLine(i.anchor.line).length),\\n            i.anchor.ch < o\\n              ? r.push(\\n                  e.markText(i.anchor, tt(i.anchor.line, i.anchor.ch + 1), {\\n                    className: \\\"cm-fat-cursor-mark\\\",\\n                  })\\n                )\\n              : r.push(\\n                  e.markText(tt(i.anchor.line, o - 1), tt(i.anchor.line, o), {\\n                    className: \\\"cm-fat-cursor-mark\\\",\\n                  })\\n                ));\\n        }\\n        e.state.fatCursorMarks = r;\\n      }\\n    }\\n    function a(e) {\\n      var t = e.state.fatCursorMarks;\\n      if (t) for (var r = 0; r < t.length; r++) t[r].clear();\\n    }\\n    function t(e, t) {\\n      if (t) {\\n        if (this[e]) return this[e];\\n        var r = (function (e) {\\n          if (\\\"'\\\" == e.charAt(0)) return e.charAt(1);\\n          var t = e.split(/-(?!$)/),\\n            r = t[t.length - 1];\\n          {\\n            if (1 == t.length && 1 == t[0].length) return !1;\\n            if (2 == t.length && \\\"Shift\\\" == t[0] && 1 == r.length) return !1;\\n          }\\n          for (var n = !1, o = 0; o < t.length; o++) {\\n            var i = t[o];\\n            i in s ? (t[o] = s[i]) : (n = !0), i in l && (t[o] = l[i]);\\n          }\\n          if (!n) return !1;\\n          k(r) && (t[t.length - 1] = r.toLowerCase());\\n          return \\\"<\\\" + t.join(\\\"-\\\") + \\\">\\\";\\n        })(e);\\n        if (!r) return !1;\\n        var n = Ze.Vim.findKey(t, r);\\n        return \\\"function\\\" == typeof n && Ze.signal(t, \\\"vim-keypress\\\", r), n;\\n      }\\n    }\\n    Ze.defineOption(\\\"vimMode\\\", !1, function (e, t, r) {\\n      t && \\\"vim\\\" != e.getOption(\\\"keyMap\\\")\\n        ? e.setOption(\\\"keyMap\\\", \\\"vim\\\")\\n        : !t &&\\n          r != Ze.Init &&\\n          /^vim/.test(e.getOption(\\\"keyMap\\\")) &&\\n          e.setOption(\\\"keyMap\\\", \\\"default\\\");\\n    });\\n    var s = { Shift: \\\"S\\\", Ctrl: \\\"C\\\", Alt: \\\"A\\\", Cmd: \\\"D\\\", Mod: \\\"A\\\" },\\n      l = { Enter: \\\"CR\\\", Backspace: \\\"BS\\\", Delete: \\\"Del\\\", Insert: \\\"Ins\\\" };\\n    function c(e) {\\n      var t = e.state.vim;\\n      return (\\n        t.onPasteFn ||\\n          (t.onPasteFn = function () {\\n            t.insertMode ||\\n              (e.setCursor(q(e.getCursor(), 0, 1)),\\n              U.enterInsertMode(e, {}, t));\\n          }),\\n        t.onPasteFn\\n      );\\n    }\\n    var u = /[\\\\d]/,\\n      m = [\\n        Ze.isWordChar,\\n        function (e) {\\n          return e && !Ze.isWordChar(e) && !/\\\\s/.test(e);\\n        },\\n      ],\\n      g = [\\n        function (e) {\\n          return /\\\\S/.test(e);\\n        },\\n      ];\\n    function r(e, t) {\\n      for (var r = [], n = e; n < e + t; n++) r.push(String.fromCharCode(n));\\n      return r;\\n    }\\n    var n = r(65, 26),\\n      h = r(97, 26),\\n      p = r(48, 10),\\n      f = [].concat(n, h, p, [\\\"<\\\", \\\">\\\"]),\\n      d = [].concat(n, h, p, [\\\"-\\\", '\\\"', \\\".\\\", \\\":\\\", \\\"_\\\", \\\"/\\\"]);\\n    function v(e, t) {\\n      return t >= e.firstLine() && t <= e.lastLine();\\n    }\\n    function y(e) {\\n      return /^[a-z]$/.test(e);\\n    }\\n    function k(e) {\\n      return /^[A-Z]$/.test(e);\\n    }\\n    function B(e) {\\n      return /^\\\\s*$/.test(e);\\n    }\\n    function C(e) {\\n      return -1 != \\\".?!\\\".indexOf(e);\\n    }\\n    function w(e, t) {\\n      for (var r = 0; r < t.length; r++) if (t[r] == e) return !0;\\n      return !1;\\n    }\\n    var x = {};\\n    function M(e, t, r, n, o) {\\n      if (void 0 === t && !o)\\n        throw Error(\\\"defaultValue is required unless callback is provided\\\");\\n      if (\\n        ((r = r || \\\"string\\\"),\\n        (x[e] = { type: r, defaultValue: t, callback: o }),\\n        n)\\n      )\\n        for (var i = 0; i < n.length; i++) x[n[i]] = x[e];\\n      t && S(e, t);\\n    }\\n    function S(e, t, r, n) {\\n      var o = x[e],\\n        i = (n = n || {}).scope;\\n      if (!o) return new Error(\\\"Unknown option: \\\" + e);\\n      if (\\\"boolean\\\" == o.type) {\\n        if (t && !0 !== t) return new Error(\\\"Invalid argument: \\\" + e + \\\"=\\\" + t);\\n        !1 !== t && (t = !0);\\n      }\\n      o.callback\\n        ? (\\\"local\\\" !== i && o.callback(t, void 0),\\n          \\\"global\\\" !== i && r && o.callback(t, r))\\n        : (\\\"local\\\" !== i && (o.value = \\\"boolean\\\" == o.type ? !!t : t),\\n          \\\"global\\\" !== i && r && (r.state.vim.options[e] = { value: t }));\\n    }\\n    function A(e, t, r) {\\n      var n = x[e],\\n        o = (r = r || {}).scope;\\n      if (!n) return new Error(\\\"Unknown option: \\\" + e);\\n      if (n.callback) {\\n        var i = t && n.callback(void 0, t);\\n        return \\\"global\\\" !== o && void 0 !== i\\n          ? i\\n          : \\\"local\\\" !== o\\n          ? n.callback()\\n          : void 0;\\n      }\\n      return (\\n        (i = \\\"global\\\" !== o && t && t.state.vim.options[e]) ||\\n        (\\\"local\\\" !== o && n) ||\\n        {}\\n      ).value;\\n    }\\n    M(\\\"filetype\\\", void 0, \\\"string\\\", [\\\"ft\\\"], function (e, t) {\\n      if (void 0 !== t) {\\n        if (void 0 === e) return \\\"null\\\" == (r = t.getOption(\\\"mode\\\")) ? \\\"\\\" : r;\\n        var r = \\\"\\\" == e ? \\\"null\\\" : e;\\n        t.setOption(\\\"mode\\\", r);\\n      }\\n    });\\n    function b() {\\n      var a = 100,\\n        s = -1,\\n        l = 0,\\n        c = 0,\\n        u = new Array(a);\\n      function o(e, t) {\\n        l < (s += t) ? (s = l) : s < c && (s = c);\\n        var r = u[(a + s) % a];\\n        if (r && !r.find()) {\\n          var n,\\n            o = 0 < t ? 1 : -1,\\n            i = e.getCursor();\\n          do {\\n            if ((r = u[(a + (s += o)) % a]) && (n = r.find()) && !X(i, n))\\n              break;\\n          } while (s < l && c < s);\\n        }\\n        return r;\\n      }\\n      return {\\n        cachedCursor: void 0,\\n        add: function (n, e, t) {\\n          var r,\\n            o = u[s % a];\\n          function i(e) {\\n            var t = ++s % a,\\n              r = u[t];\\n            r && r.clear(), (u[t] = n.setBookmark(e));\\n          }\\n          (o && (!(r = o.find()) || X(r, e))) || i(e),\\n            i(t),\\n            (c = (l = s) - a + 1) < 0 && (c = 0);\\n        },\\n        find: function (e, t) {\\n          var r = s,\\n            n = o(e, t);\\n          return (s = r), n && n.find();\\n        },\\n        move: o,\\n      };\\n    }\\n    var K,\\n      L,\\n      T = function (e) {\\n        return e\\n          ? {\\n              changes: e.changes,\\n              expectCursorActivityForChange: e.expectCursorActivityForChange,\\n            }\\n          : { changes: [], expectCursorActivityForChange: !1 };\\n      };\\n    function R() {\\n      (this.latestRegister = void 0),\\n        (this.isPlaying = !1),\\n        (this.isRecording = !1),\\n        (this.replaySearchQueries = []),\\n        (this.onRecordingDone = void 0),\\n        (this.lastInsertModeChanges = T());\\n    }\\n    function E(e) {\\n      return (\\n        e.state.vim ||\\n          (e.state.vim = {\\n            inputState: new N(),\\n            lastEditInputState: void 0,\\n            lastEditActionCommand: void 0,\\n            lastHPos: -1,\\n            lastHSPos: -1,\\n            lastMotion: null,\\n            marks: {},\\n            fakeCursor: null,\\n            insertMode: !1,\\n            insertModeRepeat: void 0,\\n            visualMode: !1,\\n            visualLine: !1,\\n            visualBlock: !1,\\n            lastSelection: null,\\n            lastPastedText: null,\\n            sel: {},\\n            options: {},\\n          }),\\n        e.state.vim\\n      );\\n    }\\n    function O() {\\n      for (var e in ((K = {\\n        searchQuery: null,\\n        searchIsReversed: !1,\\n        lastSubstituteReplacePart: void 0,\\n        jumpList: b(),\\n        macroModeState: new R(),\\n        lastCharacterSearch: {\\n          increment: 0,\\n          forward: !0,\\n          selectedCharacter: \\\"\\\",\\n        },\\n        registerController: new j({}),\\n        searchHistoryController: new H(),\\n        exCommandHistoryController: new H(),\\n      }),\\n      x)) {\\n        var t = x[e];\\n        t.value = t.defaultValue;\\n      }\\n    }\\n    var I = {\\n      buildKeyMap: function () {},\\n      getRegisterController: function () {\\n        return K.registerController;\\n      },\\n      resetVimGlobalState_: O,\\n      getVimGlobalState_: function () {\\n        return K;\\n      },\\n      maybeInitVimState_: E,\\n      suppressErrorLogging: !(R.prototype = {\\n        exitMacroRecordMode: function () {\\n          var e = K.macroModeState;\\n          e.onRecordingDone && e.onRecordingDone(),\\n            (e.onRecordingDone = void 0),\\n            (e.isRecording = !1);\\n        },\\n        enterMacroRecordMode: function (e, t) {\\n          var r = K.registerController.getRegister(t);\\n          r &&\\n            (r.clear(),\\n            (this.latestRegister = t),\\n            e.openDialog &&\\n              (this.onRecordingDone = e.openDialog(\\n                \\\"(recording)[\\\" + t + \\\"]\\\",\\n                null,\\n                { bottom: !0 }\\n              )),\\n            (this.isRecording = !0));\\n        },\\n      }),\\n      InsertModeKey: qe,\\n      map: function (e, t, r) {\\n        Fe.map(e, t, r);\\n      },\\n      unmap: function (e, t) {\\n        Fe.unmap(e, t);\\n      },\\n      noremap: function (e, t, r) {\\n        function n(e) {\\n          return e ? [e] : [\\\"normal\\\", \\\"insert\\\", \\\"visual\\\"];\\n        }\\n        for (var o = n(r), i = Ge.length, a = i - Ye; a < i && o.length; a++) {\\n          var s = Ge[a];\\n          if (\\n            !(\\n              s.keys != t ||\\n              (r && s.context && s.context !== r) ||\\n              \\\"ex\\\" === s.type.substr(0, 2) ||\\n              \\\"key\\\" === s.type.substr(0, 3)\\n            )\\n          ) {\\n            var l = {};\\n            for (var c in s) l[c] = s[c];\\n            (l.keys = e),\\n              r && !l.context && (l.context = r),\\n              this._mapCommand(l);\\n            var u = n(s.context),\\n              o = o.filter(function (e) {\\n                return -1 === u.indexOf(e);\\n              });\\n          }\\n        }\\n      },\\n      mapclear: function (e) {\\n        var t = Ge.length,\\n          r = Ye,\\n          n = Ge.slice(0, t - r);\\n        if (((Ge = Ge.slice(t - r)), e))\\n          for (var o = n.length - 1; 0 <= o; o--) {\\n            var i = n[o];\\n            if (e !== i.context)\\n              if (i.context) this._mapCommand(i);\\n              else {\\n                var a = [\\\"normal\\\", \\\"insert\\\", \\\"visual\\\"];\\n                for (var s in a)\\n                  if (a[s] !== e) {\\n                    var l = {};\\n                    for (var c in i) l[c] = i[c];\\n                    (l.context = a[s]), this._mapCommand(l);\\n                  }\\n              }\\n          }\\n      },\\n      setOption: S,\\n      getOption: A,\\n      defineOption: M,\\n      defineEx: function (e, t, r) {\\n        if (t) {\\n          if (0 !== e.indexOf(t))\\n            throw new Error(\\n              '(Vim.defineEx) \\\"' +\\n                t +\\n                '\\\" is not a prefix of \\\"' +\\n                e +\\n                '\\\", command not registered'\\n            );\\n        } else t = e;\\n        (He[e] = r),\\n          (Fe.commandMap_[t] = { name: e, shortName: t, type: \\\"api\\\" });\\n      },\\n      handleKey: function (e, t, r) {\\n        var n = this.findKey(e, t, r);\\n        if (\\\"function\\\" == typeof n) return n();\\n      },\\n      findKey: function (s, l, t) {\\n        var e,\\n          c = E(s);\\n        function o() {\\n          var e = K.macroModeState;\\n          if (e.isRecording) {\\n            if (\\\"q\\\" == l) return e.exitMacroRecordMode(), P(s), 1;\\n            \\\"mapping\\\" != t &&\\n              (function (e, t) {\\n                if (e.isPlaying) return;\\n                var r = e.latestRegister,\\n                  n = K.registerController.getRegister(r);\\n                n && n.pushText(t);\\n              })(e, l);\\n          }\\n        }\\n        function u() {\\n          return (\\n            \\\"<Esc>\\\" == l &&\\n            (P(s), c.visualMode ? le(s) : c.insertMode && We(s), 1)\\n          );\\n        }\\n        return !1 ===\\n          (e = (\\n            c.insertMode\\n              ? function () {\\n                  if (u()) return !0;\\n                  for (\\n                    var e = (c.inputState.keyBuffer =\\n                        c.inputState.keyBuffer + l),\\n                      t = 1 == l.length,\\n                      r = F.matchCommand(e, Ge, c.inputState, \\\"insert\\\");\\n                    1 < e.length && \\\"full\\\" != r.type;\\n\\n                  ) {\\n                    var e = (c.inputState.keyBuffer = e.slice(1)),\\n                      n = F.matchCommand(e, Ge, c.inputState, \\\"insert\\\");\\n                    \\\"none\\\" != n.type && (r = n);\\n                  }\\n                  if (\\\"none\\\" == r.type) return P(s), !1;\\n                  if (\\\"partial\\\" == r.type)\\n                    return (\\n                      L && window.clearTimeout(L),\\n                      (L = window.setTimeout(function () {\\n                        c.insertMode && c.inputState.keyBuffer && P(s);\\n                      }, A(\\\"insertModeEscKeysTimeout\\\"))),\\n                      !t\\n                    );\\n                  if ((L && window.clearTimeout(L), t)) {\\n                    for (var o = s.listSelections(), i = 0; i < o.length; i++) {\\n                      var a = o[i].head;\\n                      s.replaceRange(\\\"\\\", q(a, 0, -(e.length - 1)), a, \\\"+input\\\");\\n                    }\\n                    K.macroModeState.lastInsertModeChanges.changes.pop();\\n                  }\\n                  return P(s), r.command;\\n                }\\n              : function () {\\n                  if (o() || u()) return !0;\\n                  var e = (c.inputState.keyBuffer = c.inputState.keyBuffer + l);\\n                  if (/^[1-9]\\\\d*$/.test(e)) return !0;\\n                  var t = /^(\\\\d*)(.*)$/.exec(e);\\n                  if (!t) return P(s), !1;\\n                  var r = c.visualMode ? \\\"visual\\\" : \\\"normal\\\",\\n                    n = F.matchCommand(t[2] || t[1], Ge, c.inputState, r);\\n                  return \\\"none\\\" == n.type\\n                    ? (P(s), !1)\\n                    : \\\"partial\\\" == n.type ||\\n                        ((c.inputState.keyBuffer = \\\"\\\"),\\n                        (t = /^(\\\\d*)(.*)$/.exec(e))[1] &&\\n                          \\\"0\\\" != t[1] &&\\n                          c.inputState.pushRepeatDigit(t[1]),\\n                        n.command);\\n                }\\n          )())\\n          ? c.insertMode || 1 !== l.length\\n            ? void 0\\n            : function () {\\n                return !0;\\n              }\\n          : !0 === e\\n          ? function () {\\n              return !0;\\n            }\\n          : function () {\\n              return s.operation(function () {\\n                s.curOp.isVimOp = !0;\\n                try {\\n                  \\\"keyToKey\\\" == e.type\\n                    ? (function (e) {\\n                        for (var t; e; )\\n                          (t = /<\\\\w+-.+?>|<\\\\w+>|./.exec(e)),\\n                            (l = t[0]),\\n                            (e = e.substring(t.index + l.length)),\\n                            Ze.Vim.handleKey(s, l, \\\"mapping\\\");\\n                      })(e.toKeys)\\n                    : F.processCommand(s, c, e);\\n                } catch (e) {\\n                  throw (\\n                    ((s.state.vim = void 0),\\n                    E(s),\\n                    Ze.Vim.suppressErrorLogging || console.log(e),\\n                    e)\\n                  );\\n                }\\n                return !0;\\n              });\\n            };\\n      },\\n      handleEx: function (e, t) {\\n        Fe.processCommand(e, t);\\n      },\\n      defineMotion: function (e, t) {\\n        W[e] = t;\\n      },\\n      defineAction: function (e, t) {\\n        U[e] = t;\\n      },\\n      defineOperator: function (e, t) {\\n        D[e] = t;\\n      },\\n      mapCommand: function (e, t, r, n, o) {\\n        var i = { keys: e, type: t };\\n        for (var a in ((i[t] = r), (i[t + \\\"Args\\\"] = n), o)) i[a] = o[a];\\n        Ve(i);\\n      },\\n      _mapCommand: Ve,\\n      defineRegister: function (e, t) {\\n        var r = K.registerController.registers;\\n        if (!e || 1 != e.length)\\n          throw Error(\\\"Register name must be 1 character\\\");\\n        if (r[e]) throw Error(\\\"Register already defined \\\" + e);\\n        (r[e] = t), d.push(e);\\n      },\\n      exitVisualMode: le,\\n      exitInsertMode: We,\\n    };\\n    function N() {\\n      (this.prefixRepeat = []),\\n        (this.motionRepeat = []),\\n        (this.operator = null),\\n        (this.operatorArgs = null),\\n        (this.motion = null),\\n        (this.motionArgs = null),\\n        (this.keyBuffer = []),\\n        (this.registerName = null);\\n    }\\n    function P(e, t) {\\n      (e.state.vim.inputState = new N()), Ze.signal(e, \\\"vim-command-done\\\", t);\\n    }\\n    function _(e, t, r) {\\n      this.clear(),\\n        (this.keyBuffer = [e || \\\"\\\"]),\\n        (this.insertModeChanges = []),\\n        (this.searchQueries = []),\\n        (this.linewise = !!t),\\n        (this.blockwise = !!r);\\n    }\\n    function j(e) {\\n      (this.registers = e),\\n        (this.unnamedRegister = e['\\\"'] = new _()),\\n        (e[\\\".\\\"] = new _()),\\n        (e[\\\":\\\"] = new _()),\\n        (e[\\\"/\\\"] = new _());\\n    }\\n    function H() {\\n      (this.historyBuffer = []),\\n        (this.iterator = 0),\\n        (this.initialPrefix = null);\\n    }\\n    (N.prototype.pushRepeatDigit = function (e) {\\n      this.operator\\n        ? (this.motionRepeat = this.motionRepeat.concat(e))\\n        : (this.prefixRepeat = this.prefixRepeat.concat(e));\\n    }),\\n      (N.prototype.getRepeat = function () {\\n        var e = 0;\\n        return (\\n          (0 < this.prefixRepeat.length || 0 < this.motionRepeat.length) &&\\n            ((e = 1),\\n            0 < this.prefixRepeat.length &&\\n              (e *= parseInt(this.prefixRepeat.join(\\\"\\\"), 10)),\\n            0 < this.motionRepeat.length &&\\n              (e *= parseInt(this.motionRepeat.join(\\\"\\\"), 10))),\\n          e\\n        );\\n      }),\\n      (_.prototype = {\\n        setText: function (e, t, r) {\\n          (this.keyBuffer = [e || \\\"\\\"]),\\n            (this.linewise = !!t),\\n            (this.blockwise = !!r);\\n        },\\n        pushText: function (e, t) {\\n          t &&\\n            (this.linewise || this.keyBuffer.push(\\\"\\\\n\\\"), (this.linewise = !0)),\\n            this.keyBuffer.push(e);\\n        },\\n        pushInsertModeChanges: function (e) {\\n          this.insertModeChanges.push(T(e));\\n        },\\n        pushSearchQuery: function (e) {\\n          this.searchQueries.push(e);\\n        },\\n        clear: function () {\\n          (this.keyBuffer = []),\\n            (this.insertModeChanges = []),\\n            (this.searchQueries = []),\\n            (this.linewise = !1);\\n        },\\n        toString: function () {\\n          return this.keyBuffer.join(\\\"\\\");\\n        },\\n      }),\\n      (j.prototype = {\\n        pushText: function (e, t, r, n, o) {\\n          if (\\\"_\\\" !== e) {\\n            n && \\\"\\\\n\\\" !== r.charAt(r.length - 1) && (r += \\\"\\\\n\\\");\\n            var i = this.isValidRegister(e) ? this.getRegister(e) : null;\\n            if (i) {\\n              k(e) ? i.pushText(r, n) : i.setText(r, n, o),\\n                this.unnamedRegister.setText(i.toString(), n);\\n            } else {\\n              switch (t) {\\n                case \\\"yank\\\":\\n                  this.registers[0] = new _(r, n, o);\\n                  break;\\n                case \\\"delete\\\":\\n                case \\\"change\\\":\\n                  -1 == r.indexOf(\\\"\\\\n\\\")\\n                    ? (this.registers[\\\"-\\\"] = new _(r, n))\\n                    : (this.shiftNumericRegisters_(),\\n                      (this.registers[1] = new _(r, n)));\\n              }\\n              this.unnamedRegister.setText(r, n, o);\\n            }\\n          }\\n        },\\n        getRegister: function (e) {\\n          return this.isValidRegister(e)\\n            ? ((e = e.toLowerCase()),\\n              this.registers[e] || (this.registers[e] = new _()),\\n              this.registers[e])\\n            : this.unnamedRegister;\\n        },\\n        isValidRegister: function (e) {\\n          return e && w(e, d);\\n        },\\n        shiftNumericRegisters_: function () {\\n          for (var e = 9; 2 <= e; e--)\\n            this.registers[e] = this.getRegister(\\\"\\\" + (e - 1));\\n        },\\n      }),\\n      (H.prototype = {\\n        nextMatch: function (e, t) {\\n          var r = this.historyBuffer,\\n            n = t ? -1 : 1;\\n          null === this.initialPrefix && (this.initialPrefix = e);\\n          for (var o = this.iterator + n; t ? 0 <= o : o < r.length; o += n)\\n            for (var i = r[o], a = 0; a <= i.length; a++)\\n              if (this.initialPrefix == i.substring(0, a))\\n                return (this.iterator = o), i;\\n          return o >= r.length\\n            ? ((this.iterator = r.length), this.initialPrefix)\\n            : o < 0\\n            ? e\\n            : void 0;\\n        },\\n        pushInput: function (e) {\\n          var t = this.historyBuffer.indexOf(e);\\n          -1 < t && this.historyBuffer.splice(t, 1),\\n            e.length && this.historyBuffer.push(e);\\n        },\\n        reset: function () {\\n          (this.initialPrefix = null),\\n            (this.iterator = this.historyBuffer.length);\\n        },\\n      });\\n    var F = {\\n        matchCommand: function (e, t, r, n) {\\n          var o = (function (e, t, r, n) {\\n            for (var o, i = [], a = [], s = 0; s < t.length; s++) {\\n              var l = t[s];\\n              (\\\"insert\\\" == r && \\\"insert\\\" != l.context) ||\\n                (l.context && l.context != r) ||\\n                (n.operator && \\\"action\\\" == l.type) ||\\n                !(o = (function (e, t) {\\n                  {\\n                    if (\\\"<character>\\\" != t.slice(-11))\\n                      return e == t ? \\\"full\\\" : 0 == t.indexOf(e) && \\\"partial\\\";\\n                    var r = t.length - 11,\\n                      n = e.slice(0, r),\\n                      o = t.slice(0, r);\\n                    return n == o && e.length > r\\n                      ? \\\"full\\\"\\n                      : 0 == o.indexOf(n) && \\\"partial\\\";\\n                  }\\n                })(e, l.keys)) ||\\n                (\\\"partial\\\" == o && i.push(l), \\\"full\\\" == o && a.push(l));\\n            }\\n            return { partial: i.length && i, full: a.length && a };\\n          })(e, t, n, r);\\n          if (!o.full && !o.partial) return { type: \\\"none\\\" };\\n          if (!o.full && o.partial) return { type: \\\"partial\\\" };\\n          for (var i = 0; i < o.full.length; i++) var a = o.full[i], s = s || a;\\n          if (\\\"<character>\\\" == s.keys.slice(-11)) {\\n            var l = (function (e) {\\n              var t = /^.*(<[^>]+>)$/.exec(e),\\n                r = t ? t[1] : e.slice(-1);\\n              if (1 < r.length)\\n                switch (r) {\\n                  case \\\"<CR>\\\":\\n                    r = \\\"\\\\n\\\";\\n                    break;\\n                  case \\\"<Space>\\\":\\n                    r = \\\" \\\";\\n                    break;\\n                  default:\\n                    r = \\\"\\\";\\n                }\\n              return r;\\n            })(e);\\n            if (!l) return { type: \\\"none\\\" };\\n            r.selectedCharacter = l;\\n          }\\n          return { type: \\\"full\\\", command: s };\\n        },\\n        processCommand: function (e, t, r) {\\n          switch (((t.inputState.repeatOverride = r.repeatOverride), r.type)) {\\n            case \\\"motion\\\":\\n              this.processMotion(e, t, r);\\n              break;\\n            case \\\"operator\\\":\\n              this.processOperator(e, t, r);\\n              break;\\n            case \\\"operatorMotion\\\":\\n              this.processOperatorMotion(e, t, r);\\n              break;\\n            case \\\"action\\\":\\n              this.processAction(e, t, r);\\n              break;\\n            case \\\"search\\\":\\n              this.processSearch(e, t, r);\\n              break;\\n            case \\\"ex\\\":\\n            case \\\"keyToEx\\\":\\n              this.processEx(e, t, r);\\n          }\\n        },\\n        processMotion: function (e, t, r) {\\n          (t.inputState.motion = r.motion),\\n            (t.inputState.motionArgs = $(r.motionArgs)),\\n            this.evalInput(e, t);\\n        },\\n        processOperator: function (e, t, r) {\\n          var n = t.inputState;\\n          if (n.operator) {\\n            if (n.operator == r.operator)\\n              return (\\n                (n.motion = \\\"expandToLine\\\"),\\n                (n.motionArgs = { linewise: !0 }),\\n                void this.evalInput(e, t)\\n              );\\n            P(e);\\n          }\\n          (n.operator = r.operator),\\n            (n.operatorArgs = $(r.operatorArgs)),\\n            r.exitVisualBlock && ((t.visualBlock = !1), ae(e)),\\n            t.visualMode && this.evalInput(e, t);\\n        },\\n        processOperatorMotion: function (e, t, r) {\\n          var n = t.visualMode,\\n            o = $(r.operatorMotionArgs);\\n          o && n && o.visualLine && (t.visualLine = !0),\\n            this.processOperator(e, t, r),\\n            n || this.processMotion(e, t, r);\\n        },\\n        processAction: function (e, t, r) {\\n          var n = t.inputState,\\n            o = n.getRepeat(),\\n            i = !!o,\\n            a = $(r.actionArgs) || {};\\n          n.selectedCharacter && (a.selectedCharacter = n.selectedCharacter),\\n            r.operator && this.processOperator(e, t, r),\\n            r.motion && this.processMotion(e, t, r),\\n            (r.motion || r.operator) && this.evalInput(e, t),\\n            (a.repeat = o || 1),\\n            (a.repeatIsExplicit = i),\\n            (a.registerName = n.registerName),\\n            P(e),\\n            (t.lastMotion = null),\\n            r.isEdit && this.recordLastEdit(t, n, r),\\n            U[r.action](e, a, t);\\n        },\\n        processSearch: function (s, n, o) {\\n          if (s.getSearchCursor) {\\n            var l = o.searchArgs.forward,\\n              e = o.searchArgs.wholeWordOnly;\\n            Ce(s).setReversed(!l);\\n            var t = l ? \\\"/\\\" : \\\"?\\\",\\n              i = Ce(s).getQuery(),\\n              c = s.getScrollInfo();\\n            switch (o.searchArgs.querySrc) {\\n              case \\\"prompt\\\":\\n                var r = K.macroModeState;\\n                r.isPlaying\\n                  ? p((h = r.replaySearchQueries.shift()), !0, !1)\\n                  : Re(s, {\\n                      onClose: function (e) {\\n                        s.scrollTo(c.left, c.top), p(e, !0, !0);\\n                        var t = K.macroModeState;\\n                        t.isRecording &&\\n                          (function (e, t) {\\n                            if (e.isPlaying) return;\\n                            var r = e.latestRegister,\\n                              n = K.registerController.getRegister(r);\\n                            n && n.pushSearchQuery && n.pushSearchQuery(t);\\n                          })(t, e);\\n                      },\\n                      prefix: t,\\n                      desc: Te,\\n                      onKeyUp: function (e, t, r) {\\n                        var n,\\n                          o,\\n                          i,\\n                          a = Ze.keyName(e);\\n                        \\\"Up\\\" == a || \\\"Down\\\" == a\\n                          ? ((n = \\\"Up\\\" == a),\\n                            (o = e.target ? e.target.selectionEnd : 0),\\n                            r(\\n                              (t =\\n                                K.searchHistoryController.nextMatch(t, n) || \\\"\\\")\\n                            ),\\n                            o &&\\n                              e.target &&\\n                              (e.target.selectionEnd = e.target.selectionStart =\\n                                Math.min(o, e.target.value.length)))\\n                          : \\\"Left\\\" != a &&\\n                            \\\"Right\\\" != a &&\\n                            \\\"Ctrl\\\" != a &&\\n                            \\\"Alt\\\" != a &&\\n                            \\\"Shift\\\" != a &&\\n                            K.searchHistoryController.reset();\\n                        try {\\n                          i = Ee(s, t, !0, !0);\\n                        } catch (e) {}\\n                        i\\n                          ? s.scrollIntoView(Ie(s, !l, i), 30)\\n                          : (Ke(s), s.scrollTo(c.left, c.top));\\n                      },\\n                      onKeyDown: function (e, t, r) {\\n                        var n = Ze.keyName(e);\\n                        \\\"Esc\\\" == n ||\\n                        \\\"Ctrl-C\\\" == n ||\\n                        \\\"Ctrl-[\\\" == n ||\\n                        (\\\"Backspace\\\" == n && \\\"\\\" == t)\\n                          ? (K.searchHistoryController.pushInput(t),\\n                            K.searchHistoryController.reset(),\\n                            Ee(s, i),\\n                            Ke(s),\\n                            s.scrollTo(c.left, c.top),\\n                            Ze.e_stop(e),\\n                            P(s),\\n                            r(),\\n                            s.focus())\\n                          : \\\"Up\\\" == n || \\\"Down\\\" == n\\n                          ? Ze.e_stop(e)\\n                          : \\\"Ctrl-U\\\" == n && (Ze.e_stop(e), r(\\\"\\\"));\\n                      },\\n                    });\\n                break;\\n              case \\\"wordUnderCursor\\\":\\n                var a = ue(s, !1, 0, !1, !0),\\n                  u = !0;\\n                if ((a || ((a = ue(s, !1, 0, !1, !1)), (u = !1)), !a)) return;\\n                var h = s.getLine(a.start.line).substring(a.start.ch, a.end.ch);\\n                (h =\\n                  u && e\\n                    ? \\\"\\\\\\\\b\\\" + h + \\\"\\\\\\\\b\\\"\\n                    : h.replace(/([.?*+$\\\\[\\\\]\\\\/\\\\\\\\(){}|\\\\-])/g, \\\"\\\\\\\\$1\\\")),\\n                  (K.jumpList.cachedCursor = s.getCursor()),\\n                  s.setCursor(a.start),\\n                  p(h, !0, !1);\\n            }\\n          }\\n          function p(t, e, r) {\\n            K.searchHistoryController.pushInput(t),\\n              K.searchHistoryController.reset();\\n            try {\\n              Ee(s, t, e, r);\\n            } catch (e) {\\n              return Le(s, \\\"Invalid regex: \\\" + t), void P(s);\\n            }\\n            F.processMotion(s, n, {\\n              type: \\\"motion\\\",\\n              motion: \\\"findNext\\\",\\n              motionArgs: { forward: !0, toJumplist: o.searchArgs.toJumplist },\\n            });\\n          }\\n        },\\n        processEx: function (a, e, t) {\\n          function r(e) {\\n            K.exCommandHistoryController.pushInput(e),\\n              K.exCommandHistoryController.reset(),\\n              Fe.processCommand(a, e);\\n          }\\n          function n(e, t, r) {\\n            var n,\\n              o,\\n              i = Ze.keyName(e);\\n            (\\\"Esc\\\" == i ||\\n              \\\"Ctrl-C\\\" == i ||\\n              \\\"Ctrl-[\\\" == i ||\\n              (\\\"Backspace\\\" == i && \\\"\\\" == t)) &&\\n              (K.exCommandHistoryController.pushInput(t),\\n              K.exCommandHistoryController.reset(),\\n              Ze.e_stop(e),\\n              P(a),\\n              r(),\\n              a.focus()),\\n              \\\"Up\\\" == i || \\\"Down\\\" == i\\n                ? (Ze.e_stop(e),\\n                  (n = \\\"Up\\\" == i),\\n                  (o = e.target ? e.target.selectionEnd : 0),\\n                  r((t = K.exCommandHistoryController.nextMatch(t, n) || \\\"\\\")),\\n                  o &&\\n                    e.target &&\\n                    (e.target.selectionEnd = e.target.selectionStart =\\n                      Math.min(o, e.target.value.length)))\\n                : \\\"Ctrl-U\\\" == i\\n                ? (Ze.e_stop(e), r(\\\"\\\"))\\n                : \\\"Left\\\" != i &&\\n                  \\\"Right\\\" != i &&\\n                  \\\"Ctrl\\\" != i &&\\n                  \\\"Alt\\\" != i &&\\n                  \\\"Shift\\\" != i &&\\n                  K.exCommandHistoryController.reset();\\n          }\\n          \\\"keyToEx\\\" == t.type\\n            ? Fe.processCommand(a, t.exArgs.input)\\n            : e.visualMode\\n            ? Re(a, {\\n                onClose: r,\\n                prefix: \\\":\\\",\\n                value: \\\"'<,'>\\\",\\n                onKeyDown: n,\\n                selectValueOnOpen: !1,\\n              })\\n            : Re(a, { onClose: r, prefix: \\\":\\\", onKeyDown: n });\\n        },\\n        evalInput: function (e, t) {\\n          var r,\\n            n,\\n            o,\\n            i,\\n            a,\\n            s,\\n            l,\\n            c,\\n            u,\\n            h,\\n            p,\\n            f,\\n            d = t.inputState,\\n            m = d.motion,\\n            g = d.motionArgs || {},\\n            v = d.operator,\\n            y = d.operatorArgs || {},\\n            k = d.registerName,\\n            C = t.sel,\\n            w = z(t.visualMode ? J(e, C.head) : e.getCursor(\\\"head\\\")),\\n            x = z(t.visualMode ? J(e, C.anchor) : e.getCursor(\\\"anchor\\\")),\\n            M = z(w),\\n            S = z(x);\\n          if (\\n            (v && this.recordLastEdit(t, d),\\n            0 <\\n              (n =\\n                void 0 !== d.repeatOverride\\n                  ? d.repeatOverride\\n                  : d.getRepeat()) && g.explicitRepeat\\n              ? (g.repeatIsExplicit = !0)\\n              : (g.noRepeat || (!g.explicitRepeat && 0 === n)) &&\\n                ((n = 1), (g.repeatIsExplicit = !1)),\\n            d.selectedCharacter &&\\n              (g.selectedCharacter = y.selectedCharacter = d.selectedCharacter),\\n            (g.repeat = n),\\n            P(e),\\n            m)\\n          ) {\\n            var A,\\n              b,\\n              L = W[m](e, w, g, t, d);\\n            if (((t.lastMotion = W[m]), !L)) return;\\n            g.toJumplist &&\\n              ((b = (A = K.jumpList).cachedCursor)\\n                ? (he(e, b, L), delete A.cachedCursor)\\n                : he(e, w, L)),\\n              (s = (s = L instanceof Array ? ((r = L[0]), L[1]) : L) || z(w)),\\n              t.visualMode\\n                ? ((t.visualBlock && s.ch === 1 / 0) || (s = J(e, s)),\\n                  (r = (r = r && J(e, r)) || S),\\n                  (C.anchor = r),\\n                  (C.head = s),\\n                  ae(e),\\n                  ve(e, t, \\\"<\\\", Z(r, s) ? r : s),\\n                  ve(e, t, \\\">\\\", Z(r, s) ? s : r))\\n                : v || ((s = J(e, s)), e.setCursor(s.line, s.ch));\\n          }\\n          if (v) {\\n            if (\\n              (y.lastSel\\n                ? ((r = S),\\n                  (o = y.lastSel),\\n                  (i = Math.abs(o.head.line - o.anchor.line)),\\n                  (a = Math.abs(o.head.ch - o.anchor.ch)),\\n                  (s = o.visualLine\\n                    ? tt(S.line + i, S.ch)\\n                    : o.visualBlock\\n                    ? tt(S.line + i, S.ch + a)\\n                    : o.head.line == o.anchor.line\\n                    ? tt(S.line, S.ch + a)\\n                    : tt(S.line + i, S.ch)),\\n                  (t.visualMode = !0),\\n                  (t.visualLine = o.visualLine),\\n                  (t.visualBlock = o.visualBlock),\\n                  (C = t.sel = { anchor: r, head: s }),\\n                  ae(e))\\n                : t.visualMode &&\\n                  (y.lastSel = {\\n                    anchor: z(C.anchor),\\n                    head: z(C.head),\\n                    visualBlock: t.visualBlock,\\n                    visualLine: t.visualLine,\\n                  }),\\n              t.visualMode)\\n            ) {\\n              if (\\n                ((h = G(C.head, C.anchor)),\\n                (p = Y(C.head, C.anchor)),\\n                (l = t.visualLine || y.linewise),\\n                (E = se(\\n                  e,\\n                  { anchor: h, head: p },\\n                  (c = t.visualBlock ? \\\"block\\\" : l ? \\\"line\\\" : \\\"char\\\")\\n                )),\\n                l)\\n              ) {\\n                var T = E.ranges;\\n                if (\\\"block\\\" == c)\\n                  for (var R = 0; R < T.length; R++)\\n                    T[R].head.ch = te(e, T[R].head.line);\\n                else \\\"line\\\" == c && (T[0].head = tt(T[0].head.line + 1, 0));\\n              }\\n            } else {\\n              (h = z(r || S)),\\n                Z((p = z(s || M)), h) && ((u = h), (h = p), (p = u)),\\n                (l = g.linewise || y.linewise)\\n                  ? ((f = p), (h.ch = 0), (f.ch = 0), f.line++)\\n                  : g.forward &&\\n                    (function (e, t, r) {\\n                      var n = e.getRange(t, r);\\n                      if (/\\\\n\\\\s*$/.test(n)) {\\n                        var o = n.split(\\\"\\\\n\\\");\\n                        o.pop();\\n                        for (\\n                          var i = o.pop();\\n                          0 < o.length && i && B(i);\\n                          i = o.pop()\\n                        )\\n                          r.line--, (r.ch = 0);\\n                        i ? (r.line--, (r.ch = te(e, r.line))) : (r.ch = 0);\\n                      }\\n                    })(e, h, p);\\n              var E = se(\\n                e,\\n                { anchor: h, head: p },\\n                (c = \\\"char\\\"),\\n                !g.inclusive || l\\n              );\\n            }\\n            e.setSelections(E.ranges, E.primary),\\n              (t.lastMotion = null),\\n              (y.repeat = n),\\n              (y.registerName = k),\\n              (y.linewise = l);\\n            var O = D[v](e, y, E.ranges, S, s);\\n            t.visualMode && le(e, null != O), O && e.setCursor(O);\\n          }\\n        },\\n        recordLastEdit: function (e, t, r) {\\n          var n = K.macroModeState;\\n          n.isPlaying ||\\n            ((e.lastEditInputState = t),\\n            (e.lastEditActionCommand = r),\\n            (n.lastInsertModeChanges.changes = []),\\n            (n.lastInsertModeChanges.expectCursorActivityForChange = !1),\\n            (n.lastInsertModeChanges.visualBlock = e.visualBlock\\n              ? e.sel.head.line - e.sel.anchor.line\\n              : 0));\\n        },\\n      },\\n      W = {\\n        moveToTopLine: function (e, t, r) {\\n          var n = Ne(e).top + r.repeat - 1;\\n          return tt(n, ce(e.getLine(n)));\\n        },\\n        moveToMiddleLine: function (e) {\\n          var t = Ne(e),\\n            r = Math.floor(0.5 * (t.top + t.bottom));\\n          return tt(r, ce(e.getLine(r)));\\n        },\\n        moveToBottomLine: function (e, t, r) {\\n          var n = Ne(e).bottom - r.repeat + 1;\\n          return tt(n, ce(e.getLine(n)));\\n        },\\n        expandToLine: function (e, t, r) {\\n          return tt(t.line + r.repeat - 1, 1 / 0);\\n        },\\n        findNext: function (e, t, r) {\\n          var n = Ce(e),\\n            o = n.getQuery();\\n          if (o) {\\n            var i = !r.forward,\\n              i = n.isReversed() ? !i : i;\\n            return Be(e, o), Ie(e, i, o, r.repeat);\\n          }\\n        },\\n        findAndSelectNextInclusive: function (e, t, r, n, o) {\\n          var i = Ce(e),\\n            a = i.getQuery();\\n          if (a) {\\n            var s = !r.forward,\\n              l = (function (o, i, a, s, l) {\\n                void 0 === s && (s = 1);\\n                return o.operation(function () {\\n                  var e = o.getCursor(),\\n                    t = o.getSearchCursor(a, e),\\n                    r = t.find(!i);\\n                  !l.visualMode && r && X(t.from(), e) && t.find(!i);\\n                  for (var n = 0; n < s; n++)\\n                    if (\\n                      !(r = t.find(i)) &&\\n                      !(t = o.getSearchCursor(\\n                        a,\\n                        i ? tt(o.lastLine()) : tt(o.firstLine(), 0)\\n                      )).find(i)\\n                    )\\n                      return;\\n                  return [t.from(), t.to()];\\n                });\\n              })(e, (s = i.isReversed() ? !s : s), a, r.repeat, n);\\n            if (l) {\\n              if (o.operator) return l;\\n              var c = l[0],\\n                u = tt(l[1].line, l[1].ch - 1);\\n              if (n.visualMode) {\\n                (n.visualLine || n.visualBlock) &&\\n                  ((n.visualLine = !1),\\n                  (n.visualBlock = !1),\\n                  Ze.signal(e, \\\"vim-mode-change\\\", {\\n                    mode: \\\"visual\\\",\\n                    subMode: \\\"\\\",\\n                  }));\\n                var h = n.sel.anchor;\\n                if (h)\\n                  return i.isReversed()\\n                    ? r.forward\\n                      ? [h, c]\\n                      : [h, u]\\n                    : r.forward\\n                    ? [h, u]\\n                    : [h, c];\\n              } else\\n                (n.visualMode = !0),\\n                  (n.visualLine = !1),\\n                  (n.visualBlock = !1),\\n                  Ze.signal(e, \\\"vim-mode-change\\\", {\\n                    mode: \\\"visual\\\",\\n                    subMode: \\\"\\\",\\n                  });\\n              return s ? [u, c] : [c, u];\\n            }\\n          }\\n        },\\n        goToMark: function (e, t, r, n) {\\n          var o = Pe(e, n, r.selectedCharacter);\\n          return o\\n            ? r.linewise\\n              ? { line: o.line, ch: ce(e.getLine(o.line)) }\\n              : o\\n            : null;\\n        },\\n        moveToOtherHighlightedEnd: function (e, t, r, n) {\\n          if (n.visualBlock && r.sameLine) {\\n            var o = n.sel;\\n            return [\\n              J(e, tt(o.anchor.line, o.head.ch)),\\n              J(e, tt(o.head.line, o.anchor.ch)),\\n            ];\\n          }\\n          return [n.sel.head, n.sel.anchor];\\n        },\\n        jumpToMark: function (e, t, r, n) {\\n          for (var o = t, i = 0; i < r.repeat; i++) {\\n            var a,\\n              s,\\n              l,\\n              c = o;\\n            for (var u in n.marks) {\\n              y(u) &&\\n                ((a = n.marks[u].find()),\\n                (r.forward ? Z(a, c) : Z(c, a)) ||\\n                  (r.linewise && a.line == c.line) ||\\n                  ((s = X(c, o)),\\n                  (l = r.forward ? ee(c, a, o) : ee(o, a, c)),\\n                  (s || l) && (o = a)));\\n            }\\n          }\\n          return r.linewise && (o = tt(o.line, ce(e.getLine(o.line)))), o;\\n        },\\n        moveByCharacters: function (e, t, r) {\\n          var n = r.repeat,\\n            o = r.forward ? t.ch + n : t.ch - n;\\n          return tt(t.line, o);\\n        },\\n        moveByLines: function (e, t, r, n) {\\n          var o = t,\\n            i = o.ch;\\n          switch (n.lastMotion) {\\n            case this.moveByLines:\\n            case this.moveByDisplayLines:\\n            case this.moveByScroll:\\n            case this.moveToColumn:\\n            case this.moveToEol:\\n              i = n.lastHPos;\\n              break;\\n            default:\\n              n.lastHPos = i;\\n          }\\n          var a = r.repeat + (r.repeatOffset || 0),\\n            s = r.forward ? o.line + a : o.line - a,\\n            l = e.firstLine(),\\n            c = e.lastLine(),\\n            u = e.findPosV(o, r.forward ? a : -a, \\\"line\\\", n.lastHSPos);\\n          return (\\n            (r.forward ? u.line > s : u.line < s) && ((s = u.line), (i = u.ch)),\\n            s < l && o.line == l\\n              ? this.moveToStartOfLine(e, t, r, n)\\n              : c < s && o.line == c\\n              ? me(e, t, r, n, !0)\\n              : (r.toFirstChar && ((i = ce(e.getLine(s))), (n.lastHPos = i)),\\n                (n.lastHSPos = e.charCoords(tt(s, i), \\\"div\\\").left),\\n                tt(s, i))\\n          );\\n        },\\n        moveByDisplayLines: function (e, t, r, n) {\\n          var o = t;\\n          switch (n.lastMotion) {\\n            case this.moveByDisplayLines:\\n            case this.moveByScroll:\\n            case this.moveByLines:\\n            case this.moveToColumn:\\n            case this.moveToEol:\\n              break;\\n            default:\\n              n.lastHSPos = e.charCoords(o, \\\"div\\\").left;\\n          }\\n          var i,\\n            a,\\n            s = r.repeat,\\n            l = e.findPosV(o, r.forward ? s : -s, \\\"line\\\", n.lastHSPos);\\n          return (\\n            l.hitSide &&\\n              (l = r.forward\\n                ? ((i = {\\n                    top: e.charCoords(l, \\\"div\\\").top + 8,\\n                    left: n.lastHSPos,\\n                  }),\\n                  e.coordsChar(i, \\\"div\\\"))\\n                : (((a = e.charCoords(tt(e.firstLine(), 0), \\\"div\\\")).left =\\n                    n.lastHSPos),\\n                  e.coordsChar(a, \\\"div\\\"))),\\n            (n.lastHPos = l.ch),\\n            l\\n          );\\n        },\\n        moveByPage: function (e, t, r) {\\n          var n = r.repeat;\\n          return e.findPosV(t, r.forward ? n : -n, \\\"page\\\");\\n        },\\n        moveByParagraph: function (e, t, r) {\\n          var n = r.forward ? 1 : -1;\\n          return ye(e, t, r.repeat, n);\\n        },\\n        moveBySentence: function (e, t, r) {\\n          var n = r.forward ? 1 : -1;\\n          return (function (e, t, r, n) {\\n            function u(e, t) {\\n              if (t.pos + t.dir < 0 || t.pos + t.dir >= t.line.length) {\\n                if (((t.ln += t.dir), !v(e, t.ln)))\\n                  return (t.line = null), (t.ln = null), void (t.pos = null);\\n                (t.line = e.getLine(t.ln)),\\n                  (t.pos = 0 < t.dir ? 0 : t.line.length - 1);\\n              } else t.pos += t.dir;\\n            }\\n            var o = { ln: t.line, pos: t.ch };\\n            for (; 0 < r; )\\n              (o = (\\n                n < 0\\n                  ? function (e, t, r, n) {\\n                      var o = {\\n                          line: (s = e.getLine(t)),\\n                          ln: t,\\n                          pos: r,\\n                          dir: n,\\n                        },\\n                        i = { ln: o.ln, pos: null },\\n                        a = \\\"\\\" === o.line;\\n                      for (u(e, o); null !== o.line; ) {\\n                        if (\\\"\\\" === o.line && !a)\\n                          return null !== i.pos ? i : { ln: o.ln, pos: o.pos };\\n                        if (\\n                          C(o.line[o.pos]) &&\\n                          null !== i.pos &&\\n                          (o.ln !== i.ln || o.pos + 1 !== i.pos)\\n                        )\\n                          return i;\\n                        \\\"\\\" === o.line ||\\n                          B(o.line[o.pos]) ||\\n                          ((a = !1), (i = { ln: o.ln, pos: o.pos })),\\n                          u(e, o);\\n                      }\\n                      for (\\n                        var s = e.getLine(i.ln), l = (i.pos = 0);\\n                        l < s.length;\\n                        ++l\\n                      )\\n                        if (!B(s[l])) {\\n                          i.pos = l;\\n                          break;\\n                        }\\n                      return i;\\n                    }\\n                  : function (e, t, r, n) {\\n                      var o = \\\"\\\" === (l = e.getLine(t)),\\n                        i = { line: l, ln: t, pos: r, dir: n },\\n                        a = { ln: i.ln, pos: i.pos },\\n                        s = \\\"\\\" === i.line;\\n                      for (u(e, i); null !== i.line; ) {\\n                        if (\\n                          ((a.ln = i.ln), (a.pos = i.pos), \\\"\\\" === i.line && !s)\\n                        )\\n                          return { ln: i.ln, pos: i.pos };\\n                        if (o && \\\"\\\" !== i.line && !B(i.line[i.pos]))\\n                          return { ln: i.ln, pos: i.pos };\\n                        !C(i.line[i.pos]) ||\\n                          o ||\\n                          (i.pos !== i.line.length - 1 &&\\n                            !B(i.line[i.pos + 1])) ||\\n                          (o = !0),\\n                          u(e, i);\\n                      }\\n                      var l = e.getLine(a.ln);\\n                      a.pos = 0;\\n                      for (var c = l.length - 1; 0 <= c; --c)\\n                        if (!B(l[c])) {\\n                          a.pos = c;\\n                          break;\\n                        }\\n                      return a;\\n                    }\\n              )(e, o.ln, o.pos, n)),\\n                r--;\\n            return tt(o.ln, o.pos);\\n          })(e, t, r.repeat, n);\\n        },\\n        moveByScroll: function (e, t, r, n) {\\n          var o = e.getScrollInfo(),\\n            i = null,\\n            a = (a = r.repeat) || o.clientHeight / (2 * e.defaultTextHeight()),\\n            s = e.charCoords(t, \\\"local\\\");\\n          if (((r.repeat = a), !(i = W.moveByDisplayLines(e, t, r, n))))\\n            return null;\\n          var l = e.charCoords(i, \\\"local\\\");\\n          return e.scrollTo(null, o.top + l.top - s.top), i;\\n        },\\n        moveByWords: function (e, t, r) {\\n          return (function (e, t, r, n, o, i) {\\n            var a = z(t),\\n              s = [];\\n            ((n && !o) || (!n && o)) && r++;\\n            for (var l = !(n && o), c = 0; c < r; c++) {\\n              var u = (function (e, t, r, n, o) {\\n                var i = t.line,\\n                  a = t.ch,\\n                  s = e.getLine(i),\\n                  l = r ? 1 : -1,\\n                  c = n ? g : m;\\n                if (o && \\\"\\\" == s) {\\n                  if (((i += l), (s = e.getLine(i)), !v(e, i))) return null;\\n                  a = r ? 0 : s.length;\\n                }\\n                for (;;) {\\n                  if (o && \\\"\\\" == s) return { from: 0, to: 0, line: i };\\n                  for (var u = 0 < l ? s.length : -1, h = u, p = u; a != u; ) {\\n                    for (var f = !1, d = 0; d < c.length && !f; ++d)\\n                      if (c[d](s.charAt(a))) {\\n                        for (h = a; a != u && c[d](s.charAt(a)); ) a += l;\\n                        if (\\n                          ((f = h != (p = a)),\\n                          h == t.ch && i == t.line && p == h + l)\\n                        )\\n                          continue;\\n                        return {\\n                          from: Math.min(h, p + 1),\\n                          to: Math.max(h, p),\\n                          line: i,\\n                        };\\n                      }\\n                    f || (a += l);\\n                  }\\n                  if (!v(e, (i += l))) return null;\\n                  (s = e.getLine(i)), (a = 0 < l ? 0 : s.length);\\n                }\\n              })(e, t, n, i, l);\\n              if (!u) {\\n                var h = te(e, e.lastLine());\\n                s.push(\\n                  n\\n                    ? { line: e.lastLine(), from: h, to: h }\\n                    : { line: 0, from: 0, to: 0 }\\n                );\\n                break;\\n              }\\n              s.push(u), (t = tt(u.line, n ? u.to - 1 : u.from));\\n            }\\n            var p = s.length != r,\\n              f = s[0],\\n              d = s.pop();\\n            return n && !o\\n              ? (p || (f.from == a.ch && f.line == a.line) || (d = s.pop()),\\n                tt(d.line, d.from))\\n              : n && o\\n              ? tt(d.line, d.to - 1)\\n              : !n && o\\n              ? (p || (f.to == a.ch && f.line == a.line) || (d = s.pop()),\\n                tt(d.line, d.to))\\n              : tt(d.line, d.from);\\n          })(e, t, r.repeat, !!r.forward, !!r.wordEnd, !!r.bigWord);\\n        },\\n        moveTillCharacter: function (e, t, r) {\\n          var n = ge(e, r.repeat, r.forward, r.selectedCharacter),\\n            o = r.forward ? -1 : 1;\\n          return pe(o, r), n ? ((n.ch += o), n) : null;\\n        },\\n        moveToCharacter: function (e, t, r) {\\n          var n = r.repeat;\\n          return pe(0, r), ge(e, n, r.forward, r.selectedCharacter) || t;\\n        },\\n        moveToSymbol: function (e, t, r) {\\n          return (\\n            (function (e, t, r, n) {\\n              var o = z(e.getCursor()),\\n                i = r ? 1 : -1,\\n                a = r ? e.lineCount() : -1,\\n                s = o.ch,\\n                l = o.line,\\n                c = e.getLine(l),\\n                u = {\\n                  lineText: c,\\n                  nextCh: c.charAt(s),\\n                  lastCh: null,\\n                  index: s,\\n                  symb: n,\\n                  reverseSymb: (r\\n                    ? { \\\")\\\": \\\"(\\\", \\\"}\\\": \\\"{\\\" }\\n                    : { \\\"(\\\": \\\")\\\", \\\"{\\\": \\\"}\\\" })[n],\\n                  forward: r,\\n                  depth: 0,\\n                  curMoveThrough: !1,\\n                },\\n                h = fe[n];\\n              if (!h) return o;\\n              var p = de[h].init,\\n                f = de[h].isComplete;\\n              p && p(u);\\n              for (; l !== a && t; ) {\\n                var d;\\n                (u.index += i),\\n                  (u.nextCh = u.lineText.charAt(u.index)),\\n                  u.nextCh ||\\n                    ((l += i),\\n                    (u.lineText = e.getLine(l) || \\\"\\\"),\\n                    0 < i\\n                      ? (u.index = 0)\\n                      : ((d = u.lineText.length),\\n                        (u.index = 0 < d ? d - 1 : 0)),\\n                    (u.nextCh = u.lineText.charAt(u.index))),\\n                  f(u) && ((o.line = l), (o.ch = u.index), t--);\\n              }\\n              if (u.nextCh || u.curMoveThrough) return tt(l, u.index);\\n              return o;\\n            })(e, r.repeat, r.forward, r.selectedCharacter) || t\\n          );\\n        },\\n        moveToColumn: function (e, t, r, n) {\\n          var o,\\n            i,\\n            a,\\n            s = r.repeat;\\n          return (\\n            (n.lastHPos = s - 1),\\n            (n.lastHSPos = e.charCoords(t, \\\"div\\\").left),\\n            (i = s),\\n            (a = (o = e).getCursor().line),\\n            J(o, tt(a, i - 1))\\n          );\\n        },\\n        moveToEol: function (e, t, r, n) {\\n          return me(e, t, r, n, !1);\\n        },\\n        moveToFirstNonWhiteSpaceCharacter: function (e, t) {\\n          return tt(t.line, ce(e.getLine(t.line)));\\n        },\\n        moveToMatchedSymbol: function (e, t) {\\n          for (\\n            var r, n = t, o = n.line, i = n.ch, a = e.getLine(o);\\n            i < a.length;\\n            i++\\n          )\\n            if ((r = a.charAt(i)) && -1 != \\\"()[]{}\\\".indexOf(r)) {\\n              var s = e.getTokenTypeAt(tt(o, i + 1));\\n              if (\\\"string\\\" !== s && \\\"comment\\\" !== s) break;\\n            }\\n          if (i < a.length) {\\n            var l = \\\"<\\\" === i || \\\">\\\" === i ? /[(){}[\\\\]<>]/ : /[(){}[\\\\]]/;\\n            return e.findMatchingBracket(tt(o, i), { bracketRegex: l }).to;\\n          }\\n          return n;\\n        },\\n        moveToStartOfLine: function (e, t) {\\n          return tt(t.line, 0);\\n        },\\n        moveToLineOrEdgeOfDocument: function (e, t, r) {\\n          var n = r.forward ? e.lastLine() : e.firstLine();\\n          return (\\n            r.repeatIsExplicit &&\\n              (n = r.repeat - e.getOption(\\\"firstLineNumber\\\")),\\n            tt(n, ce(e.getLine(n)))\\n          );\\n        },\\n        textObjectManipulation: function (e, t, r, n) {\\n          var o = r.selectedCharacter;\\n          \\\"b\\\" == o ? (o = \\\"(\\\") : \\\"B\\\" == o && (o = \\\"{\\\");\\n          var i = !r.textObjectInner;\\n          if (\\n            {\\n              \\\"(\\\": \\\")\\\",\\n              \\\")\\\": \\\"(\\\",\\n              \\\"{\\\": \\\"}\\\",\\n              \\\"}\\\": \\\"{\\\",\\n              \\\"[\\\": \\\"]\\\",\\n              \\\"]\\\": \\\"[\\\",\\n              \\\"<\\\": \\\">\\\",\\n              \\\">\\\": \\\"<\\\",\\n            }[o]\\n          )\\n            s = (function (e, t, r, n) {\\n              var o,\\n                i,\\n                a = t,\\n                s = {\\n                  \\\"(\\\": /[()]/,\\n                  \\\")\\\": /[()]/,\\n                  \\\"[\\\": /[[\\\\]]/,\\n                  \\\"]\\\": /[[\\\\]]/,\\n                  \\\"{\\\": /[{}]/,\\n                  \\\"}\\\": /[{}]/,\\n                  \\\"<\\\": /[<>]/,\\n                  \\\">\\\": /[<>]/,\\n                }[r],\\n                l = {\\n                  \\\"(\\\": \\\"(\\\",\\n                  \\\")\\\": \\\"(\\\",\\n                  \\\"[\\\": \\\"[\\\",\\n                  \\\"]\\\": \\\"[\\\",\\n                  \\\"{\\\": \\\"{\\\",\\n                  \\\"}\\\": \\\"{\\\",\\n                  \\\"<\\\": \\\"<\\\",\\n                  \\\">\\\": \\\"<\\\",\\n                }[r],\\n                c = e.getLine(a.line).charAt(a.ch) === l ? 1 : 0;\\n              if (\\n                ((o = e.scanForBracket(tt(a.line, a.ch + c), -1, void 0, {\\n                  bracketRegex: s,\\n                })),\\n                (i = e.scanForBracket(tt(a.line, a.ch + c), 1, void 0, {\\n                  bracketRegex: s,\\n                })),\\n                !o || !i)\\n              )\\n                return { start: a, end: a };\\n              {\\n                var u;\\n                (o = o.pos),\\n                  (i = i.pos),\\n                  ((o.line == i.line && o.ch > i.ch) || o.line > i.line) &&\\n                    ((u = o), (o = i), (i = u));\\n              }\\n              n ? (i.ch += 1) : (o.ch += 1);\\n              return { start: o, end: i };\\n            })(e, t, o, i);\\n          else if ({ \\\"'\\\": !0, '\\\"': !0, \\\"`\\\": !0 }[o])\\n            s = (function (e, t, r, n) {\\n              var o,\\n                i,\\n                a,\\n                s,\\n                l = z(t),\\n                c = e.getLine(l.line).split(\\\"\\\"),\\n                u = c.indexOf(r);\\n              l.ch < u\\n                ? (l.ch = u)\\n                : u < l.ch && c[l.ch] == r && ((i = l.ch), --l.ch);\\n              if (c[l.ch] != r || i)\\n                for (a = l.ch; -1 < a && !o; a--) c[a] == r && (o = a + 1);\\n              else o = l.ch + 1;\\n              if (o && !i)\\n                for (a = o, s = c.length; a < s && !i; a++)\\n                  c[a] == r && (i = a);\\n              if (!o || !i) return { start: l, end: l };\\n              n && (--o, ++i);\\n              return { start: tt(l.line, o), end: tt(l.line, i) };\\n            })(e, t, o, i);\\n          else if (\\\"W\\\" === o) s = ue(e, i, 0, !0);\\n          else if (\\\"w\\\" === o) s = ue(e, i, 0, !1);\\n          else if (\\\"p\\\" === o) {\\n            var a,\\n              s = ye(e, t, r.repeat, 0, i);\\n            (r.linewise = !0),\\n              n.visualMode\\n                ? n.visualLine || (n.visualLine = !0)\\n                : ((a = n.inputState.operatorArgs) && (a.linewise = !0),\\n                  s.end.line--);\\n          } else {\\n            if (\\\"t\\\" !== o) return null;\\n            s = (function (e, t, r) {\\n              var n = t;\\n              if (!Ze.findMatchingTag || !Ze.findEnclosingTag)\\n                return { start: n, end: n };\\n              var o = Ze.findMatchingTag(e, t) || Ze.findEnclosingTag(e, t);\\n              if (!o || !o.open || !o.close) return { start: n, end: n };\\n              if (r) return { start: o.open.from, end: o.close.to };\\n              return { start: o.open.to, end: o.close.from };\\n            })(e, t, i);\\n          }\\n          return e.state.vim.visualMode\\n            ? (function (e, t, r) {\\n                var n,\\n                  o = e.state.vim.sel,\\n                  i = o.head,\\n                  a = o.anchor;\\n                Z(r, t) && ((n = r), (r = t), (t = n));\\n                Z(i, a)\\n                  ? ((i = G(t, i)), (a = Y(a, r)))\\n                  : ((a = G(t, a)),\\n                    -1 == (i = q((i = Y(i, r)), 0, -1)).ch &&\\n                      i.line != e.firstLine() &&\\n                      (i = tt(i.line - 1, te(e, i.line - 1))));\\n                return [a, i];\\n              })(e, s.start, s.end)\\n            : [s.start, s.end];\\n        },\\n        repeatLastCharacterSearch: function (e, t, r) {\\n          var n = K.lastCharacterSearch,\\n            o = r.repeat,\\n            i = r.forward === n.forward,\\n            a = (n.increment ? 1 : 0) * (i ? -1 : 1);\\n          e.moveH(-a, \\\"char\\\");\\n          var s = ge(e, o, (r.inclusive = i), n.selectedCharacter);\\n          return s ? ((s.ch += a), s) : (e.moveH(a, \\\"char\\\"), t);\\n        },\\n      };\\n    function V(e, t) {\\n      for (var r = [], n = 0; n < t; n++) r.push(e);\\n      return r;\\n    }\\n    var D = {\\n      change: function (e, t, r) {\\n        var n,\\n          o,\\n          i,\\n          a,\\n          s,\\n          l,\\n          c = e.state.vim,\\n          u = r[0].anchor,\\n          h = r[0].head,\\n          p = c.visualMode\\n            ? t.fullLine\\n              ? ((h.ch = Number.MAX_VALUE),\\n                h.line--,\\n                e.setSelection(u, h),\\n                (n = e.getSelection()),\\n                e.replaceSelection(\\\"\\\"),\\n                u)\\n              : ((n = e.getSelection()),\\n                (o = V(\\\"\\\", r.length)),\\n                e.replaceSelections(o),\\n                G(r[0].head, r[0].anchor))\\n            : ((n = e.getRange(u, h)),\\n              \\\"moveByWords\\\" != (i = c.lastEditInputState || {}).motion ||\\n                B(n) ||\\n                ((a = /\\\\s+$/.exec(n)) &&\\n                  i.motionArgs &&\\n                  i.motionArgs.forward &&\\n                  ((h = q(h, 0, -a[0].length)),\\n                  (n = n.slice(0, -a[0].length)))),\\n              (s = new tt(u.line - 1, Number.MAX_VALUE)),\\n              (l = e.firstLine() == e.lastLine()),\\n              h.line > e.lastLine() && t.linewise && !l\\n                ? e.replaceRange(\\\"\\\", s, h)\\n                : e.replaceRange(\\\"\\\", u, h),\\n              t.linewise &&\\n                (l || (e.setCursor(s), Ze.commands.newlineAndIndent(e)),\\n                (u.ch = Number.MAX_VALUE)),\\n              u);\\n        K.registerController.pushText(\\n          t.registerName,\\n          \\\"change\\\",\\n          n,\\n          t.linewise,\\n          1 < r.length\\n        ),\\n          U.enterInsertMode(e, { head: p }, e.state.vim);\\n      },\\n      delete: function (e, t, r) {\\n        var n,\\n          o,\\n          i,\\n          a,\\n          s,\\n          l = e.state.vim;\\n        return (\\n          l.visualBlock\\n            ? ((o = e.getSelection()),\\n              (i = V(\\\"\\\", r.length)),\\n              e.replaceSelections(i),\\n              (n = r[0].anchor))\\n            : ((a = r[0].anchor),\\n              (s = r[0].head),\\n              t.linewise &&\\n                s.line != e.firstLine() &&\\n                a.line == e.lastLine() &&\\n                a.line == s.line - 1 &&\\n                (a.line == e.firstLine()\\n                  ? (a.ch = 0)\\n                  : (a = tt(a.line - 1, te(e, a.line - 1)))),\\n              (o = e.getRange(a, s)),\\n              e.replaceRange(\\\"\\\", a, s),\\n              (n = a),\\n              t.linewise && (n = W.moveToFirstNonWhiteSpaceCharacter(e, a))),\\n          K.registerController.pushText(\\n            t.registerName,\\n            \\\"delete\\\",\\n            o,\\n            t.linewise,\\n            l.visualBlock\\n          ),\\n          J(e, n)\\n        );\\n      },\\n      indent: function (e, t, r) {\\n        var n = e.state.vim,\\n          o = r[0].anchor.line,\\n          i = n.visualBlock ? r[r.length - 1].anchor.line : r[0].head.line,\\n          a = n.visualMode ? t.repeat : 1;\\n        t.linewise && i--;\\n        for (var s = o; s <= i; s++)\\n          for (var l = 0; l < a; l++) e.indentLine(s, t.indentRight);\\n        return W.moveToFirstNonWhiteSpaceCharacter(e, r[0].anchor);\\n      },\\n      indentAuto: function (e, t, r) {\\n        return (\\n          e.execCommand(\\\"indentAuto\\\"),\\n          W.moveToFirstNonWhiteSpaceCharacter(e, r[0].anchor)\\n        );\\n      },\\n      changeCase: function (e, t, r, n, o) {\\n        for (\\n          var i = e.getSelections(), a = [], s = t.toLower, l = 0;\\n          l < i.length;\\n          l++\\n        ) {\\n          var c = i[l],\\n            u = \\\"\\\";\\n          if (!0 === s) u = c.toLowerCase();\\n          else if (!1 === s) u = c.toUpperCase();\\n          else\\n            for (var h = 0; h < c.length; h++) {\\n              var p = c.charAt(h);\\n              u += k(p) ? p.toLowerCase() : p.toUpperCase();\\n            }\\n          a.push(u);\\n        }\\n        return (\\n          e.replaceSelections(a),\\n          t.shouldMoveCursor\\n            ? o\\n            : !e.state.vim.visualMode &&\\n              t.linewise &&\\n              r[0].anchor.line + 1 == r[0].head.line\\n            ? W.moveToFirstNonWhiteSpaceCharacter(e, n)\\n            : t.linewise\\n            ? n\\n            : G(r[0].anchor, r[0].head)\\n        );\\n      },\\n      yank: function (e, t, r, n) {\\n        var o = e.state.vim,\\n          i = e.getSelection(),\\n          a = o.visualMode\\n            ? G(o.sel.anchor, o.sel.head, r[0].head, r[0].anchor)\\n            : n;\\n        return (\\n          K.registerController.pushText(\\n            t.registerName,\\n            \\\"yank\\\",\\n            i,\\n            t.linewise,\\n            o.visualBlock\\n          ),\\n          a\\n        );\\n      },\\n    };\\n    var U = {\\n      jumpListWalk: function (e, t, r) {\\n        var n, o, i, a;\\n        r.visualMode ||\\n          ((n = t.repeat),\\n          (o = t.forward),\\n          (a =\\n            (a = (i = K.jumpList.move(e, o ? n : -n)) ? i.find() : void 0) ||\\n            e.getCursor()),\\n          e.setCursor(a));\\n      },\\n      scroll: function (e, t, r) {\\n        var n, o, i, a, s, l, c, u;\\n        r.visualMode ||\\n          ((n = t.repeat || 1),\\n          (o = e.defaultTextHeight()),\\n          (i = e.getScrollInfo().top),\\n          (a = o * n),\\n          (s = t.forward ? i + a : i - a),\\n          (l = z(e.getCursor())),\\n          (c = e.charCoords(l, \\\"local\\\")),\\n          t.forward\\n            ? s > c.top\\n              ? ((l.line += (s - c.top) / o),\\n                (l.line = Math.ceil(l.line)),\\n                e.setCursor(l),\\n                (c = e.charCoords(l, \\\"local\\\")),\\n                e.scrollTo(null, c.top))\\n              : e.scrollTo(null, s)\\n            : (u = s + e.getScrollInfo().clientHeight) < c.bottom\\n            ? ((l.line -= (c.bottom - u) / o),\\n              (l.line = Math.floor(l.line)),\\n              e.setCursor(l),\\n              (c = e.charCoords(l, \\\"local\\\")),\\n              e.scrollTo(null, c.bottom - e.getScrollInfo().clientHeight))\\n            : e.scrollTo(null, s));\\n      },\\n      scrollToCursor: function (e, t) {\\n        var r = e.getCursor().line,\\n          n = e.charCoords(tt(r, 0), \\\"local\\\"),\\n          o = e.getScrollInfo().clientHeight,\\n          i = n.top,\\n          a = n.bottom - i;\\n        switch (t.position) {\\n          case \\\"center\\\":\\n            i = i - o / 2 + a;\\n            break;\\n          case \\\"bottom\\\":\\n            i = i - o + a;\\n        }\\n        e.scrollTo(null, i);\\n      },\\n      replayMacro: function (e, t, r) {\\n        var n = t.selectedCharacter,\\n          o = t.repeat,\\n          i = K.macroModeState;\\n        for (\\\"@\\\" == n ? (n = i.latestRegister) : (i.latestRegister = n); o--; )\\n          !(function (e, t, r, n) {\\n            var o = K.registerController.getRegister(n);\\n            if (\\\":\\\" == n)\\n              return (\\n                o.keyBuffer[0] && Fe.processCommand(e, o.keyBuffer[0]),\\n                (r.isPlaying = !1)\\n              );\\n            var i = o.keyBuffer,\\n              a = 0;\\n            (r.isPlaying = !0),\\n              (r.replaySearchQueries = o.searchQueries.slice(0));\\n            for (var s, l, c = 0; c < i.length; c++)\\n              for (var u, h = i[c]; h; ) {\\n                (s = /<\\\\w+-.+?>|<\\\\w+>|./.exec(h)),\\n                  (l = s[0]),\\n                  (h = h.substring(s.index + l.length)),\\n                  Ze.Vim.handleKey(e, l, \\\"macro\\\"),\\n                  t.insertMode &&\\n                    ((u = o.insertModeChanges[a++].changes),\\n                    (K.macroModeState.lastInsertModeChanges.changes = u),\\n                    Xe(e, u, 1),\\n                    We(e));\\n              }\\n            r.isPlaying = !1;\\n          })(e, r, i, n);\\n      },\\n      enterMacroRecordMode: function (e, t) {\\n        var r = K.macroModeState,\\n          n = t.selectedCharacter;\\n        K.registerController.isValidRegister(n) && r.enterMacroRecordMode(e, n);\\n      },\\n      toggleOverwrite: function (e) {\\n        e.state.overwrite\\n          ? (e.toggleOverwrite(!1),\\n            e.setOption(\\\"keyMap\\\", \\\"vim-insert\\\"),\\n            Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"insert\\\" }))\\n          : (e.toggleOverwrite(!0),\\n            e.setOption(\\\"keyMap\\\", \\\"vim-replace\\\"),\\n            Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"replace\\\" }));\\n      },\\n      enterInsertMode: function (e, t, r) {\\n        if (!e.getOption(\\\"readOnly\\\")) {\\n          (r.insertMode = !0), (r.insertModeRepeat = (t && t.repeat) || 1);\\n          var n = t ? t.insertAt : null,\\n            o = r.sel,\\n            i = t.head || e.getCursor(\\\"head\\\"),\\n            a = e.listSelections().length;\\n          if (\\\"eol\\\" == n) i = tt(i.line, te(e, i.line));\\n          else if (\\\"bol\\\" == n) i = tt(i.line, 0);\\n          else if (\\\"charAfter\\\" == n) i = q(i, 0, 1);\\n          else if (\\\"firstNonBlank\\\" == n)\\n            i = W.moveToFirstNonWhiteSpaceCharacter(e, i);\\n          else if (\\\"startOfSelectedArea\\\" == n) {\\n            if (!r.visualMode) return;\\n            r.visualBlock\\n              ? ((i = tt(\\n                  Math.min(o.head.line, o.anchor.line),\\n                  Math.min(o.head.ch, o.anchor.ch)\\n                )),\\n                (a = Math.abs(o.head.line - o.anchor.line) + 1))\\n              : (i =\\n                  o.head.line < o.anchor.line ? o.head : tt(o.anchor.line, 0));\\n          } else if (\\\"endOfSelectedArea\\\" == n) {\\n            if (!r.visualMode) return;\\n            r.visualBlock\\n              ? ((i = tt(\\n                  Math.min(o.head.line, o.anchor.line),\\n                  Math.max(o.head.ch + 1, o.anchor.ch)\\n                )),\\n                (a = Math.abs(o.head.line - o.anchor.line) + 1))\\n              : (i =\\n                  o.head.line >= o.anchor.line\\n                    ? q(o.head, 0, 1)\\n                    : tt(o.anchor.line, 0));\\n          } else if (\\\"inplace\\\" == n) {\\n            if (r.visualMode) return;\\n          } else \\\"lastEdit\\\" == n && (i = _e(e) || i);\\n          e.setOption(\\\"disableInput\\\", !1),\\n            t && t.replace\\n              ? (e.toggleOverwrite(!0),\\n                e.setOption(\\\"keyMap\\\", \\\"vim-replace\\\"),\\n                Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"replace\\\" }))\\n              : (e.toggleOverwrite(!1),\\n                e.setOption(\\\"keyMap\\\", \\\"vim-insert\\\"),\\n                Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"insert\\\" })),\\n            K.macroModeState.isPlaying ||\\n              (e.on(\\\"change\\\", De), Ze.on(e.getInputField(), \\\"keydown\\\", Qe)),\\n            r.visualMode && le(e),\\n            oe(e, i, a);\\n        }\\n      },\\n      toggleVisualMode: function (e, t, r) {\\n        var n,\\n          o = t.repeat,\\n          i = e.getCursor();\\n        r.visualMode\\n          ? r.visualLine ^ t.linewise || r.visualBlock ^ t.blockwise\\n            ? ((r.visualLine = !!t.linewise),\\n              (r.visualBlock = !!t.blockwise),\\n              Ze.signal(e, \\\"vim-mode-change\\\", {\\n                mode: \\\"visual\\\",\\n                subMode: r.visualLine\\n                  ? \\\"linewise\\\"\\n                  : r.visualBlock\\n                  ? \\\"blockwise\\\"\\n                  : \\\"\\\",\\n              }),\\n              ae(e))\\n            : le(e)\\n          : ((r.visualMode = !0),\\n            (r.visualLine = !!t.linewise),\\n            (r.visualBlock = !!t.blockwise),\\n            (n = J(e, tt(i.line, i.ch + o - 1))),\\n            (r.sel = { anchor: i, head: n }),\\n            Ze.signal(e, \\\"vim-mode-change\\\", {\\n              mode: \\\"visual\\\",\\n              subMode: r.visualLine\\n                ? \\\"linewise\\\"\\n                : r.visualBlock\\n                ? \\\"blockwise\\\"\\n                : \\\"\\\",\\n            }),\\n            ae(e),\\n            ve(e, r, \\\"<\\\", G(i, n)),\\n            ve(e, r, \\\">\\\", Y(i, n)));\\n      },\\n      reselectLastSelection: function (e, t, r) {\\n        var n = r.lastSelection;\\n        if ((r.visualMode && ie(e, r), n)) {\\n          var o = n.anchorMark.find(),\\n            i = n.headMark.find();\\n          if (!o || !i) return;\\n          (r.sel = { anchor: o, head: i }),\\n            (r.visualMode = !0),\\n            (r.visualLine = n.visualLine),\\n            (r.visualBlock = n.visualBlock),\\n            ae(e),\\n            ve(e, r, \\\"<\\\", G(o, i)),\\n            ve(e, r, \\\">\\\", Y(o, i)),\\n            Ze.signal(e, \\\"vim-mode-change\\\", {\\n              mode: \\\"visual\\\",\\n              subMode: r.visualLine\\n                ? \\\"linewise\\\"\\n                : r.visualBlock\\n                ? \\\"blockwise\\\"\\n                : \\\"\\\",\\n            });\\n        }\\n      },\\n      joinLines: function (e, t, r) {\\n        var n, o, i;\\n        r.visualMode\\n          ? ((o = e.getCursor(\\\"anchor\\\")),\\n            Z((n = e.getCursor(\\\"head\\\")), o) && ((l = n), (n = o), (o = l)),\\n            (n.ch = te(e, n.line) - 1))\\n          : ((i = Math.max(t.repeat, 2)),\\n            (o = e.getCursor()),\\n            (n = J(e, tt(o.line + i - 1, 1 / 0))));\\n        for (var a = 0, s = o.line; s < n.line; s++) {\\n          a = te(e, o.line);\\n          var l = tt(o.line + 1, te(e, o.line + 1)),\\n            c = e.getRange(o, l),\\n            c = t.keepSpaces\\n              ? c.replace(/\\\\n\\\\r?/g, \\\"\\\")\\n              : c.replace(/\\\\n\\\\s*/g, \\\" \\\");\\n          e.replaceRange(c, o, l);\\n        }\\n        var u = tt(o.line, a);\\n        r.visualMode && le(e, !1), e.setCursor(u);\\n      },\\n      newLineAndEnterInsertMode: function (e, t, r) {\\n        r.insertMode = !0;\\n        var n = z(e.getCursor());\\n        n.line !== e.firstLine() || t.after\\n          ? ((n.line = t.after ? n.line : n.line - 1),\\n            (n.ch = te(e, n.line)),\\n            e.setCursor(n),\\n            (\\n              Ze.commands.newlineAndIndentContinueComment ||\\n              Ze.commands.newlineAndIndent\\n            )(e))\\n          : (e.replaceRange(\\\"\\\\n\\\", tt(e.firstLine(), 0)),\\n            e.setCursor(e.firstLine(), 0)),\\n          this.enterInsertMode(e, { repeat: t.repeat }, r);\\n      },\\n      paste: function (n, e, t) {\\n        var o,\\n          i,\\n          r,\\n          a,\\n          s,\\n          l,\\n          c,\\n          u = z(n.getCursor()),\\n          h = K.registerController.getRegister(e.registerName),\\n          p = h.toString();\\n        if (p) {\\n          e.matchIndent &&\\n            ((o = n.getOption(\\\"tabSize\\\")),\\n            (i = function (e) {\\n              var t = e.split(\\\"\\\\t\\\").length - 1,\\n                r = e.split(\\\" \\\").length - 1;\\n              return t * o + r;\\n            }),\\n            (r = n.getLine(n.getCursor().line)),\\n            (a = i(r.match(/^\\\\s*/)[0])),\\n            (s = p.replace(/\\\\n$/, \\\"\\\")),\\n            (l = p !== s),\\n            (c = i(p.match(/^\\\\s*/)[0])),\\n            (p = s.replace(/^\\\\s*/gm, function (e) {\\n              var t = a + (i(e) - c);\\n              if (t < 0) return \\\"\\\";\\n              if (n.getOption(\\\"indentWithTabs\\\")) {\\n                var r = Math.floor(t / o);\\n                return Array(r + 1).join(\\\"\\\\t\\\");\\n              }\\n              return Array(t + 1).join(\\\" \\\");\\n            })),\\n            (p += l ? \\\"\\\\n\\\" : \\\"\\\")),\\n            1 < e.repeat && (p = Array(e.repeat + 1).join(p));\\n          var f,\\n            d,\\n            m,\\n            g,\\n            v,\\n            y,\\n            k,\\n            C,\\n            w,\\n            x,\\n            M,\\n            S = h.linewise,\\n            A = h.blockwise;\\n          if (A) {\\n            (p = p.split(\\\"\\\\n\\\")), S && p.pop();\\n            for (var b = 0; b < p.length; b++) p[b] = \\\"\\\" == p[b] ? \\\" \\\" : p[b];\\n            (u.ch += e.after ? 1 : 0), (u.ch = Math.min(te(n, u.line), u.ch));\\n          } else\\n            S\\n              ? t.visualMode\\n                ? (p = t.visualLine\\n                    ? p.slice(0, -1)\\n                    : \\\"\\\\n\\\" + p.slice(0, p.length - 1) + \\\"\\\\n\\\")\\n                : e.after\\n                ? ((p = \\\"\\\\n\\\" + p.slice(0, p.length - 1)),\\n                  (u.ch = te(n, u.line)))\\n                : (u.ch = 0)\\n              : (u.ch += e.after ? 1 : 0);\\n          if (t.visualMode) {\\n            t.lastPastedText = p;\\n            var L =\\n                ((w = n),\\n                (M = (x = t).lastSelection),\\n                (x.visualMode\\n                  ? function () {\\n                      var e = w.listSelections(),\\n                        t = e[0],\\n                        r = e[e.length - 1];\\n                      return [\\n                        Z(t.anchor, t.head) ? t.anchor : t.head,\\n                        Z(r.anchor, r.head) ? r.head : r.anchor,\\n                      ];\\n                    }\\n                  : function () {\\n                      var e = w.getCursor(),\\n                        t = w.getCursor(),\\n                        r = M.visualBlock;\\n                      if (r) {\\n                        for (\\n                          var n = r.width,\\n                            o = r.height,\\n                            t = tt(e.line + o, e.ch + n),\\n                            i = [],\\n                            a = e.line;\\n                          a < t.line;\\n                          a++\\n                        ) {\\n                          var s = { anchor: tt(a, e.ch), head: tt(a, t.ch) };\\n                          i.push(s);\\n                        }\\n                        w.setSelections(i);\\n                      } else {\\n                        var l = M.anchorMark.find(),\\n                          c = M.headMark.find(),\\n                          u = c.line - l.line,\\n                          h = c.ch - l.ch;\\n                        (t = { line: t.line + u, ch: u ? t.ch : h + t.ch }),\\n                          M.visualLine &&\\n                            ((e = tt(e.line, 0)),\\n                            (t = tt(t.line, te(w, t.line)))),\\n                          w.setSelection(e, t);\\n                      }\\n                      return [e, t];\\n                    })()),\\n              T = L[0],\\n              R = L[1],\\n              E = n.getSelection(),\\n              O = n.listSelections(),\\n              B = new Array(O.length).join(\\\"1\\\").split(\\\"1\\\");\\n            t.lastSelection && (m = t.lastSelection.headMark.find()),\\n              K.registerController.unnamedRegister.setText(E),\\n              (f = A\\n                ? (n.replaceSelections(B),\\n                  (R = tt(T.line + p.length - 1, T.ch)),\\n                  n.setCursor(T),\\n                  ne(n, R),\\n                  n.replaceSelections(p),\\n                  T)\\n                : t.visualBlock\\n                ? (n.replaceSelections(B),\\n                  n.setCursor(T),\\n                  n.replaceRange(p, T, T),\\n                  T)\\n                : (n.replaceRange(p, T, R),\\n                  n.posFromIndex(n.indexFromPos(T) + p.length - 1))),\\n              m && (t.lastSelection.headMark = n.setBookmark(m)),\\n              S && (f.ch = 0);\\n          } else if (A) {\\n            n.setCursor(u);\\n            for (b = 0; b < p.length; b++) {\\n              var I = u.line + b;\\n              I > n.lastLine() && n.replaceRange(\\\"\\\\n\\\", tt(I, 0)),\\n                te(n, I) < u.ch &&\\n                  ((g = n),\\n                  (v = I),\\n                  (y = u.ch),\\n                  0,\\n                  (k = te(g, v)),\\n                  (C = new Array(y - k + 1).join(\\\" \\\")),\\n                  g.setCursor(tt(v, k)),\\n                  g.replaceRange(C, g.getCursor()));\\n            }\\n            n.setCursor(u),\\n              ne(n, tt(u.line + p.length - 1, u.ch)),\\n              n.replaceSelections(p),\\n              (f = u);\\n          } else\\n            n.replaceRange(p, u),\\n              (f =\\n                S && e.after\\n                  ? tt(u.line + 1, ce(n.getLine(u.line + 1)))\\n                  : S && !e.after\\n                  ? tt(u.line, ce(n.getLine(u.line)))\\n                  : !S && e.after\\n                  ? ((d = n.indexFromPos(u)), n.posFromIndex(d + p.length - 1))\\n                  : ((d = n.indexFromPos(u)), n.posFromIndex(d + p.length)));\\n          t.visualMode && le(n, !1), n.setCursor(f);\\n        }\\n      },\\n      undo: function (e, t) {\\n        e.operation(function () {\\n          Q(e, Ze.commands.undo, t.repeat)(),\\n            e.setCursor(e.getCursor(\\\"anchor\\\"));\\n        });\\n      },\\n      redo: function (e, t) {\\n        Q(e, Ze.commands.redo, t.repeat)();\\n      },\\n      setRegister: function (e, t, r) {\\n        r.inputState.registerName = t.selectedCharacter;\\n      },\\n      setMark: function (e, t, r) {\\n        ve(e, r, t.selectedCharacter, e.getCursor());\\n      },\\n      replace: function (e, t, r) {\\n        var n,\\n          o,\\n          i,\\n          a,\\n          s = t.selectedCharacter,\\n          l = e.getCursor(),\\n          c = e.listSelections(),\\n          u = r.visualMode\\n            ? ((l = e.getCursor(\\\"start\\\")), e.getCursor(\\\"end\\\"))\\n            : ((n = e.getLine(l.line)),\\n              (o = l.ch + t.repeat) > n.length && (o = n.length),\\n              tt(l.line, o));\\n        \\\"\\\\n\\\" == s\\n          ? (r.visualMode || e.replaceRange(\\\"\\\", l, u),\\n            (\\n              Ze.commands.newlineAndIndentContinueComment ||\\n              Ze.commands.newlineAndIndent\\n            )(e))\\n          : ((a = (a = e.getRange(l, u)).replace(/[^\\\\n]/g, s)),\\n            r.visualBlock\\n              ? ((i = new Array(e.getOption(\\\"tabSize\\\") + 1).join(\\\" \\\")),\\n                (a = (a = e.getSelection())\\n                  .replace(/\\\\t/g, i)\\n                  .replace(/[^\\\\n]/g, s)\\n                  .split(\\\"\\\\n\\\")),\\n                e.replaceSelections(a))\\n              : e.replaceRange(a, l, u),\\n            r.visualMode\\n              ? ((l = Z(c[0].anchor, c[0].head) ? c[0].anchor : c[0].head),\\n                e.setCursor(l),\\n                le(e, !1))\\n              : e.setCursor(q(u, 0, -1)));\\n      },\\n      incrementNumberToken: function (e, t) {\\n        for (\\n          var r,\\n            n,\\n            o,\\n            i,\\n            a,\\n            s,\\n            l,\\n            c,\\n            u,\\n            h,\\n            p,\\n            f = e.getCursor(),\\n            d = e.getLine(f.line),\\n            m = /(-?)(?:(0x)([\\\\da-f]+)|(0b|0|)(\\\\d+))/gi;\\n          null !== (r = m.exec(d)) &&\\n          ((o = (n = r.index) + r[0].length), !(f.ch < o));\\n\\n        );\\n        (!t.backtrack && o <= f.ch) ||\\n          (r &&\\n            ((i = r[2] || r[4]),\\n            (a = r[3] || r[5]),\\n            (s = t.increase ? 1 : -1),\\n            (l = { \\\"0b\\\": 2, 0: 8, \\\"\\\": 10, \\\"0x\\\": 16 }[i.toLowerCase()]),\\n            (c = (parseInt(r[1] + a, l) + s * t.repeat).toString(l)),\\n            (u = i\\n              ? new Array(a.length - c.length + 1 + r[1].length).join(\\\"0\\\")\\n              : \\\"\\\"),\\n            (c = \\\"-\\\" === c.charAt(0) ? \\\"-\\\" + i + u + c.substr(1) : i + u + c),\\n            (h = tt(f.line, n)),\\n            (p = tt(f.line, o)),\\n            e.replaceRange(c, h, p),\\n            e.setCursor(tt(f.line, n + c.length - 1))));\\n      },\\n      repeatLastEdit: function (e, t, r) {\\n        var n;\\n        r.lastEditInputState &&\\n          ((n = t.repeat) && t.repeatIsExplicit\\n            ? (r.lastEditInputState.repeatOverride = n)\\n            : (n = r.lastEditInputState.repeatOverride || n),\\n          ze(e, r, n, !1));\\n      },\\n      indent: function (e, t) {\\n        e.indentLine(e.getCursor().line, t.indentRight);\\n      },\\n      exitInsertMode: We,\\n    };\\n    function J(e, t) {\\n      var r = e.state.vim,\\n        n = r.insertMode || r.visualMode,\\n        o = Math.min(Math.max(e.firstLine(), t.line), e.lastLine()),\\n        i = te(e, o) - 1 + !!n,\\n        a = Math.min(Math.max(0, t.ch), i);\\n      return tt(o, a);\\n    }\\n    function $(e) {\\n      var t = {};\\n      for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]);\\n      return t;\\n    }\\n    function q(e, t, r) {\\n      return (\\n        \\\"object\\\" == typeof t && ((r = t.ch), (t = t.line)),\\n        tt(e.line + t, e.ch + r)\\n      );\\n    }\\n    function Q(t, r, n) {\\n      return function () {\\n        for (var e = 0; e < n; e++) r(t);\\n      };\\n    }\\n    function z(e) {\\n      return tt(e.line, e.ch);\\n    }\\n    function X(e, t) {\\n      return e.ch == t.ch && e.line == t.line;\\n    }\\n    function Z(e, t) {\\n      return e.line < t.line || (e.line == t.line && e.ch < t.ch);\\n    }\\n    function G(e, t) {\\n      return (\\n        2 < arguments.length &&\\n          (t = G.apply(void 0, Array.prototype.slice.call(arguments, 1))),\\n        Z(e, t) ? e : t\\n      );\\n    }\\n    function Y(e, t) {\\n      return (\\n        2 < arguments.length &&\\n          (t = Y.apply(void 0, Array.prototype.slice.call(arguments, 1))),\\n        Z(e, t) ? t : e\\n      );\\n    }\\n    function ee(e, t, r) {\\n      var n = Z(e, t),\\n        o = Z(t, r);\\n      return n && o;\\n    }\\n    function te(e, t) {\\n      return e.getLine(t).length;\\n    }\\n    function re(e) {\\n      return e.trim ? e.trim() : e.replace(/^\\\\s+|\\\\s+$/g, \\\"\\\");\\n    }\\n    function ne(e, t) {\\n      var r = [],\\n        n = e.listSelections(),\\n        o = z(e.clipPos(t)),\\n        i = !X(t, o),\\n        a = (function (e, t, r) {\\n          for (var n = 0; n < e.length; n++) {\\n            var o = \\\"head\\\" != r && X(e[n].anchor, t),\\n              i = \\\"anchor\\\" != r && X(e[n].head, t);\\n            if (o || i) return n;\\n          }\\n          return -1;\\n        })(n, e.getCursor(\\\"head\\\")),\\n        s = X(n[a].head, n[a].anchor),\\n        l = n.length - 1,\\n        c = a < l - a ? l : 0,\\n        u = n[c].anchor,\\n        h = Math.min(u.line, o.line),\\n        p = Math.max(u.line, o.line),\\n        f = u.ch,\\n        d = o.ch,\\n        m = n[c].head.ch - f,\\n        g = d - f;\\n      0 < m && g <= 0\\n        ? (f++, i || d--)\\n        : m < 0 && 0 <= g\\n        ? (f--, s || d++)\\n        : m < 0 && -1 == g && (f--, d++);\\n      for (var v = h; v <= p; v++) {\\n        var y = { anchor: new tt(v, f), head: new tt(v, d) };\\n        r.push(y);\\n      }\\n      return e.setSelections(r), (t.ch = d), (u.ch = f), u;\\n    }\\n    function oe(e, t, r) {\\n      for (var n = [], o = 0; o < r; o++) {\\n        var i = q(t, o, 0);\\n        n.push({ anchor: i, head: i });\\n      }\\n      e.setSelections(n, 0);\\n    }\\n    function ie(e, t) {\\n      var r = t.sel.anchor,\\n        n = t.sel.head;\\n      t.lastPastedText &&\\n        ((n = e.posFromIndex(e.indexFromPos(r) + t.lastPastedText.length)),\\n        (t.lastPastedText = null)),\\n        (t.lastSelection = {\\n          anchorMark: e.setBookmark(r),\\n          headMark: e.setBookmark(n),\\n          anchor: z(r),\\n          head: z(n),\\n          visualMode: t.visualMode,\\n          visualLine: t.visualLine,\\n          visualBlock: t.visualBlock,\\n        });\\n    }\\n    function ae(e, t, r) {\\n      var n = e.state.vim,\\n        o = se(\\n          e,\\n          (t = t || n.sel),\\n          (r = r || n.visualLine ? \\\"line\\\" : n.visualBlock ? \\\"block\\\" : \\\"char\\\")\\n        );\\n      e.setSelections(o.ranges, o.primary), Je(e);\\n    }\\n    function se(e, t, r, n) {\\n      var o,\\n        i = z(t.head),\\n        a = z(t.anchor);\\n      if (\\\"char\\\" == r) {\\n        var s = n || Z(t.head, t.anchor) ? 0 : 1,\\n          l = Z(t.head, t.anchor) ? 1 : 0,\\n          i = q(t.head, 0, s);\\n        return {\\n          ranges: [{ anchor: (a = q(t.anchor, 0, l)), head: i }],\\n          primary: 0,\\n        };\\n      }\\n      if (\\\"line\\\" == r)\\n        return (\\n          Z(t.head, t.anchor)\\n            ? ((i.ch = 0), (a.ch = te(e, a.line)))\\n            : ((a.ch = 0),\\n              (o = e.lastLine()),\\n              i.line > o && (i.line = o),\\n              (i.ch = te(e, i.line))),\\n          { ranges: [{ anchor: a, head: i }], primary: 0 }\\n        );\\n      if (\\\"block\\\" == r) {\\n        for (\\n          var c = Math.min(a.line, i.line),\\n            u = Math.min(a.ch, i.ch),\\n            h = Math.max(a.line, i.line),\\n            p = Math.max(a.ch, i.ch) + 1,\\n            f = h - c + 1,\\n            d = i.line == c ? 0 : f - 1,\\n            m = [],\\n            g = 0;\\n          g < f;\\n          g++\\n        )\\n          m.push({ anchor: tt(c + g, u), head: tt(c + g, p) });\\n        return { ranges: m, primary: d };\\n      }\\n    }\\n    function le(e, t) {\\n      var r = e.state.vim;\\n      !1 !== t && e.setCursor(J(e, r.sel.head)),\\n        ie(e, r),\\n        (r.visualMode = !1),\\n        (r.visualLine = !1),\\n        (r.visualBlock = !1),\\n        r.insertMode || Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"normal\\\" }),\\n        $e(r);\\n    }\\n    function ce(e) {\\n      if (!e) return 0;\\n      var t = e.search(/\\\\S/);\\n      return -1 == t ? e.length : t;\\n    }\\n    function ue(e, t, r, n, o) {\\n      for (\\n        var i,\\n          a,\\n          s =\\n            ((a = (i = e).getCursor(\\\"head\\\")),\\n            1 == i.getSelection().length && (a = G(a, i.getCursor(\\\"anchor\\\"))),\\n            a),\\n          l = e.getLine(s.line),\\n          c = s.ch,\\n          u = o ? m[0] : g[0];\\n        !u(l.charAt(c));\\n\\n      )\\n        if (++c >= l.length) return null;\\n      n ? (u = g[0]) : (u = m[0])(l.charAt(c)) || (u = m[1]);\\n      for (var h = c, p = c; u(l.charAt(h)) && h < l.length; ) h++;\\n      for (; u(l.charAt(p)) && 0 <= p; ) p--;\\n      if ((p++, t)) {\\n        for (var f = h; /\\\\s/.test(l.charAt(h)) && h < l.length; ) h++;\\n        if (f == h) {\\n          for (var d = p; /\\\\s/.test(l.charAt(p - 1)) && 0 < p; ) p--;\\n          p = p || d;\\n        }\\n      }\\n      return { start: tt(s.line, p), end: tt(s.line, h) };\\n    }\\n    function he(e, t, r) {\\n      X(t, r) || K.jumpList.add(e, t, r);\\n    }\\n    function pe(e, t) {\\n      (K.lastCharacterSearch.increment = e),\\n        (K.lastCharacterSearch.forward = t.forward),\\n        (K.lastCharacterSearch.selectedCharacter = t.selectedCharacter);\\n    }\\n    var fe = {\\n        \\\"(\\\": \\\"bracket\\\",\\n        \\\")\\\": \\\"bracket\\\",\\n        \\\"{\\\": \\\"bracket\\\",\\n        \\\"}\\\": \\\"bracket\\\",\\n        \\\"[\\\": \\\"section\\\",\\n        \\\"]\\\": \\\"section\\\",\\n        \\\"*\\\": \\\"comment\\\",\\n        \\\"/\\\": \\\"comment\\\",\\n        m: \\\"method\\\",\\n        M: \\\"method\\\",\\n        \\\"#\\\": \\\"preprocess\\\",\\n      },\\n      de = {\\n        bracket: {\\n          isComplete: function (e) {\\n            if (e.nextCh === e.symb) {\\n              if ((e.depth++, 1 <= e.depth)) return !0;\\n            } else e.nextCh === e.reverseSymb && e.depth--;\\n            return !1;\\n          },\\n        },\\n        section: {\\n          init: function (e) {\\n            (e.curMoveThrough = !0),\\n              (e.symb = (e.forward ? \\\"]\\\" : \\\"[\\\") === e.symb ? \\\"{\\\" : \\\"}\\\");\\n          },\\n          isComplete: function (e) {\\n            return 0 === e.index && e.nextCh === e.symb;\\n          },\\n        },\\n        comment: {\\n          isComplete: function (e) {\\n            var t = \\\"*\\\" === e.lastCh && \\\"/\\\" === e.nextCh;\\n            return (e.lastCh = e.nextCh), t;\\n          },\\n        },\\n        method: {\\n          init: function (e) {\\n            (e.symb = \\\"m\\\" === e.symb ? \\\"{\\\" : \\\"}\\\"),\\n              (e.reverseSymb = \\\"{\\\" === e.symb ? \\\"}\\\" : \\\"{\\\");\\n          },\\n          isComplete: function (e) {\\n            return e.nextCh === e.symb;\\n          },\\n        },\\n        preprocess: {\\n          init: function (e) {\\n            e.index = 0;\\n          },\\n          isComplete: function (e) {\\n            if (\\\"#\\\" === e.nextCh) {\\n              var t = e.lineText.match(/#(\\\\w+)/)[1];\\n              if (\\\"endif\\\" === t) {\\n                if (e.forward && 0 === e.depth) return !0;\\n                e.depth++;\\n              } else if (\\\"if\\\" === t) {\\n                if (!e.forward && 0 === e.depth) return !0;\\n                e.depth--;\\n              }\\n              if (\\\"else\\\" === t && 0 === e.depth) return !0;\\n            }\\n            return !1;\\n          },\\n        },\\n      };\\n    function me(e, t, r, n, o) {\\n      var i = tt(t.line + r.repeat - 1, 1 / 0),\\n        a = e.clipPos(i);\\n      return (\\n        a.ch--,\\n        o ||\\n          ((n.lastHPos = 1 / 0), (n.lastHSPos = e.charCoords(a, \\\"div\\\").left)),\\n        i\\n      );\\n    }\\n    function ge(e, t, r, n) {\\n      for (var o, i = e.getCursor(), a = i.ch, s = 0; s < t; s++) {\\n        if (\\n          -1 ==\\n          (o = (function (e, t, r, n, o) {\\n            var i;\\n            n\\n              ? -1 == (i = t.indexOf(r, e + 1)) || o || --i\\n              : -1 == (i = t.lastIndexOf(r, e - 1)) || o || (i += 1);\\n            return i;\\n          })(a, e.getLine(i.line), n, r, !0))\\n        )\\n          return null;\\n        a = o;\\n      }\\n      return tt(e.getCursor().line, o);\\n    }\\n    function ve(e, t, r, n) {\\n      w(r, f) &&\\n        (t.marks[r] && t.marks[r].clear(), (t.marks[r] = e.setBookmark(n)));\\n    }\\n    function ye(t, e, r, n, o) {\\n      var i,\\n        a = e.line,\\n        s = t.firstLine(),\\n        l = t.lastLine(),\\n        c = a;\\n      function u(e) {\\n        return !t.getLine(e);\\n      }\\n      function h(e, t, r) {\\n        return r ? u(e) != u(e + t) : !u(e) && u(e + t);\\n      }\\n      if (n) {\\n        for (; s <= c && c <= l && 0 < r; ) h(c, n) && r--, (c += n);\\n        return new tt(c, 0);\\n      }\\n      var p,\\n        f = t.state.vim;\\n      f.visualLine &&\\n        h(a, 1, !0) &&\\n        h((p = f.sel.anchor).line, -1, !0) &&\\n        ((o && p.line == a) || (a += 1));\\n      for (var d = u(a), c = a; c <= l && r; c++)\\n        h(c, 1, !0) && ((o && u(c) == d) || r--);\\n      for (\\n        i = new tt(c, 0), l < c && !d ? (d = !0) : (o = !1), c = a;\\n        s < c && ((o && u(c) != d && c != a) || !h(c, -1, !0));\\n        c--\\n      );\\n      return { start: new tt(c, 0), end: i };\\n    }\\n    function ke() {}\\n    function Ce(e) {\\n      var t = e.state.vim;\\n      return t.searchState_ || (t.searchState_ = new ke());\\n    }\\n    function we(e, t) {\\n      var r = xe(e, t) || [];\\n      if (!r.length) return [];\\n      var n = [];\\n      if (0 === r[0]) {\\n        for (var o = 0; o < r.length; o++)\\n          \\\"number\\\" == typeof r[o] && n.push(e.substring(r[o] + 1, r[o + 1]));\\n        return n;\\n      }\\n    }\\n    function xe(e, t) {\\n      t = t || \\\"/\\\";\\n      for (var r = !1, n = [], o = 0; o < e.length; o++) {\\n        var i = e.charAt(o);\\n        r || i != t || n.push(o), (r = !r && \\\"\\\\\\\\\\\" == i);\\n      }\\n      return n;\\n    }\\n    M(\\\"pcre\\\", !0, \\\"boolean\\\"),\\n      (ke.prototype = {\\n        getQuery: function () {\\n          return K.query;\\n        },\\n        setQuery: function (e) {\\n          K.query = e;\\n        },\\n        getOverlay: function () {\\n          return this.searchOverlay;\\n        },\\n        setOverlay: function (e) {\\n          this.searchOverlay = e;\\n        },\\n        isReversed: function () {\\n          return K.isReversed;\\n        },\\n        setReversed: function (e) {\\n          K.isReversed = e;\\n        },\\n        getScrollbarAnnotate: function () {\\n          return this.annotate;\\n        },\\n        setScrollbarAnnotate: function (e) {\\n          this.annotate = e;\\n        },\\n      });\\n    var Me = { \\\"\\\\\\\\n\\\": \\\"\\\\n\\\", \\\"\\\\\\\\r\\\": \\\"\\\\r\\\", \\\"\\\\\\\\t\\\": \\\"\\\\t\\\" };\\n    function Se(e) {\\n      for (var t, r = !1, n = [], o = -1; o < e.length; o++) {\\n        var i = e.charAt(o) || \\\"\\\",\\n          a = e.charAt(o + 1) || \\\"\\\";\\n        Me[i + a]\\n          ? (n.push(Me[i + a]), o++)\\n          : r\\n          ? (n.push(i), (r = !1))\\n          : \\\"\\\\\\\\\\\" === i\\n          ? ((r = !0),\\n            (t = a),\\n            u.test(t) || \\\"$\\\" === a\\n              ? n.push(\\\"$\\\")\\n              : \\\"/\\\" !== a && \\\"\\\\\\\\\\\" !== a && n.push(\\\"\\\\\\\\\\\"))\\n          : (\\\"$\\\" === i && n.push(\\\"$\\\"), n.push(i), \\\"/\\\" === a && n.push(\\\"\\\\\\\\\\\"));\\n      }\\n      return n.join(\\\"\\\");\\n    }\\n    var Ae = {\\n      \\\"\\\\\\\\/\\\": \\\"/\\\",\\n      \\\"\\\\\\\\\\\\\\\\\\\": \\\"\\\\\\\\\\\",\\n      \\\"\\\\\\\\n\\\": \\\"\\\\n\\\",\\n      \\\"\\\\\\\\r\\\": \\\"\\\\r\\\",\\n      \\\"\\\\\\\\t\\\": \\\"\\\\t\\\",\\n      \\\"\\\\\\\\&\\\": \\\"&\\\",\\n    };\\n    function be(e, t, r) {\\n      if (\\n        (K.registerController.getRegister(\\\"/\\\").setText(e), e instanceof RegExp)\\n      )\\n        return e;\\n      var n,\\n        o,\\n        i = xe(e, \\\"/\\\");\\n      return (\\n        i.length\\n          ? ((n = e.substring(0, i[0])),\\n            (o = -1 != e.substring(i[0]).indexOf(\\\"i\\\")))\\n          : (n = e),\\n        n\\n          ? (A(\\\"pcre\\\") ||\\n              (n = (function (e) {\\n                for (var t = !1, r = [], n = -1; n < e.length; n++) {\\n                  var o = e.charAt(n) || \\\"\\\",\\n                    i = e.charAt(n + 1) || \\\"\\\",\\n                    a = i && -1 != \\\"|(){\\\".indexOf(i);\\n                  t\\n                    ? ((\\\"\\\\\\\\\\\" === o && a) || r.push(o), (t = !1))\\n                    : \\\"\\\\\\\\\\\" === o\\n                    ? ((t = !0),\\n                      i && -1 != \\\"}\\\".indexOf(i) && (a = !0),\\n                      (a && \\\"\\\\\\\\\\\" !== i) || r.push(o))\\n                    : (r.push(o), a && \\\"\\\\\\\\\\\" !== i && r.push(\\\"\\\\\\\\\\\"));\\n                }\\n                return r.join(\\\"\\\");\\n              })(n)),\\n            r && (t = /^[^A-Z]*$/.test(n)),\\n            new RegExp(n, t || o ? \\\"i\\\" : void 0))\\n          : null\\n      );\\n    }\\n    function Le(e, t) {\\n      e.openNotification\\n        ? e.openNotification('<span style=\\\"color: red\\\">' + t + \\\"</span>\\\", {\\n            bottom: !0,\\n            duration: 5e3,\\n          })\\n        : alert(t);\\n    }\\n    var Te = \\\"(Javascript regexp)\\\";\\n    function Re(e, t) {\\n      var r,\\n        n,\\n        o,\\n        i,\\n        a,\\n        s,\\n        l,\\n        c,\\n        u = (t.prefix || \\\"\\\") + \\\" \\\" + (t.desc || \\\"\\\"),\\n        h =\\n          ((r = t.prefix),\\n          (n = t.desc),\\n          (o =\\n            '<span style=\\\"font-family: monospace; white-space: pre\\\">' +\\n            (r || \\\"\\\") +\\n            '<input type=\\\"text\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\"></span>'),\\n          n && (o += ' <span style=\\\"color: #888\\\">' + n + \\\"</span>\\\"),\\n          o);\\n      (i = e),\\n        (a = h),\\n        (s = u),\\n        (l = t.onClose),\\n        (c = t),\\n        i.openDialog\\n          ? i.openDialog(a, l, {\\n              bottom: !0,\\n              value: c.value,\\n              onKeyDown: c.onKeyDown,\\n              onKeyUp: c.onKeyUp,\\n              selectValueOnOpen: !1,\\n            })\\n          : l(prompt(s, \\\"\\\"));\\n    }\\n    function Ee(e, t, r, n) {\\n      if (t) {\\n        var o = Ce(e),\\n          i = be(t, !!r, !!n);\\n        if (i)\\n          return (\\n            Be(e, i),\\n            (function (e, t) {\\n              if (e instanceof RegExp && t instanceof RegExp) {\\n                for (\\n                  var r = [\\\"global\\\", \\\"multiline\\\", \\\"ignoreCase\\\", \\\"source\\\"],\\n                    n = 0;\\n                  n < r.length;\\n                  n++\\n                ) {\\n                  var o = r[n];\\n                  if (e[o] !== t[o]) return;\\n                }\\n                return 1;\\n              }\\n            })(i, o.getQuery()) || o.setQuery(i),\\n            i\\n          );\\n      }\\n    }\\n    var Oe = 0;\\n    function Be(o, i) {\\n      clearTimeout(Oe),\\n        (Oe = setTimeout(function () {\\n          var r,\\n            n,\\n            e = Ce(o),\\n            t = e.getOverlay();\\n          (t && i == t.query) ||\\n            (t && o.removeOverlay(t),\\n            \\\"^\\\" == (r = i).source.charAt(0) && (n = !0),\\n            (t = {\\n              token: function (e) {\\n                if (!n || e.sol()) {\\n                  var t = e.match(r, !1);\\n                  if (t)\\n                    return 0 == t[0].length\\n                      ? (e.next(), \\\"searching\\\")\\n                      : e.sol() || (e.backUp(1), r.exec(e.next() + t[0]))\\n                      ? (e.match(r), \\\"searching\\\")\\n                      : (e.next(), null);\\n                  for (; !e.eol() && (e.next(), !e.match(r, !1)); );\\n                } else e.skipToEnd();\\n              },\\n              query: r,\\n            }),\\n            o.addOverlay(t),\\n            o.showMatchesOnScrollbar &&\\n              (e.getScrollbarAnnotate() && e.getScrollbarAnnotate().clear(),\\n              e.setScrollbarAnnotate(o.showMatchesOnScrollbar(i))),\\n            e.setOverlay(t));\\n        }, 50));\\n    }\\n    function Ie(o, i, a, s) {\\n      return (\\n        void 0 === s && (s = 1),\\n        o.operation(function () {\\n          for (\\n            var e = o.getCursor(), t = o.getSearchCursor(a, e), r = 0;\\n            r < s;\\n            r++\\n          ) {\\n            var n = t.find(i);\\n            if (\\n              (0 == r && n && X(t.from(), e) && (n = t.find(i)),\\n              !n &&\\n                !(t = o.getSearchCursor(\\n                  a,\\n                  i ? tt(o.lastLine()) : tt(o.firstLine(), 0)\\n                )).find(i))\\n            )\\n              return;\\n          }\\n          return t.from();\\n        })\\n      );\\n    }\\n    function Ke(e) {\\n      var t = Ce(e);\\n      e.removeOverlay(Ce(e).getOverlay()),\\n        t.setOverlay(null),\\n        t.getScrollbarAnnotate() &&\\n          (t.getScrollbarAnnotate().clear(), t.setScrollbarAnnotate(null));\\n    }\\n    function Ne(e) {\\n      var t = e.getScrollInfo(),\\n        r = e.coordsChar({ left: 0, top: 6 + t.top }, \\\"local\\\"),\\n        n = t.clientHeight - 10 + t.top,\\n        o = e.coordsChar({ left: 0, top: n }, \\\"local\\\");\\n      return { top: r.line, bottom: o.line };\\n    }\\n    function Pe(e, t, r) {\\n      if (\\\"'\\\" == r || \\\"`\\\" == r) return K.jumpList.find(e, -1) || tt(0, 0);\\n      if (\\\".\\\" == r) return _e(e);\\n      var n = t.marks[r];\\n      return n && n.find();\\n    }\\n    function _e(e) {\\n      for (var t = e.doc.history.done, r = t.length; r--; )\\n        if (t[r].changes) return z(t[r].changes[0].to);\\n    }\\n    function je() {\\n      this.buildCommandMap_();\\n    }\\n    je.prototype = {\\n      processCommand: function (e, t, r) {\\n        var n = this;\\n        e.operation(function () {\\n          (e.curOp.isVimOp = !0), n._processCommand(e, t, r);\\n        });\\n      },\\n      _processCommand: function (t, e, r) {\\n        var n = t.state.vim,\\n          o = K.registerController.getRegister(\\\":\\\"),\\n          i = o.toString();\\n        n.visualMode && le(t);\\n        var a = new Ze.StringStream(e);\\n        o.setText(e);\\n        var s,\\n          l,\\n          c = r || {};\\n        c.input = e;\\n        try {\\n          this.parseInput_(t, a, c);\\n        } catch (e) {\\n          throw (Le(t, e), e);\\n        }\\n        if (c.commandName) {\\n          if ((s = this.matchCommand_(c.commandName))) {\\n            if (\\n              ((l = s.name),\\n              s.excludeFromCommandHistory && o.setText(i),\\n              this.parseCommandArgs_(a, c, s),\\n              \\\"exToKey\\\" == s.type)\\n            ) {\\n              for (var u = 0; u < s.toKeys.length; u++)\\n                Ze.Vim.handleKey(t, s.toKeys[u], \\\"mapping\\\");\\n              return;\\n            }\\n            if (\\\"exToEx\\\" == s.type)\\n              return void this.processCommand(t, s.toInput);\\n          }\\n        } else void 0 !== c.line && (l = \\\"move\\\");\\n        if (l)\\n          try {\\n            He[l](t, c), (s && s.possiblyAsync) || !c.callback || c.callback();\\n          } catch (e) {\\n            throw (Le(t, e), e);\\n          }\\n        else Le(t, 'Not an editor command \\\":' + e + '\\\"');\\n      },\\n      parseInput_: function (e, t, r) {\\n        t.eatWhile(\\\":\\\"),\\n          t.eat(\\\"%\\\")\\n            ? ((r.line = e.firstLine()), (r.lineEnd = e.lastLine()))\\n            : ((r.line = this.parseLineSpec_(e, t)),\\n              void 0 !== r.line &&\\n                t.eat(\\\",\\\") &&\\n                (r.lineEnd = this.parseLineSpec_(e, t)));\\n        var n = t.match(/^(\\\\w+|!!|@@|[!#&*<=>@~])/);\\n        return (r.commandName = n ? n[1] : t.match(/.*/)[0]), r;\\n      },\\n      parseLineSpec_: function (e, t) {\\n        var r = t.match(/^(\\\\d+)/);\\n        if (r) return parseInt(r[1], 10) - 1;\\n        switch (t.next()) {\\n          case \\\".\\\":\\n            return this.parseLineSpecOffset_(t, e.getCursor().line);\\n          case \\\"$\\\":\\n            return this.parseLineSpecOffset_(t, e.lastLine());\\n          case \\\"'\\\":\\n            var n = t.next(),\\n              o = Pe(e, e.state.vim, n);\\n            if (!o) throw new Error(\\\"Mark not set\\\");\\n            return this.parseLineSpecOffset_(t, o.line);\\n          case \\\"-\\\":\\n          case \\\"+\\\":\\n            return (\\n              t.backUp(1), this.parseLineSpecOffset_(t, e.getCursor().line)\\n            );\\n          default:\\n            return void t.backUp(1);\\n        }\\n      },\\n      parseLineSpecOffset_: function (e, t) {\\n        var r,\\n          n = e.match(/^([+-])?(\\\\d+)/);\\n        return (\\n          n && ((r = parseInt(n[2], 10)), \\\"-\\\" == n[1] ? (t -= r) : (t += r)), t\\n        );\\n      },\\n      parseCommandArgs_: function (e, t, r) {\\n        var n, o;\\n        e.eol() ||\\n          ((t.argString = e.match(/.*/)[0]),\\n          (n = r.argDelimiter || /\\\\s+/),\\n          (o = re(t.argString).split(n)).length && o[0] && (t.args = o));\\n      },\\n      matchCommand_: function (e) {\\n        for (var t = e.length; 0 < t; t--) {\\n          var r = e.substring(0, t);\\n          if (this.commandMap_[r]) {\\n            var n = this.commandMap_[r];\\n            if (0 === n.name.indexOf(e)) return n;\\n          }\\n        }\\n        return null;\\n      },\\n      buildCommandMap_: function () {\\n        this.commandMap_ = {};\\n        for (var e = 0; e < et.length; e++) {\\n          var t = et[e],\\n            r = t.shortName || t.name;\\n          this.commandMap_[r] = t;\\n        }\\n      },\\n      map: function (e, t, r) {\\n        if (\\\":\\\" != e && \\\":\\\" == e.charAt(0)) {\\n          if (r) throw Error(\\\"Mode not supported for ex mappings\\\");\\n          var n = e.substring(1);\\n          \\\":\\\" != t && \\\":\\\" == t.charAt(0)\\n            ? (this.commandMap_[n] = {\\n                name: n,\\n                type: \\\"exToEx\\\",\\n                toInput: t.substring(1),\\n                user: !0,\\n              })\\n            : (this.commandMap_[n] = {\\n                name: n,\\n                type: \\\"exToKey\\\",\\n                toKeys: t,\\n                user: !0,\\n              });\\n        } else {\\n          var o;\\n          (o =\\n            \\\":\\\" != t && \\\":\\\" == t.charAt(0)\\n              ? { keys: e, type: \\\"keyToEx\\\", exArgs: { input: t.substring(1) } }\\n              : { keys: e, type: \\\"keyToKey\\\", toKeys: t }),\\n            r && (o.context = r),\\n            Ge.unshift(o);\\n        }\\n      },\\n      unmap: function (e, t) {\\n        if (\\\":\\\" != e && \\\":\\\" == e.charAt(0)) {\\n          if (t) throw Error(\\\"Mode not supported for ex mappings\\\");\\n          var r = e.substring(1);\\n          if (this.commandMap_[r] && this.commandMap_[r].user)\\n            return void delete this.commandMap_[r];\\n        } else\\n          for (var n = e, o = 0; o < Ge.length; o++)\\n            if (n == Ge[o].keys && Ge[o].context === t)\\n              return void Ge.splice(o, 1);\\n        throw Error(\\\"No such mapping.\\\");\\n      },\\n    };\\n    var He = {\\n        colorscheme: function (e, t) {\\n          !t.args || t.args.length < 1\\n            ? Le(e, e.getOption(\\\"theme\\\"))\\n            : e.setOption(\\\"theme\\\", t.args[0]);\\n        },\\n        map: function (e, t, r) {\\n          var n = t.args;\\n          !n || n.length < 2\\n            ? e && Le(e, \\\"Invalid mapping: \\\" + t.input)\\n            : Fe.map(n[0], n[1], r);\\n        },\\n        imap: function (e, t) {\\n          this.map(e, t, \\\"insert\\\");\\n        },\\n        nmap: function (e, t) {\\n          this.map(e, t, \\\"normal\\\");\\n        },\\n        vmap: function (e, t) {\\n          this.map(e, t, \\\"visual\\\");\\n        },\\n        unmap: function (e, t, r) {\\n          var n = t.args;\\n          !n || n.length < 1\\n            ? e && Le(e, \\\"No such mapping: \\\" + t.input)\\n            : Fe.unmap(n[0], r);\\n        },\\n        move: function (e, t) {\\n          F.processCommand(e, e.state.vim, {\\n            type: \\\"motion\\\",\\n            motion: \\\"moveToLineOrEdgeOfDocument\\\",\\n            motionArgs: { forward: !1, explicitRepeat: !0, linewise: !0 },\\n            repeatOverride: t.line + 1,\\n          });\\n        },\\n        set: function (e, t) {\\n          var r = t.args,\\n            n = t.setCfg || {};\\n          if (!r || r.length < 1) e && Le(e, \\\"Invalid mapping: \\\" + t.input);\\n          else {\\n            var o = r[0].split(\\\"=\\\"),\\n              i = o[0],\\n              a = o[1],\\n              s = !1;\\n            if (\\\"?\\\" == i.charAt(i.length - 1)) {\\n              if (a) throw Error(\\\"Trailing characters: \\\" + t.argString);\\n              (i = i.substring(0, i.length - 1)), (s = !0);\\n            }\\n            void 0 === a &&\\n              \\\"no\\\" == i.substring(0, 2) &&\\n              ((i = i.substring(2)), (a = !1));\\n            var l,\\n              c,\\n              u = x[i] && \\\"boolean\\\" == x[i].type;\\n            u && null == a && (a = !0),\\n              (!u && void 0 === a) || s\\n                ? (l = A(i, e, n)) instanceof Error\\n                  ? Le(e, l.message)\\n                  : Le(\\n                      e,\\n                      !0 === l || !1 === l\\n                        ? \\\" \\\" + (l ? \\\"\\\" : \\\"no\\\") + i\\n                        : \\\"  \\\" + i + \\\"=\\\" + l\\n                    )\\n                : (c = S(i, a, e, n)) instanceof Error && Le(e, c.message);\\n          }\\n        },\\n        setlocal: function (e, t) {\\n          (t.setCfg = { scope: \\\"local\\\" }), this.set(e, t);\\n        },\\n        setglobal: function (e, t) {\\n          (t.setCfg = { scope: \\\"global\\\" }), this.set(e, t);\\n        },\\n        registers: function (e, t) {\\n          var r = t.args,\\n            n = K.registerController.registers,\\n            o = \\\"----------Registers----------<br><br>\\\";\\n          if (r)\\n            for (var r = r.join(\\\"\\\"), i = 0; i < r.length; i++) {\\n              (a = r.charAt(i)),\\n                K.registerController.isValidRegister(a) &&\\n                  (o +=\\n                    '\\\"' + a + \\\"    \\\" + (n[a] || new _()).toString() + \\\"<br>\\\");\\n            }\\n          else\\n            for (var a in n) {\\n              var s = n[a].toString();\\n              s.length && (o += '\\\"' + a + \\\"    \\\" + s + \\\"<br>\\\");\\n            }\\n          Le(e, o);\\n        },\\n        sort: function (e, i) {\\n          var a, s, l, c, u;\\n          var t = (function () {\\n            if (i.argString) {\\n              var e = new Ze.StringStream(i.argString);\\n              if ((e.eat(\\\"!\\\") && (a = !0), e.eol())) return;\\n              if (!e.eatSpace()) return \\\"Invalid arguments\\\";\\n              var t = e.match(/([dinuox]+)?\\\\s*(\\\\/.+\\\\/)?\\\\s*/);\\n              if (!t && !e.eol()) return \\\"Invalid arguments\\\";\\n              if (t[1]) {\\n                (s = -1 != t[1].indexOf(\\\"i\\\")), (l = -1 != t[1].indexOf(\\\"u\\\"));\\n                var r =\\n                    -1 != t[1].indexOf(\\\"d\\\") || (-1 != t[1].indexOf(\\\"n\\\") && 1),\\n                  n = -1 != t[1].indexOf(\\\"x\\\") && 1,\\n                  o = -1 != t[1].indexOf(\\\"o\\\") && 1;\\n                if (1 < r + n + o) return \\\"Invalid arguments\\\";\\n                c = (r ? \\\"decimal\\\" : n && \\\"hex\\\") || (o && \\\"octal\\\");\\n              }\\n              t[2] &&\\n                (u = new RegExp(t[2].substr(1, t[2].length - 2), s ? \\\"i\\\" : \\\"\\\"));\\n            }\\n          })();\\n          if (t) Le(e, t + \\\": \\\" + i.argString);\\n          else {\\n            var r = i.line || e.firstLine(),\\n              n = i.lineEnd || i.line || e.lastLine();\\n            if (r != n) {\\n              var o = tt(r, 0),\\n                h = tt(n, te(e, n)),\\n                p = e.getRange(o, h).split(\\\"\\\\n\\\"),\\n                f =\\n                  u ||\\n                  (\\\"decimal\\\" == c\\n                    ? /(-?)([\\\\d]+)/\\n                    : \\\"hex\\\" == c\\n                    ? /(-?)(?:0x)?([0-9a-f]+)/i\\n                    : \\\"octal\\\" == c\\n                    ? /([0-7]+)/\\n                    : null),\\n                d =\\n                  \\\"decimal\\\" == c\\n                    ? 10\\n                    : \\\"hex\\\" == c\\n                    ? 16\\n                    : \\\"octal\\\" == c\\n                    ? 8\\n                    : null,\\n                m = [],\\n                g = [];\\n              if (c || u)\\n                for (var v = 0; v < p.length; v++) {\\n                  var y = u ? p[v].match(u) : null;\\n                  y && \\\"\\\" != y[0]\\n                    ? m.push(y)\\n                    : !u && f.exec(p[v])\\n                    ? m.push(p[v])\\n                    : g.push(p[v]);\\n                }\\n              else g = p;\\n              if (\\n                (m.sort(\\n                  u\\n                    ? function (e, t) {\\n                        var r;\\n                        return (\\n                          a && ((r = e), (e = t), (t = r)),\\n                          s &&\\n                            ((e[0] = e[0].toLowerCase()),\\n                            (t[0] = t[0].toLowerCase())),\\n                          e[0] < t[0] ? -1 : 1\\n                        );\\n                      }\\n                    : w\\n                ),\\n                u)\\n              )\\n                for (v = 0; v < m.length; v++) m[v] = m[v].input;\\n              else c || g.sort(w);\\n              if (((p = a ? m.concat(g) : g.concat(m)), l))\\n                for (var k, C = p, p = [], v = 0; v < C.length; v++)\\n                  C[v] != k && p.push(C[v]), (k = C[v]);\\n              e.replaceRange(p.join(\\\"\\\\n\\\"), o, h);\\n            }\\n          }\\n          function w(e, t) {\\n            var r;\\n            a && ((r = e), (e = t), (t = r)),\\n              s && ((e = e.toLowerCase()), (t = t.toLowerCase()));\\n            var n = c && f.exec(e),\\n              o = c && f.exec(t);\\n            return n\\n              ? (n = parseInt((n[1] + n[2]).toLowerCase(), d)) -\\n                  (o = parseInt((o[1] + o[2]).toLowerCase(), d))\\n              : e < t\\n              ? -1\\n              : 1;\\n          }\\n        },\\n        global: function (t, e) {\\n          var r = e.argString;\\n          if (r) {\\n            var n,\\n              o = void 0 !== e.line ? e.line : t.firstLine(),\\n              i = e.lineEnd || e.line || t.lastLine(),\\n              a = we(r, \\\"/\\\"),\\n              s = r;\\n            if (\\n              (a.length && ((s = a[0]), (n = a.slice(1, a.length).join(\\\"/\\\"))),\\n              s)\\n            )\\n              try {\\n                Ee(t, s, !0, !0);\\n              } catch (e) {\\n                return void Le(t, \\\"Invalid regex: \\\" + s);\\n              }\\n            for (\\n              var l, c, u = Ce(t).getQuery(), h = [], p = \\\"\\\", f = o;\\n              f <= i;\\n              f++\\n            ) {\\n              u.test(t.getLine(f)) &&\\n                (h.push(f + 1), (p += t.getLine(f) + \\\"<br>\\\"));\\n            }\\n            n\\n              ? ((l = 0),\\n                (c = function () {\\n                  var e;\\n                  l < h.length &&\\n                    ((e = h[l] + n), Fe.processCommand(t, e, { callback: c })),\\n                    l++;\\n                })())\\n              : Le(t, p);\\n          } else Le(t, \\\"Regular Expression missing from global\\\");\\n        },\\n        substitute: function (t, e) {\\n          if (!t.getSearchCursor)\\n            throw new Error(\\n              \\\"Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.\\\"\\n            );\\n          var r,\\n            n,\\n            o,\\n            i,\\n            a,\\n            s,\\n            l,\\n            c,\\n            u,\\n            h = e.argString,\\n            p = h ? we(h, h[0]) : [],\\n            f = \\\"\\\",\\n            d = !1,\\n            m = !1;\\n          if (p.length)\\n            (r = p[0]),\\n              A(\\\"pcre\\\") && \\\"\\\" !== r && (r = new RegExp(r).source),\\n              (f = p[1]),\\n              r &&\\n                \\\"$\\\" === r[r.length - 1] &&\\n                ((r = r.slice(0, r.length - 1) + \\\"\\\\\\\\n\\\"),\\n                (f = f ? f + \\\"\\\\n\\\" : \\\"\\\\n\\\")),\\n              void 0 !== f &&\\n                ((f = A(\\\"pcre\\\")\\n                  ? (function (e) {\\n                      for (var t = new Ze.StringStream(e), r = []; !t.eol(); ) {\\n                        for (; t.peek() && \\\"\\\\\\\\\\\" != t.peek(); ) r.push(t.next());\\n                        var n = !1;\\n                        for (var o in Ae)\\n                          if (t.match(o, !0)) {\\n                            (n = !0), r.push(Ae[o]);\\n                            break;\\n                          }\\n                        n || r.push(t.next());\\n                      }\\n                      return r.join(\\\"\\\");\\n                    })(f.replace(/([^\\\\\\\\])&/g, \\\"$1$$&\\\"))\\n                  : Se(f)),\\n                (K.lastSubstituteReplacePart = f)),\\n              (n = p[2] ? p[2].split(\\\" \\\") : []);\\n          else if (h && h.length)\\n            return void Le(\\n              t,\\n              \\\"Substitutions should be of the form :s/pattern/replace/\\\"\\n            );\\n          if (\\n            (n &&\\n              ((o = n[0]),\\n              (i = parseInt(n[1])),\\n              o &&\\n                (-1 != o.indexOf(\\\"c\\\") && ((d = !0), o.replace(\\\"c\\\", \\\"\\\")),\\n                -1 != o.indexOf(\\\"g\\\") && ((m = !0), o.replace(\\\"g\\\", \\\"\\\")),\\n                (r = A(\\\"pcre\\\")\\n                  ? r + \\\"/\\\" + o\\n                  : r.replace(/\\\\//g, \\\"\\\\\\\\/\\\") + \\\"/\\\" + o))),\\n            r)\\n          )\\n            try {\\n              Ee(t, r, !0, !0);\\n            } catch (e) {\\n              return void Le(t, \\\"Invalid regex: \\\" + r);\\n            }\\n          void 0 !== (f = f || K.lastSubstituteReplacePart)\\n            ? ((a = Ce(t).getQuery()),\\n              (s = void 0 !== e.line ? e.line : t.getCursor().line),\\n              (l = e.lineEnd || s),\\n              s == t.firstLine() && l == t.lastLine() && (l = 1 / 0),\\n              i && (l = (s = l) + i - 1),\\n              (c = J(t, tt(s, 0))),\\n              (u = t.getSearchCursor(a, c)),\\n              (function (o, e, n, i, a, s, t, r, l) {\\n                o.state.vim.exMode = !0;\\n                var c = !1,\\n                  u = s.from();\\n                function h() {\\n                  o.operation(function () {\\n                    for (; !c; ) p(), f();\\n                    d();\\n                  });\\n                }\\n                function p() {\\n                  var e = o.getRange(s.from(), s.to()).replace(t, r);\\n                  s.replace(e);\\n                }\\n                function f() {\\n                  for (\\n                    ;\\n                    s.findNext() &&\\n                    ((e = s.from()),\\n                    (t = i),\\n                    (r = a),\\n                    \\\"number\\\" != typeof e && (e = e.line),\\n                    t instanceof Array\\n                      ? w(e, t)\\n                      : r\\n                      ? t <= e && e <= r\\n                      : e == t);\\n\\n                  )\\n                    if (n || !u || s.from().line != u.line)\\n                      return (\\n                        o.scrollIntoView(s.from(), 30),\\n                        o.setSelection(s.from(), s.to()),\\n                        (u = s.from()),\\n                        void (c = !1)\\n                      );\\n                  var e, t, r;\\n                  c = !0;\\n                }\\n                function d(e) {\\n                  var t;\\n                  e && e(),\\n                    o.focus(),\\n                    u &&\\n                      (o.setCursor(u),\\n                      ((t = o.state.vim).exMode = !1),\\n                      (t.lastHPos = t.lastHSPos = u.ch)),\\n                    l && l();\\n                }\\n                if ((f(), c)) return Le(o, \\\"No matches for \\\" + t.source);\\n                if (!e) return h(), l && l();\\n                Re(o, {\\n                  prefix: \\\"replace with <strong>\\\" + r + \\\"</strong> (y/n/a/q/l)\\\",\\n                  onKeyDown: function (e, t, r) {\\n                    switch ((Ze.e_stop(e), Ze.keyName(e))) {\\n                      case \\\"Y\\\":\\n                        p(), f();\\n                        break;\\n                      case \\\"N\\\":\\n                        f();\\n                        break;\\n                      case \\\"A\\\":\\n                        var n = l;\\n                        (l = void 0), o.operation(h), (l = n);\\n                        break;\\n                      case \\\"L\\\":\\n                        p();\\n                      case \\\"Q\\\":\\n                      case \\\"Esc\\\":\\n                      case \\\"Ctrl-C\\\":\\n                      case \\\"Ctrl-[\\\":\\n                        d(r);\\n                    }\\n                    return c && d(r), !0;\\n                  },\\n                });\\n              })(t, d, m, s, l, u, a, f, e.callback))\\n            : Le(t, \\\"No previous substitute regular expression\\\");\\n        },\\n        redo: Ze.commands.redo,\\n        undo: Ze.commands.undo,\\n        write: function (e) {\\n          Ze.commands.save ? Ze.commands.save(e) : e.save && e.save();\\n        },\\n        nohlsearch: function (e) {\\n          Ke(e);\\n        },\\n        yank: function (e) {\\n          var t = z(e.getCursor()).line,\\n            r = e.getLine(t);\\n          K.registerController.pushText(\\\"0\\\", \\\"yank\\\", r, !0, !0);\\n        },\\n        delmarks: function (e, t) {\\n          if (t.argString && re(t.argString))\\n            for (\\n              var r = e.state.vim, n = new Ze.StringStream(re(t.argString));\\n              !n.eol();\\n\\n            ) {\\n              n.eatSpace();\\n              var o = n.pos;\\n              if (!n.match(/[a-zA-Z]/, !1))\\n                return void Le(\\n                  e,\\n                  \\\"Invalid argument: \\\" + t.argString.substring(o)\\n                );\\n              var i = n.next();\\n              if (n.match(\\\"-\\\", !0)) {\\n                if (!n.match(/[a-zA-Z]/, !1))\\n                  return void Le(\\n                    e,\\n                    \\\"Invalid argument: \\\" + t.argString.substring(o)\\n                  );\\n                var a = i,\\n                  s = n.next();\\n                if (!((y(a) && y(s)) || (k(a) && k(s))))\\n                  return void Le(e, \\\"Invalid argument: \\\" + a + \\\"-\\\");\\n                var l = a.charCodeAt(0),\\n                  c = s.charCodeAt(0);\\n                if (c <= l)\\n                  return void Le(\\n                    e,\\n                    \\\"Invalid argument: \\\" + t.argString.substring(o)\\n                  );\\n                for (var u = 0; u <= c - l; u++) {\\n                  var h = String.fromCharCode(l + u);\\n                  delete r.marks[h];\\n                }\\n              } else delete r.marks[i];\\n            }\\n          else Le(e, \\\"Argument required\\\");\\n        },\\n      },\\n      Fe = new je();\\n    function We(e) {\\n      var t = e.state.vim,\\n        r = K.macroModeState,\\n        n = K.registerController.getRegister(\\\".\\\"),\\n        o = r.isPlaying,\\n        i = r.lastInsertModeChanges;\\n      o || (e.off(\\\"change\\\", De), Ze.off(e.getInputField(), \\\"keydown\\\", Qe)),\\n        !o &&\\n          1 < t.insertModeRepeat &&\\n          (ze(e, t, t.insertModeRepeat - 1, !0),\\n          (t.lastEditInputState.repeatOverride = t.insertModeRepeat)),\\n        delete t.insertModeRepeat,\\n        (t.insertMode = !1),\\n        e.setCursor(e.getCursor().line, e.getCursor().ch - 1),\\n        e.setOption(\\\"keyMap\\\", \\\"vim\\\"),\\n        e.setOption(\\\"disableInput\\\", !0),\\n        e.toggleOverwrite(!1),\\n        n.setText(i.changes.join(\\\"\\\")),\\n        Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"normal\\\" }),\\n        r.isRecording &&\\n          (function (e) {\\n            if (e.isPlaying) return;\\n            var t = e.latestRegister,\\n              r = K.registerController.getRegister(t);\\n            r &&\\n              r.pushInsertModeChanges &&\\n              r.pushInsertModeChanges(e.lastInsertModeChanges);\\n          })(r);\\n    }\\n    function Ve(e) {\\n      Ge.unshift(e);\\n    }\\n    function De(e, t) {\\n      var r,\\n        n,\\n        o = K.macroModeState,\\n        i = o.lastInsertModeChanges;\\n      if (!o.isPlaying)\\n        for (; t; ) {\\n          (i.expectCursorActivityForChange = !0),\\n            1 < i.ignoreCount\\n              ? i.ignoreCount--\\n              : (\\\"+input\\\" != t.origin &&\\n                  \\\"paste\\\" != t.origin &&\\n                  void 0 !== t.origin) ||\\n                (1 < (r = e.listSelections().length) && (i.ignoreCount = r),\\n                (n = t.text.join(\\\"\\\\n\\\")),\\n                i.maybeReset && ((i.changes = []), (i.maybeReset = !1)),\\n                n &&\\n                  (e.state.overwrite && !/\\\\n/.test(n)\\n                    ? i.changes.push([n])\\n                    : i.changes.push(n))),\\n            (t = t.next);\\n        }\\n    }\\n    function Ue(e) {\\n      var t = e.state.vim;\\n      if (t.insertMode) {\\n        var r = K.macroModeState;\\n        if (r.isPlaying) return;\\n        var n = r.lastInsertModeChanges;\\n        n.expectCursorActivityForChange\\n          ? (n.expectCursorActivityForChange = !1)\\n          : (n.maybeReset = !0);\\n      } else\\n        e.curOp.isVimOp ||\\n          (function (e, t) {\\n            var r = e.getCursor(\\\"anchor\\\"),\\n              n = e.getCursor(\\\"head\\\");\\n            t.visualMode && !e.somethingSelected()\\n              ? le(e, !1)\\n              : t.visualMode ||\\n                t.insertMode ||\\n                !e.somethingSelected() ||\\n                ((t.visualMode = !0),\\n                (t.visualLine = !1),\\n                Ze.signal(e, \\\"vim-mode-change\\\", { mode: \\\"visual\\\" }));\\n            {\\n              var o, i;\\n              t.visualMode\\n                ? ((o = Z(n, r) ? 0 : -1),\\n                  (i = Z(n, r) ? -1 : 0),\\n                  (n = q(n, 0, o)),\\n                  (r = q(r, 0, i)),\\n                  (t.sel = { anchor: r, head: n }),\\n                  ve(e, t, \\\"<\\\", G(n, r)),\\n                  ve(e, t, \\\">\\\", Y(n, r)))\\n                : t.insertMode || (t.lastHPos = e.getCursor().ch);\\n            }\\n          })(e, t);\\n      t.visualMode && Je(e);\\n    }\\n    function Je(e) {\\n      var t,\\n        r = \\\"cm-animate-fat-cursor\\\",\\n        n = e.state.vim,\\n        o = J(e, z(n.sel.head)),\\n        i = q(o, 0, 1);\\n      $e(n),\\n        o.ch == e.getLine(o.line).length\\n          ? (((t = document.createElement(\\\"span\\\")).textContent = \\\" \\\"),\\n            (t.className = r),\\n            (n.fakeCursorBookmark = e.setBookmark(o, { widget: t })))\\n          : (n.fakeCursor = e.markText(o, i, { className: r }));\\n    }\\n    function $e(e) {\\n      e.fakeCursor && (e.fakeCursor.clear(), (e.fakeCursor = null)),\\n        e.fakeCursorBookmark &&\\n          (e.fakeCursorBookmark.clear(), (e.fakeCursorBookmark = null));\\n    }\\n    function qe(e) {\\n      this.keyName = e;\\n    }\\n    function Qe(e) {\\n      var t = K.macroModeState.lastInsertModeChanges,\\n        r = Ze.keyName(e);\\n      r &&\\n        ((-1 == r.indexOf(\\\"Delete\\\") && -1 == r.indexOf(\\\"Backspace\\\")) ||\\n          Ze.lookupKey(r, \\\"vim-insert\\\", function () {\\n            return (\\n              t.maybeReset && ((t.changes = []), (t.maybeReset = !1)),\\n              t.changes.push(new qe(r)),\\n              !0\\n            );\\n          }));\\n    }\\n    function ze(r, n, e, t) {\\n      var o = K.macroModeState;\\n      o.isPlaying = !0;\\n      var i = !!n.lastEditActionCommand,\\n        a = n.inputState;\\n      function s() {\\n        i ? F.processAction(r, n, n.lastEditActionCommand) : F.evalInput(r, n);\\n      }\\n      function l(e) {\\n        var t;\\n        0 < o.lastInsertModeChanges.changes.length &&\\n          ((e = n.lastEditActionCommand ? e : 1),\\n          (t = o.lastInsertModeChanges),\\n          Xe(r, t.changes, e));\\n      }\\n      if (\\n        ((n.inputState = n.lastEditInputState),\\n        i && n.lastEditActionCommand.interlaceInsertRepeat)\\n      )\\n        for (var c = 0; c < e; c++) s(), l(1);\\n      else t || s(), l(e);\\n      (n.inputState = a), n.insertMode && !t && We(r), (o.isPlaying = !1);\\n    }\\n    function Xe(t, e, r) {\\n      function n(e) {\\n        return \\\"string\\\" == typeof e ? Ze.commands[e](t) : e(t), !0;\\n      }\\n      var o = t.getCursor(\\\"head\\\"),\\n        i = K.macroModeState.lastInsertModeChanges.visualBlock;\\n      i && (oe(t, o, i + 1), (r = t.listSelections().length), t.setCursor(o));\\n      for (var a = 0; a < r; a++) {\\n        i && t.setCursor(q(o, a, 0));\\n        for (var s = 0; s < e.length; s++) {\\n          var l,\\n            c,\\n            u,\\n            h = e[s];\\n          h instanceof qe\\n            ? Ze.lookupKey(h.keyName, \\\"vim-insert\\\", n)\\n            : \\\"string\\\" == typeof h\\n            ? ((l = t.getCursor()), t.replaceRange(h, l, l))\\n            : ((u = q((c = t.getCursor()), 0, h[0].length)),\\n              t.replaceRange(h[0], c, u));\\n        }\\n      }\\n      i && t.setCursor(q(o, 0, 1));\\n    }\\n    return (\\n      (Ze.keyMap.vim = { attach: o, detach: e, call: t }),\\n      M(\\\"insertModeEscKeysTimeout\\\", 200, \\\"number\\\"),\\n      (Ze.keyMap[\\\"vim-insert\\\"] = {\\n        fallthrough: [\\\"default\\\"],\\n        attach: o,\\n        detach: e,\\n        call: t,\\n      }),\\n      (Ze.keyMap[\\\"vim-replace\\\"] = {\\n        Backspace: \\\"goCharLeft\\\",\\n        fallthrough: [\\\"vim-insert\\\"],\\n        attach: o,\\n        detach: e,\\n        call: t,\\n      }),\\n      O(),\\n      I\\n    );\\n  })();\\n});\\n\"},\"$:/plugins/tiddlywiki/codemirror/keymaps/vim\":{\"title\":\"$:/plugins/tiddlywiki/codemirror/keymaps/vim\",\"module-type\":\"codemirror-keymap\",\"text\":\"vim\\n\"}}}"
}